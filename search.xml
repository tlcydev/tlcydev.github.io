<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试资料笔记整理01</title>
      <link href="/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/"/>
      <url>/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/</url>
      
        <content type="html"><![CDATA[<h2 id="php-数组底层实现原理"><a href="#php-数组底层实现原理" class="headerlink" title="php 数组底层实现原理"></a>php 数组底层实现原理</h2><ol><li>底层实现是通过散列表（hash table） + 双向链表（解决hash冲突）<br> hashtable：将不同的关键字（key）通过映射函数计算得到散列值（Bucket-&gt;h） 从而直接索引到对应的Bucket<br> hash表保存当前循环的指针，所以foreach 比for更快<br> Bucket：保存数组元素的key和value，以及散列值h</li><li>如何保证有序性<ol><li>散列函数和元素数组（Bucket）中间添加一层大小和存储元素数组相同的映射表。</li><li>用于存储元素在实际存储数组中的下标</li><li>元素按照映射表的先后顺序插入实际存储数组中</li><li>映射表只是原理上的思路，实际上并不会有实际的映射表，而是初始化的时候分配Bucket内存的同时，还会分配相同数量的 uint32_t 大小的空间，然后将 arData 偏移到存储元素数组的位置。        </li></ol></li><li>解决hash重复(php使用的链表法)：<ol><li>链表法:不同关键字指向同一个单元时，使用链表保存关键字（遍历链表匹配key） </li><li>开放寻址法：当关键字指向已经存在数据的单元的时候，继续寻找其他单元，直到找到可用单元（占用其他单元位置，更容易出现hash冲突，性能下降）</li></ol></li><li>基础知识<br>  链表：队列、栈、双向链表、<br>  链表    ：元素 + 指向下一元素的指针<br>  双向链表：指向上一元素的指针 + 元素 + 指向下一元素的指针</li></ol><h2 id="冒泡排序的时间复杂度和空间复杂度"><a href="#冒泡排序的时间复杂度和空间复杂度" class="headerlink" title="冒泡排序的时间复杂度和空间复杂度"></a>冒泡排序的时间复杂度和空间复杂度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1. 代码实现</span><br><span class="line">        $arr = [2, 4, 1, 5, 3, 6];</span><br><span class="line">        for ($i = 0; $i &lt; (count($arr)); $i++) &#123;</span><br><span class="line">            for ($j = $i + 1; $j &lt; (count($arr)); $j++) &#123;</span><br><span class="line">                if ($arr[$i] &lt;= $arr[$j]) &#123;</span><br><span class="line">                    $temp = $arr[$i];</span><br><span class="line">                    $arr[$i] = $arr[$j];</span><br><span class="line">                    $arr[$j] = $temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    result : [6,5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">    评论区有其他同学对于上面的写法有不用意见（第一种写法虽然能达到排序的目的，但是他觉得按照冒泡排序的明确定义来说不是冒泡排序），所以另一种写法我也列举出来，有更专业的大佬们可以指正一下,代码实现如下  </span><br><span class="line">$list = [2, 4, 1, 7, 9, 3];</span><br><span class="line">$len = count($list);</span><br><span class="line"></span><br><span class="line">for ($i = $len - 1; $i &gt; 0; $i--) &#123;</span><br><span class="line">    for ($j = 0; $j &lt; $i; $j++) &#123;</span><br><span class="line">        if ($list[$j] &gt; $list[$j + 1]) &#123;</span><br><span class="line">            $tmp = $list[$j];</span><br><span class="line">            $list[$j] = $list[$j + 1];</span><br><span class="line">            $list[$j + 1] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($list);</span><br><span class="line"></span><br><span class="line">2. 计算原理</span><br><span class="line">    第一轮：将数组的第一个元素和其他所有的元素进行比较，哪个元素更大，就换顺序，从而冒泡出第一大（最大）的元素</span><br><span class="line">    第一轮：将数组的第二个元素和其他所有的元素进行比较（第一大已经筛选出来不用继续比较了），哪个元素更大，就换顺序，从而冒泡出第二大的元素</span><br><span class="line">    ... 依次类推，冒泡从大到小排序的数组</span><br><span class="line"></span><br><span class="line">    平均时间复杂度：O(n^2)  ：</span><br><span class="line">    最优时间复杂度：O(n) ：需要加判断，第一次循环如果一次都没有交换就直接跳出循环</span><br><span class="line"></span><br><span class="line">    空间复杂度：O(1)，交换元素的时候的临时变量占用的空间</span><br><span class="line">    最优空间复杂度：O(1)，排好序，不需要交换位置</span><br><span class="line">3. 时间复杂度和空间复杂度</span><br><span class="line">    时间复杂度：全程为渐进时间复杂度，估算对处理器的使用效率（描述算法的效率趋势，并不是指算法具体使用的时间，因为不同机器的性能不一致，只是一种效率计算的通用方法）</span><br><span class="line">    表示方法：大O符号表示法 </span><br><span class="line">    复杂度量级：</span><br><span class="line">        常数阶O(1)</span><br><span class="line">        线性阶O(n)</span><br><span class="line">        平方阶O(n²)</span><br><span class="line">        立方阶O(n³)</span><br><span class="line">        K次方阶O(n^k)</span><br><span class="line">        指数阶(2^n)</span><br><span class="line">        对数阶O(logN)</span><br><span class="line">        线性对数阶O(nlogN)</span><br><span class="line">    时间复制类型：</span><br><span class="line">        最好时间复杂度</span><br><span class="line">        最坏时间复杂度</span><br><span class="line">        平均时间复杂度</span><br><span class="line">        均摊时间复杂度</span><br><span class="line"></span><br><span class="line">    空间复杂度：全程渐进空间复杂度，估算对计算机内存的使用程度（描述算法占用的存储空间的趋势，不是实际占用空间，同上）</span><br></pre></td></tr></table></figure><h2 id="网络七层协议及-TCP-和-UDP"><a href="#网络七层协议及-TCP-和-UDP" class="headerlink" title="网络七层协议及 TCP 和 UDP"></a>网络七层协议及 TCP 和 UDP</h2><p> 应用层、表示层、会话层、传输层、网络层、（数据）链路层、物理层<br><kbd> 记忆套路：<br> 首字：应表会传（物链网）<br>             第一个字：应用层（出现次数多，易忆）<br>            前四个正向：应表 - 会传<br>            后三个反向：物联网谐音比网链物更好记<br></kbd></p><h2 id="TCP-和-UDP-的特点和区别"><a href="#TCP-和-UDP-的特点和区别" class="headerlink" title="TCP 和 UDP 的特点和区别"></a>TCP 和 UDP 的特点和区别</h2><ol><li><p>都是属于传输层协议</p></li><li><p>TCP</p><ol><li>面向连接，所以只能一对一</li><li>面向字节流传输</li><li>数据可靠，不丢失</li><li>全双工通信</li></ol></li><li><p>UDP（根据TCP特点反记）</p><ol><li>无连接，支持一对一，一对多，多对多</li><li>面向报文传输</li><li>首部开销小，数据不一定可靠但是速度更快<h2 id="TCP-的三次握手和四次挥手"><a href="#TCP-的三次握手和四次挥手" class="headerlink" title="TCP 的三次握手和四次挥手"></a>TCP 的三次握手和四次挥手</h2></li></ol></li><li><p>三次握手：</p><ol><li>第一次：客户端发送SYN = 1,seq = client_isn<br>作用：<br>客户端：无<br>服务端：确认自己的接收功能和客户端的发送功能</li><li>第二次：服务端发送SYN = 1,seq = server_isn,ACK =client_isn +1<br>作用：<br>客户端：确认自己发送和接收都正常，确认服务端的接收和发送正常<br>服务端：确认自己的接收正常，确认服务端的发送正常（这时候服务端还不能确认客户端接收是否正常）</li><li>第三次：客户端发送SYN = 0,  ACK =  server_isn+1,seq =client_isn+1<br>作用：双方确认互相的接收和发送正常，建立连接</li></ol></li><li><p>四次挥手</p><ol><li>第一次:客户端发送FIN<br> 作用：告诉服务端我没有数据发送了（但是还能接收数据）</li><li>第二次：服务端发送ACK<br> 作用：告诉客户端收到请求了，可能服务端可能还有数据需要发送，所以客户端收到进入FIN_WAIT状态，等服务端数据传输完之后发送FIN</li><li>第三次：服务端发送FIN<br> 作用：服务端告诉客户端我发送完了，可以关闭连接了。</li><li>第四次:客户端发送ACK<br> 作用：客户端收到FIN之后，担心服务端不知道要关闭，所以发送一个ACK，进入TIME_WAIT，等待2MSL之后如果没有收到回复，证明服务端已经关闭了，这时候客户端也关闭连接。<blockquote><p>注意：</p></blockquote></li><li>当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据</li><li>最后需要等待2MSL是因为网络是不可靠的，如果服务端没有收到最后一次ACK,服务端会重新放FIN包然后等客户端再次发送ACK包然后关闭（所以客户端最后发送ACK之后不能立即关闭连接）</li></ol></li></ol><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><ol><li><p>状态码分类  </p><pre><code> - 1xx：信息，服务器收到请求，需要请求者继续操作 - 2xx：成功 - 3xx：重定向 - 4xx：客户端错误 - 5xx：服务端错误</code></pre></li><li><p>常用状态码</p><p> 200：请求成功<br> 301：永久重定向<br> 302：临时移动<br> 400 bad request：客户端请求语法错误<br> 401 unauthorized：客户端没有权限<br> 403 forbidden：服务器拒绝客户端请求<br> 404 not found：客户端请求资源不存在<br> 500 Internal Server Eerro：服务器内部错误<br> 502 bad gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应<br> 503 Service Unavailable 超载或系统维护<br> 504 Gateway timeout：网关超时</p></li><li><p>502 的原因及解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">原因：nginx将请求提交给网关（php-fpm）处理异常导致</span><br><span class="line">    1. fastcgi 缓冲区设置过小</span><br><span class="line">        fastcgi_buffers 8 16k;</span><br><span class="line">         fastcgi_buffer_size 32k;</span><br><span class="line">    2. php-cgi的进程数设置过少</span><br><span class="line">        查看FastCgi进程数：netstat -anpo | grep &quot;php-cgi&quot;| wc -l</span><br><span class="line">        调整参数最大子进程数：max_children</span><br><span class="line">            一般按照单个进程20M计算需要需要设置的子进程数 </span><br><span class="line">    3. max_requests（内存溢出或频繁重启）</span><br><span class="line">        参数指明每个children最多能处理的请求数量，到达最大值之后会重启children。</span><br><span class="line">        设置过小可能导致频繁重启children：</span><br><span class="line">            php将请求轮询给每个children，在大流量的场景下，每一个children 到达最大值的时间差不多，如果设置过小可能多个children 在同一时间关闭，nginx无法将请求转发给php-fpm，cpu降低，负载变高。</span><br><span class="line">        设置过大可能导致内存泄露</span><br><span class="line">    4. php执行时间超过nginx等待时间</span><br><span class="line">            fastcgi_connect_timeout</span><br><span class="line">            fastcgi_send_timeout</span><br><span class="line">            fastcgi_read_timeout</span><br><span class="line">    5. fastcgi执行时间</span><br><span class="line">        max_execution_time</span><br></pre></td></tr></table></figure><h2 id="http-和-HTTPS-的区别"><a href="#http-和-HTTPS-的区别" class="headerlink" title="http 和 HTTPS 的区别"></a>http 和 HTTPS 的区别</h2></li><li><p>端口：http 80； https ：443</p></li><li><p>http无状态，https是有http + ssl构建的可进行加密传输的协议</p></li><li><p>http明文传输，https加密传输</p></li><li><p>http更快，三次握手三个包，https 需要12个包（3个tcp包+9个ssl握手包）</p></li></ol><h2 id="redis-分布式锁及问题"><a href="#redis-分布式锁及问题" class="headerlink" title="redis 分布式锁及问题"></a>redis 分布式锁及问题</h2><ol><li>实现：<br> 加锁：setnx<br> 解锁：del<br> 锁超时：expire</li><li>可能出现的问题<ol><li>setnx 和expire非原子性问题（加锁之后还没来得及设置超时就挂了）<br> 解决方案：<pre><code> Redis 2.6.12以上版本为set指令增加了可选参数，伪代码如下：set（key，1，30，NX）,这样就可以取代setnx指令</code></pre></li><li>超时误删其他进程锁。（A进程执行超时，导致锁释放，这时候B进程获取锁开始处理请求，这时候A进程处理完成，会误删B进程的锁）<br> 解决方案：只能删除自己进程的锁 （lua脚本防止B进程获取过期锁之后误删A进程的锁） </li><li>并发场景，A进程执行超时导致锁释放，这时候B进程获取到锁。<br> 解决方案：开启守护进程，给当前进程要过期的锁延时。</li><li>单点实例安全问题<br> 单机宕机之后导致所有客户端无法获取锁<br> 解决：<pre><code> 主从复制，因为是异步完成的所以无法完全实现解决</code></pre></li></ol></li></ol><h2 id="redis-的数据类型及应用场景"><a href="#redis-的数据类型及应用场景" class="headerlink" title="redis 的数据类型及应用场景"></a>redis 的数据类型及应用场景</h2><ol><li>string ：<br> 普通的key/value存储</li><li>hash：<br> hashmap：键值队集合，存储对象信息</li><li>list：<br> 双向链表:消息队列</li><li>set：<br> value永远为null的hashMap：无序集合且不重复：计算交集、并集、差集、去重值</li><li>zset：<br> 有序集合且不重复:hashMap(去重) + skiplist跳跃表（保证有序）：排行榜</li></ol><h2 id="redis-实现持久化的方式及原理、特点"><a href="#redis-实现持久化的方式及原理、特点" class="headerlink" title="redis 实现持久化的方式及原理、特点"></a>redis 实现持久化的方式及原理、特点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. RDB持久化（快照）：指定时间间隔内的内存数据集快照写入磁盘        </span><br><span class="line">        1. fork一个子进程，将快照内容写入临时RDB文件中（dump.rdb），当子进程写完快照内容之后新的文件替换老的文件</span><br><span class="line">        2. 整个redis数据库只包含一个备份文件</span><br><span class="line">        3. 性能最大化，只需要fork子进程完成持久化工作，减少磁盘IO</span><br><span class="line">        4. 持久化之前宕机可能会导致数据丢失        </span><br><span class="line">2. AOF持久化 ：以日志的形式记录服务器的所有的写、删除操作</span><br><span class="line">        1. 每接收到一个写的命令用write函数追加到文件appendonly.aof</span><br><span class="line">        2. 持久化的文件会越来越大，存在大量多余的日志（0 自增100次到100，会产生100条日志记录）</span><br><span class="line">        3. 可以设置不同的fsync策略</span><br><span class="line">            1. appendfsync everysec ：1s一次，最多丢失1s的数据（默认）</span><br><span class="line">            2. appendfsync always    ：每次变动都会执行一次</span><br><span class="line">            3. appendfsync no          ：不处理</span><br><span class="line">        4. AOF文件太大之后会进行重写：压缩AOF文件大小</span><br><span class="line">            1. fork一个子进程，将redis内地数据对象的最新状态写入AOF临时文件（类似rdb快照）</span><br><span class="line">            2. 主进程收到的变动会先写入内存中，然后同步到老的AOF文件中（重写失败之后也能保证数据完整性）</span><br><span class="line">            3. 子进程完成重写之后会将内存中的新变动同步追加到AOF的临时文件中</span><br><span class="line">            4. 父进程将临时AOF文件替换成新的AOF文件，并重命名。之后收到的新命令写入到新的文件中</span><br></pre></td></tr></table></figure><h2 id="秒杀设计流程及难点"><a href="#秒杀设计流程及难点" class="headerlink" title="秒杀设计流程及难点"></a>秒杀设计流程及难点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 静态缓存</span><br><span class="line">2. nginx 负载均衡  </span><br><span class="line">    三种方式：DNS轮询、IP负债均衡、CDN</span><br><span class="line">3. 限流机制</span><br><span class="line">    方式：ip限流、接口令牌限流、用户限流、header动态token（前端加密，后端解密）</span><br><span class="line">4. 分布式锁</span><br><span class="line">    方式：</span><br><span class="line">        1. setnx + expire （非原子性，redis2.6 之后set保证原子性）</span><br><span class="line">        2. 释放锁超时 （开启守护进程自动续时间）</span><br><span class="line">        3. 过期锁误删其他线程（requestId验证或者lua脚本保证查 + 删的原子性）</span><br><span class="line">5. 缓存数据</span><br><span class="line">    方式：</span><br><span class="line">        1. 缓存击穿：缓存数据预热 + 布隆过滤器/空缓存 </span><br><span class="line">        2. 缓存雪崩：缓存设置随机过期时间，防止同一时间过期</span><br><span class="line">6. 库存及订单</span><br><span class="line">    1. 扣库存</span><br><span class="line">        1. redis 自减库存，并发场景下可能导致负数，影响库存回仓：使用lua脚本保证原子性</span><br><span class="line">        2. redis预扣库存之后，然后使用异步消息创建订单并更新库存变动 </span><br><span class="line">        3. 数据库更新库存使用乐观锁：where stock_num - sell_num &gt; 0</span><br><span class="line">        4. 添加消息发送记录表及重试机制，防止异步消息丢失</span><br><span class="line">    2. 创建订单</span><br><span class="line">        1. 前端建立websocket连接或者轮询监听订单状态</span><br><span class="line">        2. 消费验证记录状态，防止重复消费</span><br><span class="line">    3. 回仓</span><br><span class="line">        1. 创建订单之后发送延时消息，验证订单支付状态及库存是否需要回仓 </span><br></pre></td></tr></table></figure><h2 id="防-sql-注入"><a href="#防-sql-注入" class="headerlink" title="防 sql 注入"></a>防 sql 注入</h2><ol><li>过滤特殊字符</li><li>过滤数据库关键字</li><li>验证数据类型及格式</li><li>使用预编译模式，绑定变量</li></ol><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. 标准的sql隔离级别实现原理</span><br><span class="line">    1. 未提交读：其他事务可以直接读到没有提交的：脏读</span><br><span class="line">        1. 事务对当前被读取的数据不加锁</span><br><span class="line">        2. 在更新的瞬间加行级共享锁到事务结束释放</span><br><span class="line">    2. 提交读：事务开始和结束之间读取的数据可能不一致，事务中其他事务修改了数据：不可重复度</span><br><span class="line">        1. 事务对当前读取的数据（被读到的时候）行级共享锁，读完释放</span><br><span class="line">        2. 在更新的瞬间加行级排他锁到事务结束释放</span><br><span class="line">    3. 可重复读：事务开始和结束之前读取的数据保持一致，事务中其他事务不能修改数据：可重复读</span><br><span class="line">        1. 事务对当前读到的数据从事务一开始就加一个行级共享锁</span><br><span class="line">        2. 在更新的瞬间加行级排他锁到事务结束释放</span><br><span class="line">        3. 其他事务再事务过程中可能会新增数据导致幻读 </span><br><span class="line">    4. 串行化</span><br><span class="line">        1. 事务读取数据时加表级共享锁</span><br><span class="line">        2. 事务更新数据时加表级排他锁</span><br><span class="line">2. innodb的事务隔离级别及实现原理（！！和上面的不一样，区分理解一个是隔离级别 一个是！！事务！！隔离级别）</span><br><span class="line">    1. 基本概念</span><br><span class="line">        1. mvcc:多版本并发控制:依赖于undo log 和read view</span><br><span class="line">            1. 让数据都读不会对数据加锁，提高数据库并发处理能力</span><br><span class="line">            2. 写操作才会加锁</span><br><span class="line">            3. 一条数据有多个版本，每次事务更新数据的时候会生成一个新的数据版本，旧的数据保留在undo log</span><br><span class="line">            4. 一个事务启动的时候只能看到所有已经提交的事务结果</span><br><span class="line">        1. 当前读：读取的是最新版本</span><br><span class="line">        2. 快照读:读取的是历史版本</span><br><span class="line">        4. 间隙锁：间隙锁会锁住一个范围内的索引</span><br><span class="line">            1. update id between 10 and 20 </span><br><span class="line">            2. 无论是否范围内是否存在数据，都会锁住整个范围：insert id = 15，将被防止</span><br><span class="line">            3. 只有可重复读隔离级别才有间隙锁</span><br><span class="line">        5. next-key lock：</span><br><span class="line">            1. 索引记录上的记录锁+ 间隙锁（索引值到前一个索引值之间的间隙锁）</span><br><span class="line">            2. 前开后闭</span><br><span class="line">            3. 阻止幻读</span><br><span class="line">    事务隔离级别</span><br><span class="line">        1. 未提交读</span><br><span class="line">            1. 事务对当前读取的数据不加锁，都是当前读</span><br><span class="line">            2. 在更新的瞬间加行级共享锁到事务结束释放</span><br><span class="line">        2. 提交读</span><br><span class="line">            1. 事务对当前读取的数据不加锁，都是快照读</span><br><span class="line">            2. 在更新的瞬间加行级排他锁到事务结束释放</span><br><span class="line">        3. 可重复读</span><br><span class="line">            1. 事务对当前读取的数据不加锁，都是快照读</span><br><span class="line">            2. 事务再更新某数据的瞬间，必须加行级排他锁（Record 记录锁、GAP间隙锁、next-key 锁），事务结束释放</span><br><span class="line">            3. 间隙锁解决的是幻读问题</span><br><span class="line">                    1. 主从复制的情况下 ,如果没有间隙锁，master库的A、B进程 </span><br><span class="line">                    2. A进程 delete id &lt; 6 ;然后还没有commit</span><br><span class="line">                    3. B进程insert id = 3，commit</span><br><span class="line">                    4. A进程提交commit</span><br><span class="line">                    5. 该场景下，主库会存在一条id =3 的记录，但是binlog里面是先删除再新增就会导致从库没有数据，导致主从的数据不一致</span><br><span class="line">            4. MVCC的快照解决的是不可重复读问题</span><br><span class="line">        4. 串行化</span><br><span class="line">            1. 事务读取数据时加表级，当前读</span><br><span class="line">            2. 事务更新数据时加表级排他锁</span><br></pre></td></tr></table></figure><h2 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">索引就是帮助数据库高效查找数据的存储结构，存储再磁盘中，需要消耗磁盘IO</span><br><span class="line">1. 存储引擎</span><br><span class="line">    1. myisam 支持表锁，索引和数据分开存储适合跨服务器迁移</span><br><span class="line">    2. innodb 支持行锁，索引和数据存储再一个文件</span><br><span class="line">2. 索引类型</span><br><span class="line">    1. hash索引</span><br><span class="line">        1. 适合精确查询且效率高</span><br><span class="line">        2. 无法排序、不适合范围查询</span><br><span class="line">        3. hash冲突的情况下需要遍历链表（php数组的实现原理、redis zset 的实现原理类似）</span><br><span class="line">    2. b-tree、b+tree</span><br><span class="line">        1. b-tree 和b+tree的去区别</span><br><span class="line">            1. b+tree 的数据全部存储在叶子节点，内部节点只存key,一次磁盘IO能获取到更多的节点</span><br><span class="line">            2. b-tree 的内部节点和叶子节点都存储key和数据，查找数据不需要找到叶子节点，内部节点可以直接返回数据</span><br><span class="line">            3. b+tree 增加了叶子节点到相邻节点的指针，方便返回查询遍历</span><br><span class="line">    3. 聚簇索引和非聚簇索引</span><br><span class="line">        1. 概念</span><br><span class="line">            1. 聚簇索引  :索引和数据存储在一个节点</span><br><span class="line">            2. 非聚簇索引:索引和数据分开存储，通过索引找到数据实际存储的地址</span><br><span class="line">        2. 详解:</span><br><span class="line">            1. innodb 使用的聚簇索引,且默认主键索引为聚簇索引（没有主键索引的时候，选择一个非空索引，还没有则隐式的主键索引），辅助索引指向聚簇索引位置，然后在找到实际存储地址</span><br><span class="line">            2. myisam 使用非聚簇索引，所有的索引都只需要查询一次就能找到数据</span><br><span class="line">            3. 聚簇索引的优势和略势</span><br><span class="line">                1. 索引和数据在一起，同一页的数据会被缓存到（buffer）内存中，所以查看同一页数据的时候只需要从内存中取出，</span><br><span class="line">                2. 数据更新之后之只需要维护主键索引即可，辅助索引不受影响</span><br><span class="line">                3. 辅助索引存的是主键索引的值，占用更多的物理空间。所以会受到影响</span><br><span class="line">                4. 使用随机的UUID，数据分布不均匀，导致聚簇索引可能扫全表，降低效率，所以尽量使用自增主键id </span><br><span class="line"></span><br><span class="line">## 索引原理补充（2022-03-11）</span><br><span class="line">1. 索引原理</span><br><span class="line">    1. 磁盘IO： </span><br><span class="line">        1. 寻道时间：指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下</span><br><span class="line">        2. 旋转延迟：指的是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms</span><br><span class="line">        3. 传输时间：指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</span><br><span class="line">        4. 磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右</span><br><span class="line">    2. 预读</span><br><span class="line">        1. 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)</span><br><span class="line">        2. 具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</span><br><span class="line">    3. B+tree</span><br><span class="line">        1. 一次IO将一页的数据加载到内存中</span><br><span class="line">        2. 为什么索引字段尽量小并且数据只存在叶子节点：字节越少，每次IO请求扫描的节点就越多</span><br><span class="line">            1. 假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低</span><br><span class="line">        3. 最左前缀特性：b+数是按照从左到右的顺序来建立搜索树的</span><br><span class="line">2. 索引创建原则</span><br><span class="line">    1. 最左前缀原则：mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。联合索引（A,B,C） = (A) + (A,B) +(A,B,C) （更新于2022-03-02：之前错误写法： (A) + (B) + (C) + (A,B) +(A,B,C)）</span><br><span class="line">    2. =和in可以乱序,mysql查询优化器会自动识别成需要使用索引的类型</span><br><span class="line">    3. 尽量选择区分度高的列作为索引</span><br><span class="line">    4. 索引列不能参与计算</span><br><span class="line">    5. 尽量的扩展索引，不要新建索引，入过已经存在A索引 需要加一个新的索引，建议修改原来的索引为（A,B）联合索引    </span><br><span class="line">4. OR 是否能走索引及原理</span><br><span class="line">5. GROUP BY 是否能走索引及原理</span><br><span class="line">6. ORDER BY 能否走索引及原理</span><br></pre></td></tr></table></figure><h2 id="分表-分库-的策略"><a href="#分表-分库-的策略" class="headerlink" title="分表 (分库) 的策略"></a>分表 (分库) 的策略</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 流程</span><br><span class="line">    评估容量和分表数量-&gt; 根据业务选定分表key-&gt;分表规则（hash、取余、range）-&gt;执行-&gt;考虑扩容问题</span><br><span class="line">2. 水平拆分</span><br><span class="line">    1. 根据字段水平拆分为多个表</span><br><span class="line">    2. 每个表的结构相同</span><br><span class="line">    3. 所有分表的合集是全量数量</span><br><span class="line">3. 垂直拆分</span><br><span class="line">    1. 根据字段垂直拆分</span><br><span class="line">    2. 表结构不一样，分表的同一个关联行是一条完整的数据</span><br><span class="line">    3. 扩展表，热点字段和非热点字段的拆分（列表和详情的拆分）</span><br><span class="line">    4. 获取数据时，尽量避免使用join，而是两次查询结果组合</span><br><span class="line">4. 问题</span><br><span class="line">    1. 跨库join问题</span><br><span class="line">        1. 全局表：需要关联部分系统表的场景</span><br><span class="line">        2. 冗余法：常用字段进行冗余</span><br><span class="line">        3. 组装法：多次查询的结果进行组装</span><br><span class="line">    2. 跨节点的分页、排序、函数问题</span><br><span class="line">    3. 事务一致性</span><br><span class="line">    4. 全局主键id</span><br><span class="line">        1. 使用uuid -&gt; 会降低聚簇索引效率</span><br><span class="line">        2. 使用分布式自增id</span><br><span class="line">    5. 扩容问题</span><br><span class="line">        1. 升级从库</span><br><span class="line">            1. 从库升级为主库，数据一致，只需要删除冗余数据即可</span><br><span class="line">            2. 成倍扩容：需要在加一倍从库</span><br><span class="line">        2. 双写迁移：</span><br><span class="line">            1. 新数据进行双写，同时写进新老数据库</span><br><span class="line">            2. 旧数据复制到新数据库</span><br><span class="line">            3. 以老数据库为准，验证数据一致性之后删除冗余数据</span><br></pre></td></tr></table></figure><h2 id="select-和-update-的执行流程"><a href="#select-和-update-的执行流程" class="headerlink" title="select 和 update 的执行流程"></a>select 和 update 的执行流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1. mysql 构成</span><br><span class="line">    1. server层：连接器-&gt;缓存器-&gt;分析器(预处理器)-&gt;优化器-&gt;执行器</span><br><span class="line">    2. 引擎层  ： 查询和存储数据</span><br><span class="line">2. select 执行过程</span><br><span class="line">    1. 客户端发送请求，建立连接</span><br><span class="line">    2. server层查找缓存，命中直接返回，否则继续</span><br><span class="line">    3. 分析七分析sql语句以及预处理（验证字段合法性及类型等）</span><br><span class="line">    4. 优化器生成执行计划</span><br><span class="line">    5. 执行器调用引擎API查询结果</span><br><span class="line">    6. 返回查询结果</span><br><span class="line">3. update执行过程</span><br><span class="line">    1. 基础概念</span><br><span class="line">        1. buffer pool(缓存池),在内存中，下次读取同一页的数据的时候可以直接从buffer pool中返回（innodb的聚簇索引）</span><br><span class="line">        2. 更新数据的时候先更新buffer pool,然后在更新磁盘</span><br><span class="line">        3. 脏页:内存中的缓存池更新了,但是没有更新磁盘</span><br><span class="line">        4. 刷脏:inndb 中有一个专门的进程将buffer pool的数据写入磁盘，每隔一段时间将多个修改一次性写入磁盘</span><br><span class="line">        5. redo log 和 binlog</span><br><span class="line">            1. redo log(重做日志),innodb特有的日志，物理日志，记录修改</span><br><span class="line">            2. redo log是重复写,空间固定且会用完,会覆盖老日志</span><br><span class="line">            3. binlog 是server层共有的日志，逻辑日志,记录语句的原始逻辑</span><br><span class="line">            4. binlog 是追加写到一定大小切换到下一个,不会覆盖以前的日志</span><br><span class="line">            5. redo log主要是用来恢复崩溃，bin log是用来记录归档的二进制日志</span><br><span class="line">            6. redo log只能恢复短时间内的数据，binlog可以通过设置恢复更大的数据</span><br><span class="line">        6. WAL（write-ahead-logging）先写日志方案</span><br><span class="line">            1. 记录日志是顺序IO</span><br><span class="line">            2. 直接写入磁盘（刷盘）是随机IO,因为数据是随机的,可能分布在不同的扇区</span><br><span class="line">            3. 顺序IO的效率更高,先写入修改日志,可以延迟刷盘时机，提高吞吐量</span><br><span class="line">        7. redo log 刷盘机制，check point</span><br><span class="line">            1. redo log大小固定,循环写入</span><br><span class="line">            2. redo log 就像一个圆圈,前面是check point (到这个point就开始覆盖老的日志),后面是write point (当前写到的位置)</span><br><span class="line">            2. write point 和check point 重叠的时候就证明redo log 满了,需要开始同步redo log 到磁盘中了</span><br><span class="line">    2. 执行步骤（两阶段提交 - 分布式事务，保证两个日志的一致性）</span><br><span class="line">        1. 分析更新条件,查找需要更新的数据（会用到缓存）</span><br><span class="line">        2. server 调用引擎层的API,Innodb 更新数据到内存中，然后写入redo log，然后进入prepare</span><br><span class="line">        3. 引擎通知server层开始提交数据</span><br><span class="line">        4. server层写入binlog 日志,并且调用innodb 的接口发出commit请求</span><br><span class="line">        5. 引擎层收到请求之后提交commit</span><br><span class="line">    3. 宕机后数据崩溃恢复规则</span><br><span class="line">        1. 如果redo log 状态为commit ,则直接提交</span><br><span class="line">        2. 如果redo log 状态为prepare,则判断binlog 中的事务是否commit,是则提交，否则回滚</span><br><span class="line">    4. 如果不使用两次提交的错误案例（update table_x set value = 10 where value = 9）</span><br><span class="line">        1. 先redo log 再写入binlog</span><br><span class="line">            1. redo log 写完之后，binlog没写完，这时候宕机。</span><br><span class="line">            2. 重启之后redo log 完整，所以恢复数据 value = 10 </span><br><span class="line">            3. bin log日志中没有记录，如果需要恢复数据的时候 value = 9</span><br><span class="line">        2. 先写binlog 再写redo log</span><br><span class="line">            1. binlog 写入完成，redo log 未完成</span><br><span class="line">            2. 重启之后没有redo log ，所以value 还是9</span><br><span class="line">            3. 当需要恢复数据的时候binlog 日志完整，value 更新成10</span><br><span class="line">    5. undo log </span><br><span class="line">        1. 在更新写入buffer pool之前记录</span><br><span class="line">        2. 如果更新过程中出错，直接回滚到undo log 的状态 </span><br></pre></td></tr></table></figure><h2 id="binlog-的作用和三种格式"><a href="#binlog-的作用和三种格式" class="headerlink" title="binlog 的作用和三种格式"></a>binlog 的作用和三种格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">    1. 数据恢复</span><br><span class="line">    2. 主从复制</span><br><span class="line">格式（二进制文件）：</span><br><span class="line">    1. statement </span><br><span class="line">        1. 记录每次sql语句的原文</span><br><span class="line">        2. 删除一个表只需要记录一条sql语句，不需要记录每一行的变化，节约IO，提高性能，减少日志量</span><br><span class="line">        3. 可能出现主从不一致（存储过程、函数等）</span><br><span class="line">        4. RC隔离级别（读提交），因为binlog 记录顺序是按照事务commit 顺序记录的，所以可能导致主从复制不一致。通过可重复读级别的间隙锁的引入，可以解决。</span><br><span class="line">    2. row          </span><br><span class="line">        1. 记录每条记录的修改情况，不需要记录sql语句的上下文记录</span><br><span class="line">        2. 导致binlog日志量很大</span><br><span class="line">        3. 删除一个表：记录每条记录都被删除的状况 </span><br><span class="line">    3. mixed</span><br><span class="line">        1. 前两个格式的混合版</span><br><span class="line">        2. 根据语句自动选择使用哪一种：</span><br><span class="line">            1. 一般的sql语句修改使用statement</span><br><span class="line">            2. 修改表结构、函数、存储过程等操作选择row</span><br><span class="line">            3. update 和delete 还是会记录全部记录的变化</span><br></pre></td></tr></table></figure><h2 id="主从同步（主从复制）的原理和问题及读写分离"><a href="#主从同步（主从复制）的原理和问题及读写分离" class="headerlink" title="主从同步（主从复制）的原理和问题及读写分离"></a>主从同步（主从复制）的原理和问题及读写分离</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">1. 解决的问题</span><br><span class="line">    1. 数据分布</span><br><span class="line">    2. 负载均衡</span><br><span class="line">    3. 数据备份，高可用，避免单点失败</span><br><span class="line">    4. 实现读写分离，缓解数据库压力</span><br><span class="line">    5. 升级测试（使用高版本mysql当从库）</span><br><span class="line">2. 支持的复制类型（binlog 的三种格式）</span><br><span class="line">    1. 基于sql语句的复制</span><br><span class="line">    2. 基于行的复制</span><br><span class="line">    3. 混合型复制</span><br><span class="line">3. 原理</span><br><span class="line">    1. 基础概念</span><br><span class="line">        1. 从库生成两个线程</span><br><span class="line">            1. I/O线程</span><br><span class="line">            2. SQL线程</span><br><span class="line">        2. 主库生成线程</span><br><span class="line">            1. log dumo 线程</span><br><span class="line">    2. 流程（主节点必须开启bin log功能，）</span><br><span class="line">        1. 从节点开启start slave 命令之后，创建一个IO进程连接到主节点</span><br><span class="line">        2. 连接成功之后，主节点创建一个 log dump线程(主节点会为每一个从节点创一个log dump线程)</span><br><span class="line">        3. 当binlog发生变化时，主节点的dump log线程会读取bin-log内容并发送给从节点</span><br><span class="line">        4. 主节点dump log 线程读取bin-log 的内容时会对主节点的bin-log加锁，读取完成在发送给从节点之前释放锁</span><br><span class="line">        5. 从节点的IO线程接收主节点发送的binlog内容，并将其写入本地relay log 文件中</span><br><span class="line">        6. 主从节点通过binlog文件+position偏移量定位主从同步的位置，从节点会保存接收到的position偏移量，如果从节点发生宕机重启，自动从postion位置发起同步</span><br><span class="line">        7. 从节点的SQL线程复制读取本地relay log的内容，解析成具体的操作并执行，保证主从数据一致性</span><br><span class="line">    4. 主从复制的模式</span><br><span class="line">        1. 异步模式（默认方式）</span><br><span class="line">            1. 可能导致主从不一致（主从延时）</span><br><span class="line">            2. 主节点接收到客户端提交的事务之后直接提交事务并返回给客户端</span><br><span class="line">            3. 如果主节点事务提交之后，log dump还没来得及写入就宕机就会导致主从数据不一致</span><br><span class="line">            4. 不用关心主从的同步操作，性能最好            </span><br><span class="line">        2. 全同步模式</span><br><span class="line">            1. 可靠更高，但是会影响主库相应时间</span><br><span class="line">            2. 主节点接收到客户端提交的事务之后，必须等待binlog 发送给从库，并且所有从库全部执行完事务之后才返回给客户端</span><br><span class="line">        3.  半同步模式</span><br><span class="line">            1.  增加一部分可靠性，增加主库一部分相应时间</span><br><span class="line">            2.  主节点接收到客户端提交的事务之后，等待binlog发送给至少一个从库并且成功保存到本地relay log中，此时主库提交事务并返回给客户端</span><br><span class="line">        4. server-id的配置和server-uuid</span><br><span class="line">            1. server-id用于标识数据库实例，防止在链式主从、多主多从拓扑中导致SQL语句的无限循环</span><br><span class="line">            2. server-id默认值为0，对于主机来说依然会记录二进制日志，但是会拒绝所有的从机连接。</span><br><span class="line">            2. server-id = 0 对于从机来说会拒绝连接其他实例</span><br><span class="line">            3. server-id是一个全局变量，修改之hi偶必须重启服务</span><br><span class="line">            4. 主库和从库的server-id重复时</span><br><span class="line">                1. 默认replicate-same-server-id = 0，从库会跳过所有主从同步的数据，导致主从数据不一致</span><br><span class="line">                2. replicate-same-server-id = 1，可能导致无线循环执行sql</span><br><span class="line">            5. 两个从库（B、C）server-id重复会导致主从连接异常，时断时连</span><br><span class="line">                1. 主库（A）发现相同的server-id会断开之前的连接，重新注册新的连接</span><br><span class="line">                2. B、C从库的连接会周而复始的重连</span><br><span class="line">            6. MySQL服务会自动创建并生成server-uuid配置</span><br><span class="line">                1. 当主从同步时如果主从实例的server-uuid相同会报错退出，不过我们可以通过设置replicate-same-server-id=1来避免报错（不推荐）</span><br><span class="line"></span><br><span class="line">     5. 读写分离 </span><br><span class="line">         1. 基于代码实现，减少硬件开支</span><br><span class="line">         2. 基于中间代理实现</span><br><span class="line">         3. 主从延时</span><br><span class="line">             1. 从库性能比主库差</span><br><span class="line">             2. 大量查询导致从库压力大，消耗大量CPU资源，影响同步速度：一主多从</span><br><span class="line">             3. 大事务执行：事务执行完之后才会写入binlog，从库读取延时</span><br><span class="line">             4. 主库ddl（alter、drop、create）</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol><li>产生的四个必要条件<ol><li>互斥条件</li><li>请求与保持条件：一次性分配全部资源，否则一个都不分配</li><li>非剥夺条件：当进程获得一部分资源等待其他资源的时候释放占有的资源</li><li>循环等待条件：<br>理解：一个资源只能被一个进程占用，进程获取资源资源还能申请新的资源，并且已经获得的资源不能被剥夺，同时多个进程相互等待其他进程被占用的资源</li></ol></li><li>解除死锁<ol><li>终止进程（全部干掉）</li><li>逐个种植（杀一个看一下有没有解除）</li></ol></li></ol><h2 id="Mysql-优化大分页查询-limit-100000"><a href="#Mysql-优化大分页查询-limit-100000" class="headerlink" title="Mysql 优化大分页查询 limit 100000"></a>Mysql 优化大分页查询 limit 100000</h2><ol><li>原因<br> mysql查询分页数据时不是直接跳过offset(100000)，而是取offset + page_size  = 100000 + 10 = 100010条数据，然后放弃其掉前面的100000条数据，所以效率地下</li><li>优化方案<ol><li>延时关联：使用覆盖索引</li><li>主键阈值法：主键是自增的情况下，通过条件推算出符合条件的主键最大值&amp;最小值（使用覆盖索引）</li><li>记录上一页的结果位置，避免使用 OFFSET</li></ol></li></ol><h2 id="redis-缓存和-mysql-数据一致性"><a href="#redis-缓存和-mysql-数据一致性" class="headerlink" title="redis 缓存和 mysql 数据一致性"></a>redis 缓存和 mysql 数据一致性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">方式：</span><br><span class="line">    1. 先更新redis 再更新数据库</span><br><span class="line">        场景：update set value = 10 where value = 9</span><br><span class="line">        1. redis更新成功：redis value = 10</span><br><span class="line">        2. 数据库更新失败：mysql value = 9 </span><br><span class="line">        3. 数据不一致</span><br><span class="line">    2. 先更新数据库,再更新redis</span><br><span class="line">        场景： A进程update set value = 10 where value = 9 ；B进程 update set value = 11 where value = 9;</span><br><span class="line">        1. A 进程先更新数据库，还未写入缓存：mysql value = 10 ;redis value = 9</span><br><span class="line">        2. B 进程更新数据库并且提交事务，写入缓存：mysql value = 11；redis value = 11；</span><br><span class="line">        3. A 进程处理完请求提交事务，写入缓存：redis value = 10；</span><br><span class="line">        4. 最终 mysql value = 11; redis value = 10</span><br><span class="line">    3. 先删除缓存再更新数据库</span><br><span class="line">        场景：A进程update set value = 10 where value = 9 ；B进程查询value;</span><br><span class="line">        1. A 进程先删除缓存 还没来得及修改数据或者事务未提交</span><br><span class="line">        2. B 进程开始查询，没有命中缓存，所以查库并写入缓存 redis value = 9 </span><br><span class="line">        3. A 进程更新数据库完成 mysql value = 10</span><br><span class="line">        4. 最终 mysql value = 10；redis value = 9 </span><br><span class="line">解决方案：</span><br><span class="line">    1. 延时双删除</span><br><span class="line">        场景：A进程update set value = 10 where value = 9 ；B进程查询value;</span><br><span class="line">        1. A 进程先删除缓存 还没来得及修改数据或者事务未提交</span><br><span class="line">        2. B 进程开始查询，没有命中缓存，所以查库并写入缓存 redis value = 9 </span><br><span class="line">        3. A 进程更新数据库完成 mysql value = 10</span><br><span class="line">        4. A 进程估算延时时间，sleep之后再次删除缓存</span><br><span class="line">        5. 最终mysql value = 10;redis value 为空（下次查询直接查库）</span><br><span class="line">        6. 延时的原因时防止B进程在A进程更新完之后B进程还没来得及写入缓存 </span><br><span class="line">    2. 请求串行化</span><br><span class="line">        1. 创建两个队列 ：更新队列和查询队列</span><br><span class="line">        2. 当缓存不存在需要查库的时候将key存入更新队列</span><br><span class="line">        3. 如果查询未完成之前有新的请求进来，并且发现更新队列中还存在key则将key放入查询队列，则等待；不存在则重复第二步</span><br><span class="line">        4. 如果查询的数据发现查询队列已经存在则不需要再次写入队列</span><br><span class="line">        4. 数据更新完成之后rpop更新队列，同时rpop查询队列，释放查询请求</span><br><span class="line">        5. 查询请求可以使用while + sleep  查询缓存并且设置最大延迟时间，还没有完成则返回空</span><br></pre></td></tr></table></figure><h2 id="redis-中的-connect-和-pconnect"><a href="#redis-中的-connect-和-pconnect" class="headerlink" title="redis 中的 connect 和 pconnect"></a>redis 中的 connect 和 pconnect</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. connect             ：脚本结束之后释放连接</span><br><span class="line">    1. close :释放连接</span><br><span class="line">2. pconnect（长连接） ：脚本结束连接不释放，连接保持在php-fpm进程中，生命周期随着php-fpm进程的生命周期</span><br><span class="line">    1. close不释放连接</span><br><span class="line">        1. 只是当前php-cgi进程中不能再次请求redis</span><br><span class="line">        2. 当前php-cgi中的后续连接仍然可以复用，直到php-fpm结束生命周期</span><br><span class="line">    2. 减少建立redis连接的消耗</span><br><span class="line">    3. 减少一个php-fpm多次建立连接</span><br><span class="line">    4. 消耗更多的内存，并且连接数持续增加</span><br><span class="line">    5. 同一个php-fpm的woker子进程（php-cgi）的上一个请求可能会影响到下一个请求</span><br><span class="line">3. pconnect 的连接复用问题</span><br><span class="line">    1. 变量A select db 1 ；变量B select db 2；会影响到变量A的db</span><br><span class="line">    2. 解决：每一个db创建一个连接实例</span><br></pre></td></tr></table></figure><h2 id="redis-zset-有序集合使用-skiplist-的原理"><a href="#redis-zset-有序集合使用-skiplist-的原理" class="headerlink" title="redis zset 有序集合使用 skiplist 的原理"></a>redis zset 有序集合使用 skiplist 的原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 基本概念</span><br><span class="line">     1. skiplist是一个随机的数据，以有序的方式在层次化的链表中保存元素（只能用于元素有序的情况）</span><br><span class="line">     2. skiplist实在有序链表和多层链表的基础上演变的</span><br><span class="line">     3. 允许重复值，所以对比检查除了要对比key 还要对比value</span><br><span class="line">     4. 每个节点都带有一个高度为1的后退指针，用于表头方向到表尾方向的迭代</span><br><span class="line">     5. 时间复杂度O(logn)、空间复杂度O(n)</span><br><span class="line"> 2. 跳跃表和平衡树的对比</span><br><span class="line">     1. 范围查询效率</span><br><span class="line">         1. 跳跃表范围查询效率更高，因为找到最小值之后只需要对第一层的链表进行遍历直到小于最大值即可</span><br><span class="line">         2. 平衡树范围查询找到最小值之后还要进行中序遍历找到其他不超过最大值的节点</span><br><span class="line">     2. 内存占用</span><br><span class="line">         1. skiplist 每个节点的指针数量为1/(1-p)</span><br><span class="line">         2. 平衡树的每个节点指针数都为2</span><br><span class="line">     3. 插入和删除操作</span><br><span class="line">         1. skiplist只需要修改相邻节点的指针</span><br><span class="line">         2. 平衡树变更会引起子树的调整</span><br></pre></td></tr></table></figure><h2 id="redis-的过期删除和淘汰机制"><a href="#redis-的过期删除和淘汰机制" class="headerlink" title="redis 的过期删除和淘汰机制"></a>redis 的过期删除和淘汰机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 常规过期删除策略</span><br><span class="line">    1. 定时删除</span><br><span class="line">        1. 通过定时器在过期的时候立即删除</span><br><span class="line">        2. 内存释放及时但是消耗更多的CPU，大并发的时候需要消耗CPU资源影响处理请求的速度    </span><br><span class="line">        3. 内存友好，CPU不友好</span><br><span class="line">    2. 惰性删除</span><br><span class="line">        1. 放任键过期不管，到下次需要去取出的时候检查是否过期并删除</span><br><span class="line">        2. 可能存在大量过期键，且不会使用，导致内存溢出</span><br><span class="line">        2. 内存不友好，CPU友好</span><br><span class="line">    3. 定期删除</span><br><span class="line">        1. 每隔一段时间检查，删除过期的键</span><br><span class="line">        2. 删除多少和检查多少有算法决定</span><br><span class="line">2. redis采用的 惰性删除 + 定期删除</span><br><span class="line">    1. 周期性随机测试一些设置了过期时间的键进行检查，到期则删除</span><br><span class="line">    2. 每次清理的时间不超过CPU的25%，达到时间则退出检查</span><br><span class="line">    3. 定期没有删除到的键，且以后不会使用的键还是会存在内存中，所以需要配合淘汰策略</span><br><span class="line">3. 淘汰策略（内存不足以写入新数据的时候执行）</span><br><span class="line">    1. volatile-lru     ：设置了过期时间且最近使用越少越优先淘汰</span><br><span class="line">    2. volatile-ttl     ：设置了过期时间且过期时间越早越优先淘汰</span><br><span class="line">    3. volatile-random    ：设置了过期时间中随机删除</span><br><span class="line">    4. allkeys-lru        ：所有键中过期时间越早越优先淘汰</span><br><span class="line">    5. allkeys-random    ：所有键中过期随机淘汰</span><br><span class="line">    6. no-enviction        ：不允许淘汰，内存不足报错</span><br></pre></td></tr></table></figure><h2 id="redis-常见问题及解决方案"><a href="#redis-常见问题及解决方案" class="headerlink" title="redis 常见问题及解决方案"></a>redis 常见问题及解决方案</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 缓存雪崩：同一时间大量缓存失效，导致请求直接查询数据库，数据库内存和CPU压力增加甚至宕机</span><br><span class="line">    解决：</span><br><span class="line">        1. 热点数据永不过期或者分布到不同实例，降低单机故障问题</span><br><span class="line">        2. 缓存时间添加随机数，防止大量缓存同时失效                </span><br><span class="line">        4. 做二级缓存或者双缓存，A为原始缓存 短时效，B为备份缓存 ，长期有效。更新时候双写缓存</span><br><span class="line">2. 缓存穿透：缓存和数据库都没有数据，大量请求下，所有请求直接击穿到数据库，导致宕机。</span><br><span class="line">    解决：</span><br><span class="line">        1. 布隆过滤器:长度为m的位向量或者位列表组成（仅包含0或1位值的列表）</span><br><span class="line">            1. 使用多个不用的hash函数，产生多个索引值，填充对应多个位置的值为1</span><br><span class="line">            2. 布隆过滤器可以检查值是 “可能在集合中” 还是 “绝对不在集合中”</span><br><span class="line">            2. 可能误判但是基础过滤效率高</span><br><span class="line">            3. 极端情况，当布隆过滤器没有空闲位置的时候每次查询返回true</span><br><span class="line">        2. 空缓存（短时效）</span><br><span class="line">        3. 业务层参数过滤</span><br><span class="line">3. 缓存击穿：数据库中有数据，但是缓存突然失效之后发生大量请求导致数据库压力增加甚至打垮宕机</span><br><span class="line">    解决：</span><br><span class="line">        1. 热点数据永不过期</span><br><span class="line">        2. 互斥锁：获取锁之后不管成功还是失败都要释放锁</span><br></pre></td></tr></table></figure><h2 id="php-fpm-详解及生命周期"><a href="#php-fpm-详解及生命周期" class="headerlink" title="php-fpm 详解及生命周期"></a>php-fpm 详解及生命周期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. 基础知识</span><br><span class="line">    1. CGI协议</span><br><span class="line">        1. 动态语言的代码文件需要通过对应的解析器才能被服务器识别</span><br><span class="line">        2. CGI协议就是用来使服务器和解释器相互通信的</span><br><span class="line">        3. 服务器解析PHP文件需要PHP解释器加上对应的CGI协议        </span><br><span class="line">    2. CGI程序 = php-cgi</span><br><span class="line">        1. php-cgi就是一个遵守CGI协议的CGI程序</span><br><span class="line">        2. 同时也就是PHP解释器</span><br><span class="line">        3. 标准的CGI每个请求都会解析php.ini，初始化执行环境等，降低性能</span><br><span class="line">        4. 每次修改配置之后需要重新php-cgi才能让php.ini生效</span><br><span class="line">        5. 不能动态worker调度，只能一开始指定数量的worker</span><br><span class="line">    2. FastCGI协议 </span><br><span class="line">        1. 和CGI一样也是一个协议/规范，不过是再CGI的基础上优化，效率更高</span><br><span class="line">        2. 用来提高CGI程序性能的</span><br><span class="line">        3. 实现了CGI进程的管理</span><br><span class="line"></span><br><span class="line">    3. FastCGI程序  = php-fpm</span><br><span class="line">        1. php-fpm就是一个遵守FastCGI协议的FastCGI程序        </span><br><span class="line">        2. FastCGI程序对CGI程序的管理模式</span><br><span class="line">            1. 启动一个master进程，解析配置文件，初始化环境</span><br><span class="line">            2. 启动多个worker子进程</span><br><span class="line">            3. 接受到请求之后，传递给woker进程去执行</span><br><span class="line">        3. 解决修改php.ini之后平滑重启问题</span><br><span class="line">            1. process_control_timeout:子进程接受主进程复用信号的超时时间(在规定时间内处理完请求，完成不了就不管了)</span><br><span class="line">            2. 设定php-fpm留给fastcgi进程响应重启信号的时间</span><br><span class="line">            3. process_control_timeout = 0，也就是不生效，无法保证平滑重启</span><br><span class="line">            4. process_control_timeout设置过大可能导致系统请求堵塞 </span><br><span class="line">            5. process_control_timeout =10的情况下，如果代码逻辑需要11s，重启旧可能导致代码执行部分退出</span><br><span class="line">            6. 建议值：request_terminate_timeout</span><br><span class="line">        4. 重启类型</span><br><span class="line">            1. 优雅重启</span><br><span class="line">            2. 强制重启</span><br><span class="line">    2. php-fpm生命周期：待更新</span><br><span class="line">        PHP-FPM 生命周期:https://www.abelzhou.com/php/php-fpm-lifespan/#</span><br></pre></td></tr></table></figure><h2 id="Nginx-和-php-之间的通信"><a href="#Nginx-和-php-之间的通信" class="headerlink" title="Nginx 和 php 之间的通信"></a>Nginx 和 php 之间的通信</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 通信方式：fastcgi_pass</span><br><span class="line">    1. tcp socket</span><br><span class="line">        1. 跨服务器，nginx和php不在一个机器时，只能用这个方式</span><br><span class="line">        2. 面向连接的协议，更好的保证通信的正确性和完整性</span><br><span class="line">    2. unix socket</span><br><span class="line">        1. 不需要网络协议栈、打包拆包等</span><br><span class="line">        2. 减少tcp 开销，效率比tcp socket 更高</span><br><span class="line">        3. 高并发时候不稳定，连接数暴增产生大量的长时缓存，大数据包可能直接返回异常</span><br></pre></td></tr></table></figure><h2 id="web-漏洞及问题"><a href="#web-漏洞及问题" class="headerlink" title="web 漏洞及问题"></a>web 漏洞及问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. sql注入</span><br><span class="line">2. XSS攻击</span><br><span class="line">    推荐阅读(很详细的案例来分析XSS攻击的不同类型及解决方案)：[前端安全系列（一）：如何防止XSS攻击？](https://tech.meituan.com/2018/09/27/fe-security.html)</span><br><span class="line">3. CSRF攻击：</span><br><span class="line">    推荐阅读 ：[前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)</span><br><span class="line">4. 文件上传漏洞</span><br><span class="line">    推荐阅读 ：[浅析文件上传漏洞](https://xz.aliyun.com/t/7365)</span><br><span class="line">5. 跨域问题：</span><br><span class="line">    推荐阅读 ：</span><br><span class="line">        1. [前端常见跨域解决方案（全）](https://segmentfault.com/a/1190000011145364)</span><br><span class="line">        2. [JSONP原理详解——弄懂JSONP及其实现方法](https://juejin.cn/post/6844904024924225544)</span><br><span class="line">    1. jsonp</span><br><span class="line">    2. cors</span><br><span class="line">    3. nginx代理</span><br></pre></td></tr></table></figure><h2 id="魔术方法原理及使用场景"><a href="#魔术方法原理及使用场景" class="headerlink" title="魔术方法原理及使用场景"></a>魔术方法原理及使用场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1. __cocnstruct() 构造方法</span><br><span class="line">    详解：</span><br><span class="line">        1. 对象被实例化的时候首先调用</span><br><span class="line">        2. 初始化数据、初始化属性</span><br><span class="line">2. __destruct() 析构方法</span><br><span class="line">    详解：</span><br><span class="line">        1. 对象销毁前调用该方法</span><br><span class="line">        2. 释放资源防止内存溢出和单个进程占用过多内存</span><br><span class="line">3. __get()、__set()</span><br><span class="line">    详解：</span><br><span class="line">        1. 调用或者设置对象未定义的属性是触发</span><br><span class="line">        2. 属性的一些格式化或者处理</span><br><span class="line">4. __isset()</span><br><span class="line">    详解：</span><br><span class="line">        1. 对不可访问属性调用isset()或者empty()时调用</span><br><span class="line">5. __unset()</span><br><span class="line">    详解：</span><br><span class="line">        1. 对不可访问属性调用unset()时调用</span><br><span class="line">6. __call() 、__callStatic()</span><br><span class="line">    详解：</span><br><span class="line">        1. 调用不存在的方法或者调用不存在的静态方法时执行</span><br><span class="line">        2. 调用不存在的方法php会抛出致命错误，该方法可以进行错误日志或者重定向、抛出异常等处理</span><br><span class="line">7.  __sleep () </span><br><span class="line">    详解：</span><br><span class="line">        1. 执行serialize()时调用</span><br><span class="line">8.  __wakeup ()</span><br><span class="line">    详解：</span><br><span class="line">        1. 执行unserialize()时调用</span><br><span class="line">9. __clone()</span><br><span class="line">    详解：</span><br><span class="line">        1. 对象复制完成时调用</span><br><span class="line">        2. 克隆示例或者单例模式 防止克隆</span><br><span class="line">10. __autoload（）</span><br><span class="line">    详解：</span><br><span class="line">        1. 尝试加载未定义的类时候调用</span><br><span class="line">        2. 惰性加载/懒加载/lazy loading</span><br><span class="line">11. __toString()</span><br><span class="line">12. __invoke()</span><br><span class="line">13. __set_state</span><br></pre></td></tr></table></figure><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 乐观锁：执行更新的时候判断其他进程是否修改了数据，如果修改了就放弃修改</span><br><span class="line">    1. 实现机制：</span><br><span class="line">        1. 版本号机制：数据表加一个version版本号字段，每次修改+1。</span><br><span class="line">        2. CAS算法</span><br><span class="line">    2. 场景：读取频繁场景</span><br><span class="line">2. 悲观锁：先取锁再操作-操作数据的时候把数据锁住，操作完成之后才会释放，释放锁之前其他进程不能修改数据</span><br><span class="line">    1. 实现机制</span><br><span class="line">        1. select * from table where id = 1 for update</span><br><span class="line">    2. 场景：写入操作频繁的场景</span><br></pre></td></tr></table></figure><h2 id="mysql-一次查询索引使用"><a href="#mysql-一次查询索引使用" class="headerlink" title="mysql 一次查询索引使用"></a>mysql 一次查询索引使用</h2><ol><li>一次查询只能使用1个，所以要合理的使用组合索引，而不是单列索引。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>在计算机网络的基本概念中，分层次的体系结构是最基本的</p><h2 id="计算机网络体系结构的形成"><a href="#计算机网络体系结构的形成" class="headerlink" title="计算机网络体系结构的形成"></a>计算机网络体系结构的形成</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>相互通信的两个计算机系统必须高度协调工作才行，而这种“协调”是相当复杂的。为了设计这样复杂的计算机网络，最初提出了分层的方法。“<code>分层</code>”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题比较易于研究和处理</p><h3 id="国际标准"><a href="#国际标准" class="headerlink" title="国际标准"></a>国际标准</h3><p>全球经济的发展使得不同网络体系结构的用户迫切要求能够互相交换信息，国际标准化组织 ISO 提出了 OSI。只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信</p><p>现今规则最大的、覆盖全球的、基于 TCP/IP 的互联网并未使用 OSI 标准。在20世纪90年代初期，虽然整套的 OSI 国际标准已制定出来，但基于 TCP/IP 的互联网已抢先在全球相当大的范围成功地运行了，而同时却几乎找不到有厂家生产出符合 OSI 标准的商业产品。OSI 只获得了一些理论研究的成果，市场化方面则彻底失败了</p><p>TCP/IP 常被称为是<code>事实上的国际标准</code></p><h2 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>在计算机网络中要做到有条不紊地交换数据，就必须准守一些事先约定好的规则。这些规则明确了所交换的数据的格式以及有关的同步问题</p><p>为进行网络中的数据交换而建立的规则、标准或约定称为<code>网络协议</code>。网络协议也可简称为<code>协议</code></p><p><strong>协议组成要素</strong></p><ul><li><code>语法</code>，即数据与控制信息的结构或格式</li><li><code>语义</code>，即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li><code>同步</code>，即事件实现顺序的详细说明</li></ul><p>协议通常有两种不同的形式。一种是使用便于人来阅读和理解的文字描述。另一种是使用让计算机能够理解的程序代码。这两种不同形式的协议都必须能够对网络上的信息交换过程做出精确的解释</p><h3 id="划分层次"><a href="#划分层次" class="headerlink" title="划分层次"></a>划分层次</h3><p>对于非常复杂的计算机网络协议，其结构应该是层次式的</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-01.png" alt="网络体系结构-图1"></p><p><strong>分层可以带来很多好处</strong></p><ul><li><code>各层之间是独立的</code>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间接口（即界面）所提供的服务</li><li><code>灵活性好</code>。当任何一层发送变化时（例如由于技术的变化），只要层间接口关系保持不变，则在这层以上或以下各层均不受影响</li><li><code>结构上可分割开</code>。各层都可以采用最合适的技术来实现</li><li><code>易于实现和维护</code>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统</li><li><code>能促进标准化工作</code>。因为每一层的功能及其所提供的服务都已有了精确的说明</li></ul><p><strong>各层所要完成的功能</strong></p><ul><li><code>差错控制</code> 使相应层次对等方的通信更加可靠</li><li><code>流量控制</code> 发送端的发送速率必须使接收端来得及接收，不要太快</li><li><code>分段和重装</code> 发送端将要发送的数据块划分为更小的单位，在接收端将其还原</li><li><code>复用和分用</code> 发送端几个高层会话复用一条逻辑连接，数据传送结束后释放连接</li><li><code>连接建立和释放</code> 交换数据前先建立一条逻辑连接，数据传送结束后释放连接</li></ul><p><strong>分层缺点</strong></p><p>有些功能会在不同的层次中重复出现，因而产生了额外开销</p><p><strong>体系结构</strong></p><p>计算机网络的各层及其协议的集合就是网络的<code>体系结构</code>。计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义</p><p>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件</p><h2 id="具有五层协议的体系结构"><a href="#具有五层协议的体系结构" class="headerlink" title="具有五层协议的体系结构"></a>具有五层协议的体系结构</h2><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层的体系结构。在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-02.png" alt="网络体系结构-图2"></p><h3 id="各层作用"><a href="#各层作用" class="headerlink" title="各层作用"></a>各层作用</h3><ul><li>应用层：应用层协议定义的是应用进程间通信和交互的规则</li><li>运输层：运输层的任务就是负责向<code>两台主机中进程之间的通信</code>提供<code>通用的数据传输</code>服务</li><li>网络层：把运输层产生的报文段或用户数据报封装成<code>分组</code>或<code>包</code>进行传送</li><li>数据链路层：将网络层交下来的 IP 数据报组装成帧，并在两个相邻结点间的链路上传送</li><li>物理层：利用物理媒体以<code>比特</code>形式传送数据</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>把应用层交互的数据单元称为<code>报文</code></li><li>运输层主要协议：传输控制协议 TCP、用户数据报协议 UDP</li><li>在 TCP/IP 体系中，由于网络层使用 IP 协议，因此分组也叫 <code>IP 数据报</code>，或简称为数据报</li></ul><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-03.png" alt="网络体系结构-图3"></p><h2 id="实体、协议、服务和服务访问点"><a href="#实体、协议、服务和服务访问点" class="headerlink" title="实体、协议、服务和服务访问点"></a>实体、协议、服务和服务访问点</h2><p>当研究开放系统中的信息交换时，往往使用<code>实体</code>(entity)这一较为抽象的名词表示<code>任何可发送或接受信息的硬件或软件进程</code></p><p>协议是控制两个对等实体(或多个实体)进行通信的规则的集合</p><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务</p><p>协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-04.png" alt="网络体系结构-图4"></p><h3 id="计算机网络协议特点"><a href="#计算机网络协议特点" class="headerlink" title="计算机网络协议特点"></a>计算机网络协议特点</h3><p>协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的</p><p>非常仔细地检查这个协议能否应付各种异常情况</p><h2 id="TCP-IP-的体系结构"><a href="#TCP-IP-的体系结构" class="headerlink" title="TCP/IP 的体系结构"></a>TCP/IP 的体系结构</h2><p>TCP/IP 的体系结构比较简单，只有四层</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-05.png" alt="网络体系结构-图5"></p><p>应当指出，技术的发展并不是遵循严格的 OSI 分层概念。实际上现在的互联网使用的 TCP/IP 体系结构有时已经演变成为下图所示的那样，即某些应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-06.png" alt="网络体系结构-图6"></p><p>还有一种方法，就是分层次画出具体的协议表示 TCP/IP 协议族，它的特点是上下两头大而中间小：应用层和网络接口层都有多种协议，而中间的 IP 层很小，上层的各种协议都向下汇聚到一个 IP 协议中</p><p>TCP/IP 协议可以为各式各样的应用提供服务，同时 TCP/IP 协议也允许 IP 协议在各式各样的网络构成的互联网上运行。IP 协议在互联网中充当着核心的作用</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-07.png" alt="网络体系结构-图7"></p><p><strong>《计算机网络体系结构》 原文链接：<a href="https://blog.maplemark.cn/2019/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html">https://blog.maplemark.cn/2019/04/计算机网络体系结构.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用户数据报协议 UDP</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/02.%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/02.%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP/</url>
      
        <content type="html"><![CDATA[<h1 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h1><h2 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h2><p>用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及查错检测的功能</p><h3 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h3><ol><li>UDP 是<code>无连接的</code>，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延</li><li>UDP 使用<code>尽最大努力交付</code>，即不保证可靠交付，主机不需要维持复杂的连接状态表</li><li>UDP 是<code>面向报文</code>的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是<code>保留这些报文的边界</code></li></ol><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com/network-udp-01.png" alt="UDP协议-图1"></p><ol start="4"><li>UDP <code>没有拥塞控制</code>，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP 的<code>首部开销小</code>，只有8个字节，比 TCP 的20个字节的首部要短</li></ol><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>某些实时应用需要使用没有拥塞控制的 UDP，但很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，导致大家都无法正常接收。</li><li>还有一些使用 UDP 的实时应用，需要对 UDP 的不可靠传输进行适当的改进，以减少数据的丢失。应用进程可以在不影响应用的实时性的前提下，增加一些提高可靠性的措施，如采用前向纠错或重传已丢失的报文</li></ol><h2 id="UDP-的首部格式"><a href="#UDP-的首部格式" class="headerlink" title="UDP 的首部格式"></a>UDP 的首部格式</h2><p>用户数据报 UDP 有两个字段：<code>数据字段</code>和<code>首部字段</code>。首部字段很简单，只有8个字节，由四个字段组成，每个字段都是两个字节</p><h3 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h3><ul><li><code>源端口</code> 源端口号。在需要对方回信时。不需要时可用全0</li><li><code>目的端口</code> 目的端口号。这在终点交付报文时必须使用</li><li><code>长度</code> UDP 用户数据报的长度，其最小值是8(仅有首部)</li><li><code>检验和</code> 检测 UDP 用户数据报在传输中是否有错。有错就丢弃</li></ul><p><img src="https://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com/network-udp-02.png" alt="UDP协议-图2"></p><h3 id="端口分用"><a href="#端口分用" class="headerlink" title="端口分用"></a>端口分用</h3><p>当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程</p><p><img src="https://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com/network-udp-03.png" alt="UDP协议-图3"></p><p>如果接受方 UDP 发现收到的报文中的目的端口号不正确(即不存在对应于该端口号的应用程序)，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方</p><h3 id="伪首部"><a href="#伪首部" class="headerlink" title="伪首部"></a>伪首部</h3><p>UDP 用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的<code>伪首部</code>。所谓“伪首部”是因为这种伪首部并不是 UDP 用户数据报真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报前面，得到一个临时的 UDP 用户数据报。检验和就是按照这个临时用户数据报来计算的。伪首部既不向下传也不向上递交，而仅仅是为了计算检验和</p><p><strong>《用户数据报协议UDP》 原文链接：<a href="https://blog.maplemark.cn/2019/04/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp.html">https://blog.maplemark.cn/2019/04/用户数据报协议udp.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP 粘包拆包</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/04.TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/04.TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-粘包拆包"><a href="#TCP-粘包拆包" class="headerlink" title="TCP 粘包拆包"></a>TCP 粘包拆包</h1><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>在 TCP 这种字节流协议上做<code>应用层分包</code>是网络编程的基本需求。分包指的是在发生一个消息(message)或一帧(frame)数据时，通过一定的处理，让接收方能从字节流中识别并截取(还原)出一个个消息。因此，<code>“粘包问题”是个伪命题</code></p><h2 id="短连接分包"><a href="#短连接分包" class="headerlink" title="短连接分包"></a>短连接分包</h2><p>对于短连接的 TCP 服务，分包不是一个问题，只要发送方主动关闭连接，就表示一个消息发送完毕，接收方 read() 返回0，从而知道消息的结尾</p><h2 id="TCP-发送机制"><a href="#TCP-发送机制" class="headerlink" title="TCP 发送机制"></a>TCP 发送机制</h2><p>为了提高 TCP 的传输效率，TCP 有一套自己的发送机制</p><ul><li>TCP 维持一个变量，它等于<code>最大报文段长度 MSS</code>。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去</li><li>由发送方的应用进程指明要求发送报文段，即 TCP 支持的<code>推送(push)</code>操作</li><li>发送方的一个计时器期限到了，这时把当前已有的缓存数据装入报文段(但长度不能超过 MSS)发送出去</li></ul><h2 id="长连接分包"><a href="#长连接分包" class="headerlink" title="长连接分包"></a>长连接分包</h2><p>对于长连接的 TCP 服务，分包有四种方法</p><ul><li>消息长度固定</li><li>使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\r\n”为字段的分隔符</li><li>在每条消息的头部加一个长度字段，这恐怕是最常见的做法</li><li>利用消息本身的格式来分包，例如 XML 格式的消息中 <code>&lt;root&gt;</code>…<code>&lt;/root&gt;</code> 的配对，或者 JSON 格式中的 { … } 的配对。解析这种消息格式通常会用到状态机(state machine)</li></ul><h2 id="复杂的分包"><a href="#复杂的分包" class="headerlink" title="复杂的分包"></a>复杂的分包</h2><p>假如消息格式非常简单，“消息”本身是一个字符串，每条消息有一个4字节的头部，以网络序存放字符串的长度。消息直接没有间隙，字符串也不要求以 ‘\0’ 结尾</p><p>发送两条消息“hello”和“smartboy”，打包后的字节流共有21字节</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00, 0x00, 0x00, 0x05, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;,</span><br><span class="line">0x00, 0x00, 0x00, 0x08, &#x27;s&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;t&#x27;, &#x27;b&#x27;, &#x27;o&#x27;, &#x27;y&#x27;</span><br></pre></td></tr></table></figure><p>假设数据最终都全部到达，数据解析逻辑至少能正确处理以下各种数据到达的次序</p><ul><li>一个字节一个字节到达</li><li>数据分两次到达，第一次收到2个字节，不足消息的长度字段</li><li>数据分两次到达，第一次收到4个字节，刚好够长度字段，但是没有 body</li><li>数据分两次到达，第一次收到8个字节，长度完整，但 body 不完整</li><li>数据分两次到达，第一次收到9个字节，长度完整，但 body 也完整</li><li>数据分两次到达，第一次收到10个字节，第一条消息的长度完整、body 也完整，第二条消息长度不完整</li><li>请自行移动和增加分割点，一共有超过 100 万种可能(2<sup>21-1</sup>)</li><li>数据一次就全部到达</li></ul><p><strong>《TCP粘包拆包》 原文链接：<a href="https://blog.maplemark.cn/2019/04/tcp%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.html">https://blog.maplemark.cn/2019/04/tcp粘包拆包.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>传输控制协议 TCP</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/03.%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/03.%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP/</url>
      
        <content type="html"><![CDATA[<h1 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h1><h2 id="传输控制协议-TCP-概述"><a href="#传输控制协议-TCP-概述" class="headerlink" title="传输控制协议 TCP 概述"></a>传输控制协议 TCP 概述</h2><h3 id="TCP-最主要的特点"><a href="#TCP-最主要的特点" class="headerlink" title="TCP 最主要的特点"></a>TCP 最主要的特点</h3><ul><li>TCP 是<code>面向连接的运输层协议</code>。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接</li><li>每一条 TCP 连接只能有两个<code>端点</code>，每一条 TCP 连接只能是<code>点对点</code>的(一对一)</li><li>TCP 提供<code>可靠交付</code>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达</li><li>TCP 提供<code>全双工通信</code>。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据</li><li><code>面向字节流</code>。TCP 中的“流”指的是<code>流入到进程或从进程流出的字节序列</code></li></ul><h3 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h3><p>“面向字节流”的含义是：虽然应用程序和 TCP 的交互式一次一个数据块(大小不等)，但 TCP 把应用程序交下来的数据仅仅看成是一连串的<code>无结构的字节流</code>。TCP 并不知道所传送的字节流的含义</p><p>TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系</p><blockquote><p>例如，发送方应用程序交给发送方的 TCP 共10个数据块，但接收方的 TCP 可能只用了4个数据块就把收到的字节流交付上层的应用程序</p></blockquote><p>接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-01.png" alt="TCP协议-图1"></p><p>TCP 和 UDP 在发送报文时采用的方式完全不同。TCP 并不关心应用进程一次把多长的报文发送到 TCP 的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的)。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就可以把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去</p><h3 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h3><p>TCP 把<code>连接</code>作为<code>最基本的抽象</code>。TCP 的许多特性都与 TCP 是面向连接的这个基本特性有关</p><p>TCP 连接的端点叫做<code>套接字(socket)或插口</code>，根据 RFC 793 的定义：端口号拼接到(concatenated with) IP 地址即构成了套接字</p><blockquote><p>套接字 socket = (IP 地址：端口号)</p></blockquote><p><code>每一条 TCP 连接唯一地被通信两端的两个端点(即两个套接字)所确定</code></p><blockquote><p>TCP 连接 ::= {socket<sub>1</sub>, socket<sub>2</sub>} = {(IP<sub>1</sub>: port<sub>1</sub>), (IP<sub>2</sub>: port<sub>2</sub>)}</p></blockquote><p>TCP 连接就是由协议软件所提供的一种抽象。<code>TCP 连接的端口是个很抽象的套接字</code>，即( <code>IP地址</code>: <code>端口号</code>)。同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中</p><h3 id="易混淆的-socket"><a href="#易混淆的-socket" class="headerlink" title="易混淆的 socket"></a>易混淆的 socket</h3><p>同一个名词 socket 却可表示多种不同的意思，以下 socket 的意思跟本文中所引用的 RFC 793 定义的 socket(指端口号拼接到 IP 地址)不同</p><ul><li>允许应用程序访问连网协议的<code>应用编程接口 API(Application Programming Interface)</code>，即运输层和应用层之间的接口，称为 socket API，并简称为 socket</li><li>在 socket API 中使用的一个<code>函数名</code>也叫做 socket</li><li>调用 socket 函数的<code>端点</code>称为 socket，如“创建一个数据报 socket”</li><li>调用 socket 函数时，其<code>返回值</code>称为 socket 描述符，可简称为 socket</li><li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket <code>实现</code></li></ul><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="理想的传输条件"><a href="#理想的传输条件" class="headerlink" title="理想的传输条件"></a>理想的传输条件</h3><p>理想的传输条件有以下两个特点</p><ul><li>传输信道不产生差错</li><li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</li></ul><p>实际的网络不具备以上两个理想条件。需要使用一些可靠的传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当减低发送数据的速度。这样，不可靠的传输信道就能够实现可靠传输了</p><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p>全双工通信的双方既是发送方也是接收方。把传送的数据单元都称为分组。“停止等待”就是每发完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组</p><h4 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h4><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-02.png" alt="TCP协议-图2"></p><h4 id="出现差错"><a href="#出现差错" class="headerlink" title="出现差错"></a>出现差错</h4><p>只要超过一段时间没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做<code>超时重传</code>。要实现超时重传，就要在每发送完一个分组时设置一个<code>超时计时器</code></p><ul><li>发送完一个分组后，<code>必须暂时保留已发送的分组的副本</code>(在发生超时重传时使用)。只有在收到相应的确认后才能清除暂时保留的分组副本</li><li>分组和确认分组都必须进行<code>编号</code>。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认</li><li>超时计时器的重传时间<code>应当比数据在分组传输的平均往返时间更长一些</code></li></ul><h4 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h4><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-03.png" alt="TCP协议-图3"></p><p>使用上述的确认和重传机制，我们就可以<code>在不可靠的传输网络上实现可靠的通信</code></p><p>像上述的这种可靠传输协议常称为<code>自动重传请求 ARQ(Automatic Repeat reQuest)</code>。重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组</p><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>停止等待协议的优点是简单，但缺点是信道利用率太低</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-04.png" alt="TCP协议-图4"></p><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用<code>流水线传输</code>。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。这种传输方式可以获得很高的信道利用率</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-05.png" alt="TCP协议-图5"></p><h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><p>位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认。可以提高信道利用率</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-06.png" alt="TCP协议-图6"></p><p>接收方一般都是采用<code>累积确认</code>的方式。接收方不需要对收到的分组逐个发送确认，而是在收到几个分组后，<code>对按序到达的最后一个分组发送确认</code></p><p>积累确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息</p><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><p>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分。TCP 报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项(n是整数)。因此 TCP 首部的最小长度是20字节</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-07.png" alt="TCP协议-图7"></p><h3 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h3><ul><li><code>源端口</code>和<code>目的端口</code> 各占2个字节，分别写入源端口号和目的端口号</li><li><code>序号</code> 占4字节。序号范围是[0, 2<sup>32</sup>-1]，共2<sup>32</sup>(即4 294 967 296)个序号。序号增加到2<sup>32</sup>-1后，下一个序号就又回到0。在一个 TCP 连接中传送的字节流中的<code>每一个字节都按顺序编号</code></li><li><code>确认号</code> 占4字节，是<code>期望收到对方下一个报文段的第一个数据字节的序号</code></li><li><code>数据偏移</code> 占4字节，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的首部长度</li><li><code>保留</code> 占6位，保留为今后使用，但目前应置为0</li></ul><p>下面有6个<code>控制位</code>，用来说明本报文段的性质</p><ul><li><p><code>紧急 URG(URGent)</code> 当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不是按原先的排队顺序来传送</p></li><li><p><code>确认 ACK(ACKnowledgment)</code> 仅当 ACK=1 时确认号字段才有效。当 ACK=0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置1</p></li><li><p><code>推送 PSH(Push)</code> 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应</p></li><li><p><code>复位 RST(ReSeT)</code> 当 RST=1 时，表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接</p></li><li><p><code>同步 SYN(SYNnchronization)</code> 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1</p></li><li><p><code>终止 FIN(FINis)</code> 用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接</p></li><li><p><code>窗口</code> 占2字节。窗口值是[0, 2<sup>16</sup>-1]之间的整数。窗口值作为接收方让发送方设置其发送窗口的依旧</p></li><li><p><code>检验和</code> 占2字节。检验和字段检验的范围包括首部和数据这两部分</p></li><li><p><code>紧急指针</code> 占2字节。紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数</p></li><li><p><code>选项</code> 长度可变，最长可达40字节</p></li></ul><h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><h4 id="发送窗口构造"><a href="#发送窗口构造" class="headerlink" title="发送窗口构造"></a>发送窗口构造</h4><p>TCP 的滑动窗口是以字节为单位的。假定 A 收到了 B <code>发来</code>的确认报文段，其中窗口是20字节，而确认号是31(这表明 B 期望收到的下一个序号是31，而序号30为止的数据已经收到了)。根据这两个数据，A 就构造出自己的发送窗口</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-08.png" alt="TCP协议-图8"></p><p>发送窗口标识：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送出去的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用</p><h4 id="发送窗口变化"><a href="#发送窗口变化" class="headerlink" title="发送窗口变化"></a>发送窗口变化</h4><p>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种，即不动(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销已收到的确认</p><p>发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：</p><ul><li>一是没有收到新的确认，对应通知的窗口大小也不变</li><li>二是收到了新的窗口单对方通知的窗口缩小了，使得发送窗口前沿正好不动</li></ul><p>发送窗口前沿也有可能<code>向后收缩</code>。这发生在对方通知的窗口缩小了。但 TCP 的标准<code>强烈不赞成这样做</code>。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-09.png" alt="TCP协议-图9"></p><p>要描述一个发送窗口的状态需要三个指针：P<sub>1</sub>，P<sub>2</sub>，P<sub>3</sub>。指针都指向字节的序号。这三个指针指向的几个部分的意义如下：</p><ul><li>小于 P<sub>1</sub> 的是已发送并已收到确认的部分，而大于 P<sub>3</sub> 的是不允许发送的部分</li><li>P<sub>3</sub> - P<sub>1</sub> = <code>A 的发送窗口</code></li><li>P<sub>2</sub> - P<sub>1</sub> 已发送但尚未收到确认的字节数</li><li>P<sub>3</sub> - P<sub>2</sub> 允许发送但当前尚未发送的字节数(又称为<code>可用窗口</code>或<code>有效窗口</code>)</li></ul><p>B 的接收窗口大小是20。在接收窗口外面，到30号为止的数据是已经发送过确认，并且已经交付主机了。因此在 B 可以不再保留这些数据。接收窗口内的序号(31~50)是允许接收的。在上图中，B 收到了序号为32和33的数据。这些数据没有按序到达，因为序号为31的数据没有收到(也许丢失了，也许滞留在网络中的某处)。请注意，B 只能对按序收到的数据中的最高序号给出确认，因此 B 发送的确认报文段中的确认号仍然是31(即期望收到的序号)，而不是32或33</p><p>现在假定 B 收到了序号为31的数据，并把序号为31~33的数据交付主机，然后 B 删除这些数据。接着把接收窗口向前移动3个序号，同时给 A 发送确认，其中窗口值仍为20，但确认号是34。这表明 B 已经收到了到序号33为止的数据。B 还收到了序号为37，38和40的数据，但这些都没有按序到达，只能先暂存在接收窗口中。A 收到 B 的确认后，就可以把发送窗口向前滑动3个序号，但指针 P<sub>2</sub> 不动。现在 A 的可用窗口增大了，可发送的序号范围是42~53</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-10.png" alt="TCP协议-图10"></p><p>A 在继续发送完序号42~53的数据后，指针 P<sub>2</sub> 向前移动和 P<sub>3</sub> 重合。发送窗口内的序号都已用完，但还没有再收到确认。由于 A 的发送窗口已满，可用窗口已减小到零，因此必须停止发送。发送窗口内所有的数据都已正确到达 B，B 也早已发出了确认。但所有这些确认都滞留在网络中。在没有收到 B 的确认时，A 不能猜测：”或许 B 收到了吧！“为了保证可靠传输，A 只能认为 B 还没有收到这些数据。于是，A 在经过一段时间后(由超时计时器控制)就重传这部分数据，重新设置超时计时器，直到收到 B 的确认为止。如果 A 收到确认号落在发送窗口内，那么 A 就可以发送窗口继续向前滑动，并发送新的数据</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-11.png" alt="TCP协议-图11"></p><h4 id="缓存和窗口"><a href="#缓存和窗口" class="headerlink" title="缓存和窗口"></a>缓存和窗口</h4><p>发送方维持的发送缓存和发送窗口，以及接收方维持的接收缓存和接收窗口</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-12.png" alt="TCP协议-图12"></p><p>发送缓存用来暂时存放：</p><ul><li>发送应用程序传送给对方 TCP 准备发送的数据</li><li>TCP 已发送出但尚未收到确认的数据</li></ul><p>已被确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序必须控制写入缓存的速率，不能太快，否则发送缓存就会没有存放数据的空间</p><p>接收缓存用来暂时存放：</p><ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据</li></ul><p>收到的分组被检测出有差错，则丢弃。接收应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到零。接收应用程序能够及时从接收缓存中读取收到的数据，接收窗口就可以增大，最大亦不能超过接收缓存的大小</p><p>要点小结：</p><ul><li>虽然 A 的发送窗口是根据 B 的接收窗口设置的，但在同一时刻，A 的发送窗口并不总是和 B 的接收窗口一样大。通过网络传送窗口值需要经历一定的时间滞后，该时间并不确定的</li><li>对于不按序到达的数据，TCP 通常是先临时存放在接收窗口，等字节流中所缺少的字节收到后，在<code>按序交付上层的应用进程</code></li><li>TCP 要求接收方必须有累积确认的功能，这样可以减少传输开销</li></ul><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>TCP 的发送方在规定的时间内没有收到确认就要重传已发送的报文段。这种重传的概念是很简单的，但重传时间的选择却是 TCP 最复杂的问题之一</p><p>由于 TCP 的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个 IP 数据报所选择的路由还可能不同。如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置的过长，则又使网络的空闲时间增大，降低了传输效率</p><p>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是<code>报文段的往返时间 RTT</code></p><blockquote><p>新的 RTT<sub>s</sub> = (1 - α) x (旧的 RTT<sub>s</sub>) + α x (新的 RTT 样本)</p></blockquote><p>RTT：报文段往返时间<br>RTT<sub>s</sub>：加权平均往返时间<br>α： 0 ≤ α &lt; 1，RFC 6298 推荐的 α 值为 1/8，即 0.125</p><blockquote><p>RTO = RTT<sub>s</sub> + 4 x RTT<sub>D</sub></p></blockquote><p>RTO：超时重传时间<br>RTT<sub>D</sub>：RTT 的偏差的加权平均值</p><blockquote><p>新的 RTT<sub>D</sub> = (1 - β) x (旧的 RTT<sub>D</sub>) + β x |RTT<sub>s</sub> - 新的 RTT 样本|</p></blockquote><p>β：小于1的系数，推荐值是 1/4，即 0.25</p><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><p>流量控制(flow control)：让发送方的发送速率不要太快，要让接收方来得及接收</p><p>利用滑动窗口机制可以很方便地在 TCP 连接上实现对发送方的流量控制</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-13.png" alt="TCP协议-图13"></p><p><code>发送方的发送窗口不能超过接收方给出的接收窗口的数值</code>。TCP 的<code>窗口单位是字节，不是报文段</code></p><p>避免死锁：TCP 为每一个连接设有一个<code>持续计时器(persistence timer)</code>。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口<code>探测报文段</code>(仅携带1字节的数据)，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了</p><h3 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h3><h4 id="发送机制"><a href="#发送机制" class="headerlink" title="发送机制"></a>发送机制</h4><ul><li>TCP 维持一个变量，它等于<code>最大报文段长度 MSS</code>。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去</li><li>由发送方的应用进程指明要求发送报文段，即 TCP 支持的<code>推送(push)</code>操作</li><li>发送方的一个计时器期限到了，这时把当前已有的缓存数据装入报文段(但长度不能超过 MSS)发送出去</li></ul><h4 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h4><blockquote><p>在 TCP 的实现中广泛使用 Nagle 算法</p></blockquote><p>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据达到较快而网络速率较慢时，用这样的方法可明显地减少所用的网络宽带。Nagle 算法还规定，当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。这样可以有效提高网络的吞吐量</p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><blockquote><p>TCP 接收方的缓存已满，仅剩一个字节，并还将保持这种状态持续一段时间。导致发送方只能发送一个字节。导致网络的效率很低</p></blockquote><p>为了解决这个问题，可以<code>让接收方等待一段时间</code>，使得或者接受缓存已有足够空间容纳一个最长的报文段，或者<code>等到接受缓存已有一半空闲的空间</code>。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。发送方也不要发送大小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小</p><h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><p>在计算机网络中的链路容量(即宽带)、交换结点中的缓存和处理机等，都是网络资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<code>拥塞</code>(congestion)</p><p><code>拥塞控制</code>就是<code>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</code>。拥塞控制所要做的都是一个前提，就是<code>网络能够承受现有的网络负荷</code></p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-14.png" alt="TCP协议-图14"></p><h3 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h3><p>TCP 进行拥塞控制的算法有四种，即<code>慢开始</code>(slow-start)、<code>拥塞避免</code>(congestion avoidance)、<code>快重传</code>(fast retransmit)和<code>快恢复</code>(fast recovery)</p><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，就有可能引起网络发生拥塞。经验证明，较好的方法是先探测一下，即<code>由小到大逐渐增大发送窗口</code>，也就是说，<code>由小到大逐渐增大拥塞窗口数值</code></p><p>cwnd：发送方的拥塞窗口，开始发送方设置 cwnd = 1</p><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1，而不是像慢开始阶段那样加倍增加。因此在拥塞避免阶段就有“<code>加法增大</code>” AI(Additive Increase)的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd <code>按线性规律缓慢增长</code>，比慢开始算法的拥塞窗口增长速率缓慢得多</p><p>“拥塞避免”并非完全能够避免拥塞，而是把拥塞窗口控制为按线性规律增长，<code>使网络比较不容易出现拥塞</code></p><p>在执行慢开始算法时，发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加1，然后开始下一轮的传输。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时，就改成执行拥塞避免算法，拥塞窗口按线性规律增长</p><p>ssthresh：慢开始门限，一般的，会有一个初始值，下图中为16个报文段</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-15.png" alt="TCP协议-图15"></p><p>当拥塞窗口 cwnd = 24 时，网络出现了超时，发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段</p><h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><p>采用快重传算法可以让发送方<code>尽早知道发生了个别报文段的丢失</code>。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要<code>立即发送确认</code>，即使收到了<code>失序的报文段</code>也要立即发出对已收到的报文段的重复确认</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-16.png" alt="TCP协议-图16"></p><h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><p>发送方知道当前只是丢失了个别的报文段。于是不启动慢开始，而是执行<code>快恢复</code>算法。这时，发送方调整门限值 ssthresh = cwnd / 2 = 8，同时设置拥塞窗口 cwnd = ssthresh = 8，并开始执行拥塞避免算法</p><p>TCP Reno 版本：区别于老的 TCP Tahao 版本</p><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><p>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。运输连接有三个阶段，<code>连接建立</code>、<code>数据传送</code>和<code>连接释放</code>。运输的连接管理就是使运输连接的建立和释放都能够正常地进行</p><p>在 TCP 连接建立过程中要解决以下三个问题：</p><ul><li>要使每一方能够确知对方的存在</li><li>要允许双方协商一些参数(最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等)</li><li>能够对运输实体资源(缓存大小、连接表中的项目等)进行分配</li></ul><h3 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h3><p>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-17.png" alt="TCP协议-图17"></p><h4 id="连接建立过程"><a href="#连接建立过程" class="headerlink" title="连接建立过程"></a>连接建立过程</h4><ol><li>最初客户/服务器的 TCP 进程都处于 <code>CLOSED(关闭)</code>状态。在本实例中，A <code>主动打开连接</code>，而 B <code>被动打开连接</code></li><li>B 的 TCP 服务器进程先创建<code>传输控制块</code> TCB，并处于 <code>LISTEN(收听)</code> 状态，等待客户的连接请求</li><li>A 的 TCP 客户进程创建<code>传输控制模块</code> TCB。并向 B 发出连接请求报文段，首部中的同部位 SYN = 1，选择一个初始序号 seq = x。TCP 客户端进程进入 <code>SYN-SENT(同步已发送)</code> 状态。TCP 规定，SYN 报文段(即 SYN = 1 的报文段)不能携带数据，但要<code>消耗一个序号</code></li><li>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。这时 TCP 服务器进程进入 <code>SYN-RCVD(同步收到)</code> 状态。这个报文段也不能携带数据，但同样<code>要消耗掉一个序号</code></li><li>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置1，确认号 ack = y + 1，而自己的序号 seq = x + 1。TCP 的标准规定，ACK 报文段可以携带数据。但<code>如果不携带数据则不消耗序号</code>，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 <code>ESTABLISHED(已建立连接)</code> 状态</li><li>当 B 收到 A 的确认后，也进入 <code>ESTABLISHED</code> 状态</li></ol><blockquote><p><code>传输控制块</code> TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如：TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等</p></blockquote><h4 id="四报文握手"><a href="#四报文握手" class="headerlink" title="四报文握手"></a>四报文握手</h4><p>B 发送给 A 的报文段，可拆成两个报文段。先发送一个确认报文段(ACK = 1，ack = x + 1)，然后再发送一个同步报文段(SYN = 1，seq = y)。这样的过程就变成了<code>四报文握手</code>，与三报文握手效果一致</p><h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>为什么 A 最后还要发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传到了 B，因而产生错误</p><p>正常情况：A 发出连接请求，但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B，没有“已失效的连接请求报文段”</p><p>异常情况：A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用报文握手，那么只要 B 发出确认，新的连接就建立了。</p><blockquote><p>现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。B 的<code>许多资源就这样被浪费了</code>。</p></blockquote><blockquote><p>采用三报文握手的办法，可以防止上述现象的发生</p></blockquote><h3 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-18.png" alt="TCP协议-图18"></p><h4 id="连接释放过程"><a href="#连接释放过程" class="headerlink" title="连接释放过程"></a>连接释放过程</h4><ol><li>A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置1，其序号 seq = u，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入 <code>FIN-WAIT-1(终止等待1)</code> 状态，等待 B 的确认。TCP 规定，FIN 报文段即使不携带数据，也消耗一个序号</li><li>B 收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加1。B随即进入 <code>CLOSE-WAIT(关闭等待)</code> 状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于 <code>半关闭(half-close)</code> 状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间</li><li>A 收到来自 B 的确认后，就进入 <code>FIN-WAIT-2(终止等待2)</code> 状态，等待 B 发出的连接释放报文段</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 w(在半关闭状态 B 可能又发送了一些数据)。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 <code>LAST-ACK(最后确认)</code>状态，等待 A 的确认</li><li>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置1，确认号 ack = w + 1，而自己的序号是 seq = u + 1(根据 TCP 标准，前面发送过的 FIN 报文段要消耗一个序号)。然后进入到 <code>TIME-WAIT(时间等待)</code>状态。此时 TCP 连接还没有释放掉。必须经过<code>时间等待计时器(TIME-WAIT timer)</code>设置的时间2MSL后，A 才进入到 <code>CLOSED</code> 状态</li><li>当 A 撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接</li></ol><blockquote><p>时间 MSL 叫做<code>最长报文段寿命</code>(Maximum Segment Lifetime)，RFC 793建议设为2分钟。但这完全是从工程上来考虑的，对于现在的网络，MSL = 2分钟可能太长了一些</p></blockquote><h4 id="TIME-WAIT-等待时间"><a href="#TIME-WAIT-等待时间" class="headerlink" title="TIME-WAIT 等待时间"></a>TIME-WAIT 等待时间</h4><p>为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？</p><p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时 重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法安装正常步骤进入 CLOSED 状态</p><p>防止前面提到的“已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段</p><p>B 只要收到 A 发出的确认，就进入 CLOSED 状态。同样，B 在撤销相应的传输控制 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早一些</p><p><code>保活计时器(keepalive timer)</code>：服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接</p><h3 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h3><p>为了更清晰地看出 TCP 连接的各种状态之间的关系，下图为 TCP 的有限状态机。图中每一个方框即 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。请注意图中有三种不同的箭头。<code>粗实线箭头</code>表示对<code>客户进程的正常变迁</code>。<code>粗虚线箭头</code>表示对<code>服务器进程的正常变迁</code>。另一种<code>细线箭头</code>表示<code>异常变迁</code></p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-tcp-19.png" alt="TCP协议-图19"></p><p><strong>《TCP协议详解》原文链接：<a href="https://blog.maplemark.cn/2019/04/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.html">https://blog.maplemark.cn/2019/04/tcp协议详解.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 状态码</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/05.HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/05.HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码是来告诉客户端，发生了什么事情。状态码为客户端提供了一种<code>理解事务处理结果</code>的<code>便捷方式</code>。状态码位于响应的起始行中</p><blockquote><p>比如，在行 HTTP/1.0 200 OK 中，状态码就是200</p></blockquote><p>客户端向一个 HTTP 服务器发送请求报文时，会遇到很多意想不到的情况，请求不一定能够成功完成。服务器可能会告诉你无法找到所请求的资源，你没有访问资源的权限，或者资源被移到了其他地方</p><p>状态码是在每条响应报文的起始行中返回的。会返回一个数字状态和一个可读的状态。<code>数字码</code>便于程序进行差错处理，而<code>原因短语</code>则便于人们理解</p><h2 id="原因短语"><a href="#原因短语" class="headerlink" title="原因短语"></a>原因短语</h2><p>原因短语是响应起始行中的最后一个组件。它为状态码提供了<code>文本形式</code>的解释</p><blockquote><p>比如，在行 HTTP/1.0 200 OK 中，OK 就是原因短语</p></blockquote><p>原因短语和状态码是成对出现的。原因短语是状态码的<code>可读</code>版本，应用程序开发者将其传送给用户，用于说明在请求间发生了什么情况。HTTP 规范并没有提供任何硬性规定，要求原因短语以何种形式出现</p><h2 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h2><h3 id="五大类"><a href="#五大类" class="headerlink" title="五大类"></a>五大类</h3><p>可以通过三位数字代码对不同状态码进行分类</p><ul><li>200 到 299 之间的状态码表示成功</li><li>300 到 399 之间的代码表示资源已经被移走了</li><li>400 到 499 之间的代码表示客户端的请求出错了</li><li>500 到 599 之间的代码表示服务器出错了</li></ul><table><thead><tr><th>状态码</th><th>整体范围</th><th>已定义范围</th><th>分类</th></tr></thead><tbody><tr><td>1XX</td><td>100~199</td><td>100~101</td><td>信息提示</td></tr><tr><td>2XX</td><td>200~299</td><td>200~206</td><td>成功</td></tr><tr><td>3XX</td><td>300~399</td><td>300~305</td><td>重定向</td></tr><tr><td>4XX</td><td>400~499</td><td>400~415</td><td>客户端错误</td></tr><tr><td>5XX</td><td>500~599</td><td>500~505</td><td>服务器错误</td></tr></tbody></table><p>当前的 HTTP 版本只为每类状态定义了几个代码。随着协议的发展，HTTP 规范中会正式地定义更多的状态码。若收到了不认识的状态码，可能是有人将其作为当前协议的<code>扩展定义</code>的。可以根据其所处的范围，将它作为那个类别中一个普通的成员来处理</p><blockquote><p>例如，若收到了状态码 515(在 5XX 代码的已定义范围之外)，就应该认为这条响应指出了服务器的错误，这是 5XX 报文的通用类别</p></blockquote><h3 id="100-199，信息状态码"><a href="#100-199，信息状态码" class="headerlink" title="100 ~ 199，信息状态码"></a>100 ~ 199，信息状态码</h3><p>HTTP/1.1 向协议中引入了信息性状态码。这些状态码相对较新，关于其复杂性和感<br>知价值存在一些争论，而受到限制</p><table><thead><tr><th>状态码</th><th>原因短语</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应</td></tr><tr><td>101</td><td>Switching Protocols</td><td>说明服务器正在根据客户端的指定，将协议切换成 Update 首部所列的协议</td></tr></tbody></table><p>100 Continue 状态码的目的是对这样的情况进行优化：HTTP 客户端应用程序有一个实体的主体部分要发送给服务器，但希望在发送之前查看一下服务器是否会接受这个实体。客户端应用程序只有在避免向服务器发送一个服务器<code>无法处理或使用的大实体</code>，才应该使用 100 Continue</p><h3 id="200-299，成功状态码"><a href="#200-299，成功状态码" class="headerlink" title="200 ~ 299，成功状态码"></a>200 ~ 299，成功状态码</h3><p>客户端发起请求时，这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求</p><table><thead><tr><th>状态码</th><th>原因短语</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求没问题，实体的主体部分包含了所请求的资源</td></tr><tr><td>201</td><td>Created</td><td>用于创建服务器对象的请求(比如:PUT)。响应的实体主体部分中应该包含引用了已创建的资源的URL，Location首部包含的则是最具体的引擎。服务器必须在发送这个状态码之前创建好对象</td></tr><tr><td>202</td><td>Accepted</td><td>请求已被接受，服务器还未对其执行任何动作。不能保证服务器会完成这个请求；接受请求时，它看起来是有效的。服务器应在实体的主体部分包含对请求状态的描述，或附加请求预计处理时间、信息获取指针</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>实体首部包含的信息不是来自于源端服务器，而是来自资源的副本。如果中间节点上有一份副本，但无法或没有对元数据进行验证，就会出现这种情况</td></tr><tr><td>204</td><td>No Content</td><td>响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新（比如刷新一个表单页面）</td></tr><tr><td>205</td><td>Reset Content</td><td>另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有 HTML 表单元素</td></tr><tr><td>206</td><td>Partial Content</td><td>成功执行了一个部分或 Range(范围)请求。客户端可以通过一些特殊的首部来获取部分或某个范围内的文档</td></tr></tbody></table><h3 id="300-399，重定向状态码"><a href="#300-399，重定向状态码" class="headerlink" title="300 ~ 399，重定向状态码"></a>300 ~ 399，重定向状态码</h3><p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。如果资源已被移动，可发送一个重定向状态码和一个可选的 Location 首部来告知客户端资源已被移走，以及现在可以在哪里找到它。这样，浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了</p><p>请求报文</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php HTTP/1.1</span><br><span class="line">Host: blog.maplemark.cn</span><br><span class="line">Accept: *</span><br></pre></td></tr></table></figure><p>响应报文</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Date: Fri, 19 Apr 2019 03:58:59 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">X-Powered-By: PHP/7.2.16</span><br><span class="line">Location: https://blog.maplemark.cn/</span><br></pre></td></tr></table></figure><p>请求报文</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: blog.maplemark.cn</span><br><span class="line">Accept: *</span><br></pre></td></tr></table></figure><p>响应报文</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Date: Fri, 19 Apr 2019 03:59:34 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">...</span><br></pre></td></tr></table></figure><table><thead><tr><th>状态码</th><th>原因短语</th><th>含义</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档有多个语言版本。返回时会带有一个选项列表，用户可以选择期望使用的那项</td></tr><tr><td>301</td><td>Moved Permanently</td><td>在请求的 URL 已被移除时使用。响应的 Location 首部中应该包含资源现在所处的 URL</td></tr><tr><td>302</td><td>Found</td><td>与 301 状态码类似；但是，客户端应该使用 Location 首部给出的URL 来临时定位资源。将来的请求仍应使用老的 URL</td></tr><tr><td>303</td><td>See Other</td><td>告知客户端应该用另一个 URL 来获取资源。新的 URL 位于响应报文的 Location 首部。其主要目的是允许 POST 请求的响应将客户端定向到某个资源上去</td></tr><tr><td>304</td><td>Not Modified</td><td>客户端可以通过所包含的请求首部，使其请求变成有条件的。若用户发起了一个条件 GET 请求，而资源近期未被修改，可以通过该状态码表明。带有这个状态码的响应不应该包含实体的主体部分</td></tr><tr><td>305</td><td>Use Proxy</td><td>用来说明必须通过一个代理来访问资源；代理的位置由 Location首部给出。客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞</td></tr><tr><td>306</td><td>(未使用)</td><td>当前未使用</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>与 301 状态码类似；但客户端应该使用 Location 首部给出的 URL来临时定位资源。将来的请求应该使用老的 URL</td></tr></tbody></table><blockquote><p>302、303 和 307 状态码之间存在一些交叉。这些状态码的用法有着细微的差别，大部分差别都源于 HTTP/1.0 和 HTTP/1.1 应用程序对这些状态码<code>处理方式</code>的不同，为兼容 HTTP/1.0 而保留了一些状态码(例如 302 状态码)</p></blockquote><h3 id="400-499，客户端错误状态码"><a href="#400-499，客户端错误状态码" class="headerlink" title="400 ~ 499，客户端错误状态码"></a>400 ~ 499，客户端错误状态码</h3><p>有时客户端会发送一些服务器<code>无法处理</code>的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的 URL</p><p>很多客户端错误都是由浏览器来处理的，甚至不会打扰到你。只有少量错误，比如404，还是会穿过浏览器来到用户面前</p><table><thead><tr><th>状态码</th><th>原因短语</th><th>含义</th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>用于告知客户端它发送了一个错误的请求</td></tr><tr><td>401</td><td>Unauthorized</td><td>与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证</td></tr><tr><td>402</td><td>Payment Required</td><td>现在这个状态码还未使用，但已经被保留，以作未来之用</td></tr><tr><td>403</td><td>Forbidden</td><td>用于说明请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是在服务器不想说明拒绝原因的时候使用的</td></tr><tr><td>404</td><td>Not Found</td><td>用于说明服务器无法找到所请求的 URL。通常会包含一个实体，以便客户端应用程序显示给用户看</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>发起的请求中带有所请求的 URL 不支持的方法时，使用此状态码。应该在响应中包含 Allow 首部，以告知客户端对所请求的资源可以使用哪些方法</td></tr><tr><td>406</td><td>Not Acceptable</td><td>客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的 URL 相匹配的资源时，使用此代码。通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>与 401 状态码类似，但用于要求对资源进行认证的代理服务器</td></tr><tr><td>408</td><td>Request Timeout</td><td>如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同有所不同，但通常对所有的合法请求来说，都是够长的</td></tr><tr><td>409</td><td>Conflict</td><td>用于说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时，可以发送此状态码。响应中应该包含描述冲突的主体</td></tr><tr><td>410</td><td>Gone</td><td>与 404 类似，只是服务器曾经拥有过此资源。主要用于 Web 站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了</td></tr><tr><td>411</td><td>Length Required</td><td>服务器要求在请求报文中包含 Content-Length 首部时使用</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端发起了条件请求，且其中一个条件失败了的时候使用。客户端包含了 Expect 首部时发起的就是条件请求</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>客户端发送的实体主体部分比服务器能够或者希望处理的要大时，使用此状态码</td></tr><tr><td>414</td><td>Request URI Too Long</td><td>客户端所发请求中的请求 URL 比服务器能够或者希望处理的要长时，使用此状态码</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法理解或无法支持客户端所发实体的内容类型时，使用此状态码</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td>请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时，使用此状态码</td></tr><tr><td>417</td><td>Expectation Failed</td><td>请求的 Expect 请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。如果代理或其他中间应用程序有确切证据说明源端服务器会为某请求产生一个失败的期望，就可以发送这个响应状态码</td></tr></tbody></table><h3 id="500-599，服务器错误状态码"><a href="#500-599，服务器错误状态码" class="headerlink" title="500 ~ 599，服务器错误状态码"></a>500 ~ 599，服务器错误状态码</h3><p>有时客户端发送了一条有效请求，服务器自身却出错了。这可能是客户端碰上了服务器的缺陷，或者服务器上的子元素，比如某个网关资源，出了错</p><p>代理尝试着代表客户端与服务器进行交流时，经常会出现问题。代理会发布 5XX 服务器错误状态码来描述所遇到的问题</p><table><thead><tr><th>状态码</th><th>原因短语</th><th>含义</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码</td></tr><tr><td>501</td><td>Not Implemented</td><td>客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）时，使用此状态码</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）时，使用此状态码</td></tr><tr><td>503</td><td>Service Unavailable</td><td>用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可以在响应中包含一个 RetryAfter 首部</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>与状态码 408 类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此状态码。有些服务器应用程序会选择不支持协议的早期版本</td></tr></tbody></table><p><strong>《HTTP状态码》 原文链接：<a href="https://blog.maplemark.cn/2019/04/http%E7%8A%B6%E6%80%81%E7%A0%81.html">https://blog.maplemark.cn/2019/04/http状态码.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP方法详解</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/06.HTTP%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/06.HTTP%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP方法详解"><a href="#HTTP方法详解" class="headerlink" title="HTTP方法详解"></a>HTTP方法详解</h1><h2 id="常见的-HTTP-方法"><a href="#常见的-HTTP-方法" class="headerlink" title="常见的 HTTP 方法"></a>常见的 HTTP 方法</h2><p>HTTP 请求方法用于告诉服务器要做什么。HTTP 规范中定义了一组常用的请求方法。</p><blockquote><p>例如：GET 方法负责从服务器获取文档，POST 方法会向服务器发送需要处理的数据，OPTIONS 方法用于确定服务器的一般功能，或者服务器处理特定资源的能力</p></blockquote><p>下图描述了7种 HTTP 方法，并不是所有服务器都实现了所有7种方法。有些方法的请求报文中有主体，有些则无主体的请求</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method.png" alt="HTTP方法"></p><p>由于 HTTP 设计易于扩展，除这些方法，其他服务器可能还会实现一些自己的请求方法。这些附加的方法是对 HTTP 规范的扩展，被称为<code>扩展方法</code></p><h2 id="安全方法"><a href="#安全方法" class="headerlink" title="安全方法"></a>安全方法</h2><p>HTTP 定义了一组被称为<code>安全方法</code>的方法。GET 方法和 HEAD 方法都被认为是安全的，这就意味着使用 GET 或 HEAD 方法的 HTTP 请求都不会产生什么动作</p><p>不产生动作，在这里意味着 HTTP 请求不会在服务器上产生什么结果。例如，你在 Colin 的五金商店购物时，点击了“提交购买”按钮。点击按钮时会提交一个带有信用卡信息的 POST 请求，那么在服务器上，就会为你执行一个动作。在这种情况下，为购买行为支付信用卡就是所执行的动作</p><p>安全方法并不一定是什么动作都不执行的（实际上，这是由 Web 开发者决定的）。使用安全方法的目的就是当使用可能引发某一动作的不安全方法时，<code>允许 HTTP 应用程序开发者通知用户</code>。在 Colin 的五金商店的例子中，你的 Web 浏览器可能会弹出一条警告消息，说明你正在用不安全的方法发起请求，这样可能会在服务器上引发一些事件（比如用你的信用卡支付费用）</p><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><h3 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h3><p>GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-01.png" alt="HTTP方法-GET"></p><h3 id="HEAD-方法"><a href="#HEAD-方法" class="headerlink" title="HEAD 方法"></a>HEAD 方法</h3><p>HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用 HEAD，可以：</p><ul><li>在不获取资源的情况下了解资源的情况(比如，判断其类型)</li><li>通过查看响应中的状态码，看看某个对象是否存在</li><li>通过查看首部，测试资源是否被修改了</li></ul><p>服务器开发者必须确保返回的首部与 GET 请求所返回的首部完全相同。遵循 HTTP/1.1 规范，就必须实现 HEAD 方法</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-02.png" alt="HTTP方法-HEAD"></p><h3 id="PUT-方法"><a href="#PUT-方法" class="headerlink" title="PUT 方法"></a>PUT 方法</h3><p>与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建 Web 页面，并用 PUT 直接将其安装到 Web 服务器上去</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-03.png" alt="HTTP方法-PUT"></p><p>PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它。</p><p>因为 PUT 允许用户对内容进行修改，所以很多 Web 服务器都要求在执行 PUT 之前，用密码登录</p><h3 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h3><p>POST 方法起初是用来向服务器输入数据的。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-04.png" alt="HTTP方法-POST"></p><h3 id="TRACE-方法"><a href="#TRACE-方法" class="headerlink" title="TRACE 方法"></a>TRACE 方法</h3><p>客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会<code>修改原始的 HTTP 请求</code>。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子</p><p>TRACE 请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求/响应链上，原始报文是否，以及如何被毁坏或修改过 TRACE 方法主要用于诊断；也就是说，用于验证请求是否如愿穿过了请求/响应链。它也是一种很好的工具，可以用来查看代理和其他应用程序对用户请求所产生效果</p><p>尽管 TRACE 可以很方便地用于诊断，但它确实也有缺点，它假定中间应用程序对各种不同类型请求（不同的方法——GET、HEAD、POST 等）的处理是相同的。很多 HTTP 应用程序会根据方法的不同做出不同的事情——比如，代理可能会将 POST 请求直接发送给服务器，而将 GET 请求发送给另一个 HTTP 应用程序（比如Web 缓存）。TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对 TRACE 请求的处理方式</p><p>TRACE 请求中不能带有实体的主体部分。TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-05.png" alt="HTTP方法-TRACE"></p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）</p><p>这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-06.png" alt="HTTP方法-OPTIONS"></p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-07.png" alt="HTTP方法-DELETE"></p><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法指的就是没有在 HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一些 HTTP 服务，这些方法为开发者提供了一种扩展这些 HTTP 服务能力的手段。下图列出了一些常见的扩展方法实例。这些方法就是 WebDAV HTTP 扩展包含的所有方法，这些方法有助于通过 HTTP 将 Web 内容发布到 Web 服务器上去</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method-08.png" alt="HTTP方法-扩展方法"></p><p>并不是所有的扩展方法都是在正式规范中定义的，认识到这一点很重要。如果你定义了一个扩展方法，很可能大部分 HTTP 应用程序都无法理解。同样，你的 HTTP应用程序也可能会遇到一些其他应用程序在用的，而它并不理解的扩展方法</p><p>在这些情况下，最好对扩展方法宽容一些。如果能够在不破坏端到端行为的情况下将带有未知方法的报文传递给下游服务器，代理应尝试传递这些报文。如果可能破坏端到端行为则应以 501 Not Implemented（无法实现）状态码进行响应。最好按惯例“对所发送的内容要求严一点，对所接收的内容宽容一些”来处理扩展方法（以及一般的 HTTP 扩展）</p><p><strong>《HTTP方法详解》 原文链接：<a href="https://blog.maplemark.cn/2019/04/http%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.html">https://blog.maplemark.cn/2019/04/http方法详解.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 细节介绍</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/07.HTTPS%E7%BB%86%E8%8A%82%E4%BB%8B%E7%BB%8D/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/07.HTTPS%E7%BB%86%E8%8A%82%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTPS-细节介绍"><a href="#HTTPS-细节介绍" class="headerlink" title="HTTPS 细节介绍"></a>HTTPS 细节介绍</h1><p>HTTPS 是最常见的 HTTP <code>安全版本</code>。它得到了很广泛的应用，所有主要的商业浏览器和服务器上都提供 HTTPS。HTTPS 将 HTTP 协议与一组强大的对称、非对称和基于证书的加密技术结合在一起，使得 HTTPS 不仅很安全，而且很灵活，很容易在处于无序状态的、分散的全球互联网上进行管理</p><p>HTTPS 加速了因特网应用程序的成长，已经成为基于 Web 的电子商务快速成长的主要推动力。在广域网中对分布式 Web 应用程序的安全管理方面，HTTPS 也是非常重要的</p><h2 id="HTTPS-概述"><a href="#HTTPS-概述" class="headerlink" title="HTTPS 概述"></a>HTTPS 概述</h2><p>HTTPS 就是在安全的传输层上发送的 HTTP。HTTPS 没有将未加密的 HTTP 报文发送给 TCP，并通过世界范围内的因特网进行传输，它在将 HTTP 报文发送给 TCP 之前，先将其发送给了一个安全层，对其进行加密</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-https-01.png" alt="HTTPS-图01"></p><p>现在，HTTP 安全层是通过 SSL 及其现代替代协议 TLS 来实现的。我们遵循常见的用法，用术语 SSL 来表示 SSL 或者 TLS</p><h2 id="HTTPS-方案"><a href="#HTTPS-方案" class="headerlink" title="HTTPS 方案"></a>HTTPS 方案</h2><p>现在，安全 HTTP 是可选的。因此，对 Web 服务器发起请求时，我们需要有一种方式来告知 Web 服务器去执行 HTTP 的安全协议版本。这是在 URL 的方案中实现的。通常情况下，非安全 HTTP 的 URL 方案前缀为 http，如下所示：</p><blockquote><p><a href="http://blog.maplemark.cn/">http://blog.maplemark.cn</a></p></blockquote><p>在安全 HTTPS 协议中，URL 的方案前缀为 https，如下所示：</p><blockquote><p><a href="https://blog.maplemark.cn/">https://blog.maplemark.cn</a></p></blockquote><p>请求一个客户端（比如 Web 浏览器）对某 Web 资源执行某事务时，它会去检查 URL 的方案</p><ul><li>如果 URL 的方案为 http，客户端就会打开一条到服务器端口 80（默认情况下）<br>的连接，并向其发送老的 HTTP 命令</li><li>如果 URL 的方案为 https，客户端就会打开一条到服务器端口 443（默认情况下）<br>的连接，然后与服务器“握手”，以二进制格式与服务器交换一些 SSL 安全参数，<br>附上加密的 HTTP 命令</li></ul><p>SSL 是个二进制协议，与 HTTP 完全不同，其流量是承载在另一个端口上的（SSL 通常是由端口 443 承载的）。如果 SSL 和 HTTP 流量都从端口 80 到达，大部分 Web 服务器会将二进制 SSL 流量理解为错误的 HTTP 并关闭连接。将安全服务进一步整合到 HTTP 层中去就无需使用多个目的端口了，在实际中这样不会引发严重的问题</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-https-02.png" alt="HTTPS-图02"></p><h2 id="建立安全传输"><a href="#建立安全传输" class="headerlink" title="建立安全传输"></a>建立安全传输</h2><p>在未加密 HTTP 中，客户端会打开一条到 Web 服务器端口 80 的 TCP 连接，发送一条请求报文，接收一条响应报文，关闭连接</p><p>由于 SSL 安全层的存在，HTTPS 中这个过程会略微复杂一些。在 HTTPS 中，客户端首先打开一条到 Web 服务器端口 443（安全 HTTP 的默认端口）的连接。一旦建立了 TCP 连接，客户端和服务器就会初始化 SSL 层，对加密参数进行沟通，并交换密钥。握手完成之后，SSL 初始化就完成了，客户端就可以将请求报文发送给安全层了。在将这些报文发送给 TCP 之前，要先对其进行加密</p><h2 id="SSL-握手"><a href="#SSL-握手" class="headerlink" title="SSL 握手"></a>SSL 握手</h2><p>在发送已加密的 HTTP 报文之前，客户端和服务器要进行一次 SSL 握手，在这个握手过程中，它们要完成以下工作</p><ul><li>交换协议版本号</li><li>选择一个两端都了解的密码</li><li>对两端的身份进行认证</li><li>生成临时的会话密钥，以便加密信道</li></ul><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-https-03.png" alt="HTTPS-图03"></p><p>在通过网络传输任何已加密的 HTTP 数据之前，SSL 已经发送了一组握手数据来建立通信连接了</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-https-04.png" alt="HTTPS-图04"></p><p>这是 SSL 握手的简化版本。根据 SSL 的使用方式，握手过程可能会复杂一些，但总<br>的思想就是这样</p><h2 id="服务器证书"><a href="#服务器证书" class="headerlink" title="服务器证书"></a>服务器证书</h2><p>SSL 支持双向认证，将服务器证书承载回客户端，再将客户端的证书回送给服务器。而现在，浏览时并不经常使用客户端证书。大部分用户甚至都没有自己的客户端证书。服务器可以要求使用客户端证书，但实际中很少出现这种情况。</p><p>另一方面，安全 HTTPS 事务总是要求使用服务器证书的。在一个 Web 服务器上执行安全事务，比如提交信用卡信息时，你总是希望是在与你所认为的那个组织对话。由知名权威机构签发的服务器证书可以帮助你在发送信用卡或私人信息之前评估你对服务器的信任度。</p><p>服务器证书是一个显示了组织的名称、地址、服务器 DNS 域名以及其他信息的 X.509 v3 派生证书。你和你所用的客户端软件可以检查证书，以确保所有的信息都是可信的</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-https-05.png" alt="HTTPS-图05"></p><h2 id="站点证书的有效性"><a href="#站点证书的有效性" class="headerlink" title="站点证书的有效性"></a>站点证书的有效性</h2><p>SSL 自身不要求用户检查 Web 服务器证书，但大部分现代浏览器都会对证书进行简单的完整性检查，并为用户提供进行进一步彻查的手段。网景公司提出的一种 Web 服务器证书有效性算法是大部分浏览器有效性验证技术的基础。</p><ul><li>日期检测</li></ul><p>首先，浏览器检查证书的起始日期和结束日期，以确保证书仍然有效。如果证书过期了，或者还未被激活，则证书有效性验证失败，浏览器显示一条错误信息</p><ul><li>签名颁发者可信度检测</li></ul><p>每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。证书有不同的等级，每种证书都要求不同级别的背景验证。比如，如果申请某个电子商务服务器证书，通常需要提供一个营业的合法证明</p><p>任何人都可以生成证书，但有些 CA 是非常著名的组织，它们通过非常清晰的流程来验证证书申请人的身份及商业行为的合法性。因此，浏览器会附带一个签名颁发机构的受信列表。如果浏览器收到了某未知（可能是恶意的）颁发机构签发的证书，那它通常会显示一条警告信息。有些证书会携带到受信 CA 的有效签名路径，浏览器可能会选择接受所有此类证书。换句话说，如果某受信 CA 为“Sam 的签名商店”签发了一个证书，而 Sam 的签名商店也签发了一个站点证书，浏览器可能会将其作为从有效 CA 路径导出的证书接受</p><ul><li>签名检测</li></ul><p>一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性</p><ul><li>站点身份检测</li></ul><p>为防止服务器复制其他人的证书，或拦截其他人的流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器的域名是否匹配。服务器证书中通常都包含一个域名，但有些 CA 会为一组或一群服务器创建一些包含了服务器名称列表或通配域名的证书。如果主机名与证书中的标识符不匹配，面向用户的客户端要么就去通知用户，要么就以表示证书不正确的差错报文来终止连接</p><p><strong>《HTTPS细节介绍》 原文链接：<a href="http://blog.maplemark.cn/2019/05/https%E7%BB%86%E8%8A%82%E4%BB%8B%E7%BB%8D.html">http://blog.maplemark.cn/2019/05/https细节介绍.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSL/TLS协议运行机制的概述</title>
      <link href="/interview/docs/01.%E7%BD%91%E7%BB%9C/08.SSL-TLS%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
      <url>/interview/docs/01.%E7%BD%91%E7%BB%9C/08.SSL-TLS%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SSL-TLS协议运行机制的概述"><a href="#SSL-TLS协议运行机制的概述" class="headerlink" title="SSL/TLS协议运行机制的概述"></a>SSL/TLS协议运行机制的概述</h1><p>互联网的通信安全，建立在SSL/TLS协议之上。</p><p>本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅<a href="http://tools.ietf.org/html/rfc5246">RFC文档</a>。</p><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p><ul><li><code>窃听风险</code>（eavesdropping）：第三方可以获知通信内容。</li><li><code>篡改风险</code>（tampering）：第三方可以修改通信内容。</li><li><code>冒充风险</code>（pretending）：第三方可以冒充他人身份参与通信。</li></ul><p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p><ul><li>所有信息都是<code>加密传播</code>，第三方无法窃听。</li><li>具有<code>校验机制</code>，一旦被篡改，通信双方会立刻发现。</li><li>配备<code>身份证书</code>，防止身份被冒充。</li></ul><p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p><h2 id="二、历史"><a href="#二、历史" class="headerlink" title="二、历史"></a>二、历史</h2><p>互联网加密通信协议的历史，几乎与互联网一样长。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。</span><br><span class="line">1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。</span><br><span class="line">1996年，SSL 3.0版问世，得到大规模应用。</span><br><span class="line">1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。</span><br><span class="line">2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。</span><br></pre></td></tr></table></figure><p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。</p><p>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p><h2 id="三、基本的运行过程"><a href="#三、基本的运行过程" class="headerlink" title="三、基本的运行过程"></a>三、基本的运行过程</h2><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><ul><li>如何保证公钥不被篡改？</li></ul><blockquote><p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></blockquote><ul><li>公钥加密计算量太大，如何减少耗用的时间？</li></ul><blockquote><p>解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p></blockquote><p>因此，SSL/TLS协议的基本过程是这样的：</p><blockquote><p>客户端向服务器端索要并验证公钥。</p></blockquote><blockquote><p>双方协商生成”对话密钥”。</p></blockquote><blockquote><p>双方采用”对话密钥”进行加密通信。</p></blockquote><p>上面过程的前两步，又称为”握手阶段”（handshake）。</p><h2 id="四、握手阶段的详细过程"><a href="#四、握手阶段的详细过程" class="headerlink" title="四、握手阶段的详细过程"></a>四、握手阶段的详细过程</h2><p>“握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。</p><h3 id="4-1-客户端发出请求（ClientHello）"><a href="#4-1-客户端发出请求（ClientHello）" class="headerlink" title="4.1 客户端发出请求（ClientHello）"></a>4.1 客户端发出请求（ClientHello）</h3><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p><p>在这一步，客户端主要向服务器提供以下信息。</p><blockquote><p>支持的协议版本，比如TLS 1.0版。</p></blockquote><blockquote><p>一个客户端生成的随机数，稍后用于生成”对话密钥”。</p></blockquote><blockquote><p>支持的加密方法，比如RSA公钥加密。</p></blockquote><blockquote><p>支持的压缩方法。</p></blockquote><p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p><p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p><h3 id="4-2-服务器回应（SeverHello）"><a href="#4-2-服务器回应（SeverHello）" class="headerlink" title="4.2 服务器回应（SeverHello）"></a>4.2 服务器回应（SeverHello）</h3><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p><blockquote><p>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</p></blockquote><blockquote><p>一个服务器生成的随机数，稍后用于生成”对话密钥”。</p></blockquote><blockquote><p>确认使用的加密方法，比如RSA公钥加密。</p></blockquote><blockquote><p>服务器证书。</p></blockquote><p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p><h3 id="4-3-客户端回应"><a href="#4-3-客户端回应" class="headerlink" title="4.3 客户端回应"></a>4.3 客户端回应</h3><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><blockquote><p>一个随机数。该随机数用服务器公钥加密，防止被窃听。</p></blockquote><blockquote><p>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p></blockquote><blockquote><p>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p></blockquote><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：</p><blockquote><p>“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</p></blockquote><blockquote><p>对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</p></blockquote><blockquote><p>pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”</p></blockquote><p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><h3 id="4-4-服务器的最后回应"><a href="#4-4-服务器的最后回应" class="headerlink" title="4.4 服务器的最后回应"></a>4.4 服务器的最后回应</h3><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><blockquote><p>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</p></blockquote><blockquote><p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p></blockquote><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li>MicroSoft TechNet, <a href="http://technet.microsoft.com/en-us/library/cc785811(v=ws.10).aspx">SSL/TLS in Detail</a></li><li>Jeff Moser, <a href="http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html">The First Few Milliseconds of an HTTPS Connection</a></li><li>Wikipedia, <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a></li><li>StackExchange, <a href="http://security.stackexchange.com/questions/20803/how-does-ssl-work">How does SSL work?</a></li></ul><p>（完）</p><p><strong>《SSL/TLS协议运行机制的概述》 <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">原文链接</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法概述</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>什么是数据结构？如果翻阅不同的教材，可以看到五花八门的描述。事实上，这个问题在计算机科学界至今没有标准的定义。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在计算机科学中，数据结构(英语：data structure)是计算机中存储、组织数据的方式(维基百科）</span><br></pre></td></tr></table></figure><h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><h4 id="书籍摆放"><a href="#书籍摆放" class="headerlink" title="书籍摆放"></a>书籍摆放</h4><p>问题：如果你是书店的主人，该如何摆放你的书籍，才能让顾客最快捷的找到想要的书籍？</p><ul><li>方法1：随便放</li></ul><blockquote><p>放书非常方便，有新书直接插到空位。但是查找很不方便，如果没有这本书，需要翻遍整个书架</p></blockquote><ul><li>方法2：按照书名的拼音字母顺序排放</li></ul><blockquote><p>新书插入需要给新书腾出空间，造成图书需要向后移动</p></blockquote><ul><li>方法3：把书架分成几块区域，每块区域指定摆放某种类别的图书；在每种类别内，按照书名的拼音字母顺序排放</li></ul><blockquote><p>查找和插入工作量都减少很多，但是无法预估每种类别的图书会有多少，容易造成空间的浪费</p></blockquote><h4 id="数字打印"><a href="#数字打印" class="headerlink" title="数字打印"></a>数字打印</h4><p>问题：写程序实现一个函数 PrintN，使得传入一个正整数为 N 的参数，能顺序打印从 1 到 N 的全部正整数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintN</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">&#123;$i&#125;</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//版本二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrintN</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$n</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="title function_ invoke__">PrintN</span>(<span class="variable">$n</span>-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">&#123;$n&#125;</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当输入 N 为 100、1000、10000…，N 变的越来越大时候，实现版本一和版本二有什么区别？(debug_backtrace)</p></blockquote><h4 id="一元多项式计算"><a href="#一元多项式计算" class="headerlink" title="一元多项式计算"></a>一元多项式计算</h4><p>问题：一元多项式的标准表达式可以写成：f(x) = $a_0$ + $a_1$x + … + $a_{n-1}$$x^{n-1}$ + $a_n$$x^n$。现给定一个多项式的阶数 n，并将全体系数 ${a_i}^n_{i=0}$ 存放在数组 a[] 里。请写程序计算这个多项式在给定点 x 处的值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="variable">$n</span>, <span class="variable">$a</span>, <span class="variable">$x</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$a</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line"><span class="variable">$p</span> += <span class="variable">$a</span>[<span class="variable">$i</span>] * <span class="title function_ invoke__">pow</span>(<span class="variable">$x</span>, <span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$x</span> = <span class="number">2</span>; <span class="variable">$n</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$a</span> = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt;= <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line"><span class="variable">$a</span>[<span class="variable">$i</span>] = <span class="variable">$i</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$fn</span> = <span class="title function_ invoke__">f</span>(<span class="variable">$n</span>, <span class="variable">$a</span>, <span class="variable">$x</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$fn</span> . <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>通过提公因式 x 减少乘法的运算次数，把多项式改写为：</p><blockquote><p>f(x) = $a_0$ + x($a_1$ + x(…($a_{n-1}$ + x($a_n$))…))</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"><span class="variable">$n</span>, <span class="variable">$a</span>, <span class="variable">$x</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$a</span>[<span class="variable">$n</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="variable">$n</span>; <span class="variable">$i</span> &gt; <span class="number">0</span> ; <span class="variable">$i</span>--) &#123; </span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$a</span>[<span class="variable">$i</span>-<span class="number">1</span>] + <span class="variable">$x</span> * <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$p</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决问题的效率"><a href="#解决问题的效率" class="headerlink" title="解决问题的效率"></a>解决问题的效率</h3><p>解决一个非常简单的问题，往往也有多种方法，且不同方法之间的效率可能相差甚远。解决问题方法的效率，跟<code>数据的组织方式</code>有关，跟<code>空间的利用效率</code>有关，也跟<code>算法的巧妙程度</code>有关。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>数据结构的定义，首先应该包含数据对象在计算机中的组织方式——这类似于图书的摆放方法。并且，数据对象必定与一系列加在数据对象上的操作相关联，就如我们在书架上摆放图书是为了能找得到想要的书，或者是插入一本新买的书。</p></li><li><p>在讨论数据结构的时候，关心的是<code>数据对象</code>本身以及它们在计算机中的<code>组织方式</code>，还要关心与它们相关联的<code>操作集</code>，以及实现这些操作的最高效的算法。</p></li><li><p>关于数据对象在计算机中的组织方式，包含两个概念：数据对象集的逻辑结构、数据对象集在计算机中的物理存储结构</p></li></ul><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><ul><li><p>抽象数据类型(Abstract Data Type)是一种对”数据结构”的描述，这种描述是”抽象”的。数据类型描述内容：数据对象集、与数据集合相关联的操作集。</p></li><li><p>抽象：描述数据类型的方法不依赖于具体实现，即数据对象集合操作集的描述与存放数据的机器无关、与数据存储的物理结构无关、与实现操作的算法和编程语言均无关。抽象是计算机求解问题的基本方式和重要手段，使得一种设计可以应用于多种场景。</p></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>算法(algorithm)自于9世纪波斯数学家，在数学上提出了算法这个概念。</p></blockquote><p>算法是一个<code>有限指令集</code>，它接受一些输入(非必须)，产生输出，并一定在有限步骤之后终止。</p><blockquote><p>算法不是程序，算法比程序更抽象，强调表现做什么，忽略细节性怎么做。这样的好处是使整体思路清晰易懂，形成模块化的风格。</p></blockquote><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>衡量、比较算法的指标主要有以下两个：</p><ul><li>空间复杂度 S(n)：根据算法写成的程序在执行时占用存储单元的长度</li><li>时间复杂度 T(n)：根据算法写成的程序在执行时耗时时间的长度</li></ul><p>分析一般算法效率：</p><ul><li>最坏情况复杂度 $T_{worst}$(n)</li><li>平均复杂度 $T_{avg}$(n)</li></ul><p><strong>《数据结构与算法概述》 原文链接：<a href="https://blog.maplemark.cn/2019/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.html">https://blog.maplemark.cn/2019/07/数据结构与算法概述.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构实现基础</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构实现基础"><a href="#数据结构实现基础" class="headerlink" title="数据结构实现基础"></a>数据结构实现基础</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><h3 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h3><p>例子：在日常数据处理中，经常碰到需要对一组数据进行基本的统计分析，包含这些操作：平均数、最大值、最小值、中位数、标准差、方差等。这类统计可能发生在各种情况，比如学生成绩统计、家庭开支情况、GDP 统计等等，都会涉及到这类数据统计。</p><p>为每个具体应用都编写一个程序不会是一个好方法，程序都具有很大的相似性。数据结构的处理方法是从这些具体应用中<code>抽象出共性的数据组织与操作方法</code>，进而采用某种具体的程序设计语言<code>实现相应的数据存储与操作</code></p><p>数据抽象</p><ul><li>类型名称：统计数据集</li><li>数据对象集：N 个元素 {x<sub>1</sub>, x<sub>2</sub>, … , x<sub>N</sub>} 的集合 S</li><li>操作集：</li></ul><ol><li>ElementType Average(S, N)：求 S 中 N 个元素的平均值</li><li>ElementType Max(S, N)：求 S 中 N 个元素的最大值</li><li>ElementType Min(S, N)：求 S 中 N 个元素的最小值</li><li>ElementType Median(S, N)：求 S 中 N 个元素的中位数</li></ol><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>数据组织的基本存储方式主要是利用数组和链表方式来实现的，包括很复杂的数据结构，如图、树，也都不外乎应用数组和链表来实现</p><ul><li>若要实现的操作不是基本统计，而是集合运算，需要判断元素是否属于集合、对集合进行并和交运算、元素插入集合等。这些操作虽然在简单数组也可以实现，但是效率不高，使用树的组织方式可以更方便的实现集合的上述运算。</li><li>若除了基本的统计操作外，还需要动态的维护一个集合，即经常往集合里加入/删除元素，那应该设计多大的数组来保存这些元素呢，太大浪费空间，太小不够用。使用链表来保存数据或许更适合，但是链表也有缺点，链表需要记录后续节点地址，跟数组存储相比，链表需要更多的存储空间，同时程序实现也比数组更加复杂。</li></ul><p>数据结构的存储实现跟所需要的操作密切相关，<code>没有最好的存储方式，只有最合适的存储方式</code>。</p><h3 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h3><ul><li><p>在确定数据的存储方式后，数据结构涉及的另一个问题是相关的操作如何实现。这些操作的实现需要利用程序设计语言提供的另一个功能，即<code>流程设计功能</code>。</p></li><li><p>在任何高级程序设计语言都提供了一种的基本流程控制语句，即分支控制语句和循环控制语句。分支控制结构、循环控制结构加上程序自然的语句顺序执行结构，是实现任何算法流程的基本结构。</p></li><li><p>在程序中，我们可以将程序的某个基本功能设计为函数，这一方面降低了程序设计的复杂性，另一方面也提高了程序设计的重用性。递归是数据结构算法设计的很重要的手段。</p></li></ul><h2 id="数据结构存储基础"><a href="#数据结构存储基础" class="headerlink" title="数据结构存储基础"></a>数据结构存储基础</h2><p>变量是数据存储的基本单位，而变量是有类型的，例如：整型、浮点型、字符型、布尔型</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是最基本的构造类型，它是一组相同类型数据的有序集合</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针变量用于存放变量的地址，通过指针就能间接访问那个变量</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构类型是一种允许把一些数据分量聚合成一个整体的数据类型，它能够把有内在联系的不同类型的数据统一成一个整体，使它们相互关联。同时，结构又是一个变量的集合，可以按照与成员类型变量相同的操作方法单独使用其变量成员。结构与数组的区别在于，数组的所有元素必须是相同类型的，而结构的成员可以是不同的数据类型。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct 结构名 &#123;</span><br><span class="line">类型名 结构成员名 1;</span><br><span class="line">类型名 结构成员名 2;</span><br><span class="line">......</span><br><span class="line">类型名 结构成员名 n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表使一种常见而重要的基础数据结构，也是实现复杂数据结构的重要手段。它不按照线性的顺序存储数据，而是由若干个同一结构类型的”结点”依次串联而成的，即每一个结点里保存着下一个结点的地址。使用链表结构可以克服数据需要预先知道数据大小的缺点，可以充分利用计算机内存空间，实现灵活的内存动态管理。但链表失去了数组方便随机存储的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><h4 id="单向链表的结构"><a href="#单向链表的结构" class="headerlink" title="单向链表的结构"></a>单向链表的结构</h4><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//DSA-single-link.png" alt="单向链表的组成示意图"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向链表结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$next</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $p1 结点数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $p2 下一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$p1</span>, <span class="variable">$p2</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;data = <span class="variable">$p1</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;next = <span class="variable">$p2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单向链表的常见操作"><a href="#单向链表的常见操作" class="headerlink" title="单向链表的常见操作"></a>单向链表的常见操作</h4><ul><li>链表的建立</li></ul><p>应用链表进行程序设计时，往往需要先建立一个链表，建立链表的过程实际上就是不断在链表中插入结点的过程</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleLinkList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $n int 结点数目</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> $head obj 头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$head</span> = <span class="keyword">new</span> <span class="title function_ invoke__">node</span>(<span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="variable">$n</span>; <span class="variable">$i</span> &gt; <span class="number">0</span>; <span class="variable">$i</span>--) &#123; </span><br><span class="line"><span class="variable">$newNode</span> = <span class="keyword">new</span> <span class="title function_ invoke__">node</span>(<span class="variable">$i</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="variable">$newNode</span>-&gt;next = <span class="variable">$head</span>-&gt;next;</span><br><span class="line"><span class="variable">$head</span>-&gt;next = <span class="variable">$newNode</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$head</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入结点</li></ul><p>在单向链表 head 的某个结点 p 之后插入一新结点：找到正确位置 p，申请新结点 t 并对 t 的结点信息赋值，最后将 t 插入在 p 之后</p><ul><li>删除结点</li></ul><p>从单向链表 head 中删除一个结点：找到被删除结点的前面一个结点 p，删除 p 之后的结点</p><ul><li>单向链表的遍历</li></ul><p>对单向链表最常见的处理方式：逐个查看链表中每个结点的数据并进行处理</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//DSA-double-link.png" alt="双向链表"></p><p>在单向链表基础上增加指向前驱单元指针的链表叫做<code>双向链表</code>。结点增加指向其前驱结点的指针，将牺牲一部分空间代价，前驱单元查找可以不必从链头开始查找</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$next</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$previous</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $p1 结点数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $p2 下一个结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $p3 前一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$p1</span>, <span class="variable">$p2</span>, <span class="variable">$p3</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;data = <span class="variable">$p1</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;next = <span class="variable">$p2</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;previous = <span class="variable">$p3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//DSA-double-link2.png" alt="双向循环链表"></p><p>将双向链表最后一个单元的 Next 指针指向链表的第一个单元，而第一个单元的 Previous 指针指向链表的最后一个单元，这样构成的链表称为<code>双向循环链表</code></p><h2 id="流程控制基础"><a href="#流程控制基础" class="headerlink" title="流程控制基础"></a>流程控制基础</h2><p>程序设计语言除了能表达各种各样的数据外，还必须提供一种手段来表达数据处理的过程，即<code>程序的控制过程</code>。程序的控制过程通过程序中的一系列语句来实现。</p><p>按照结构化程序设计的观点，任何程序都可以将程序模块通过三种基本的控制结构进行组合来实现。这三种基本的控制结构是<code>顺序</code>、<code>分支</code>、<code>循环</code>。</p><p><strong>《数据结构实现基础》 原文链接：<a href="https://blog.maplemark.cn/2019/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80.html">https://blog.maplemark.cn/2019/07/数据结构实现基础.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线性结构</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p>在数据的逻辑结构中，有种常见而且简单的结构是<code>线性结构</code>，即数据元素之间构成一个<code>有序</code>的序列。</p><h2 id="线性表的定义与实现"><a href="#线性表的定义与实现" class="headerlink" title="线性表的定义与实现"></a>线性表的定义与实现</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><p>线性表(Linear List)是由同一类型的数据元素构成的有序序列的线性结构。线性表中的元素的个数称为线性表的长度；当线性表中没有元素时，称为空表；表的起始位置称为表头；表的结束位置称为表尾。</p><p>类型名称：线性表(List)</p><p>操作集：</p><ul><li>1.MakeEmpty：初始化新的空线性表</li><li>2.FindKth：根据指定的位序，返回相应元素</li><li>3.Find：查找特定元素</li><li>4.Insert：指定位序，插入元素</li><li>5.Delete：删除指定位序的元素</li><li>6.Length：返回线性表的长度</li></ul><h3 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h3><p>线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表的各元素。考虑到线性表的运算有插入、删除等，即表的长度是动态可变的，因此，数组的容量需要设计得足够大。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//DSA-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F.png" alt="线性表的顺序存储"></p><blockquote><p>MAXSIZE：根据实际问题定义的足够大的整数</p></blockquote><blockquote><p>Last：记录当前线性表中最后一个元素在数组中的位置</p></blockquote><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>顺序表的初始化即构造一个空表。首先动态分配表结构所需要的存储空间，然后将表中的指针置为空，表示表中没有数据元素。</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>顺序存储的线性表中，查找主要是指在线性表中查找给定值相同的数据元素。由于线性表的元素都存储在数组中，所以这个查找过程实际上就是在数组的顺序查找。查找的平均时间复杂度为O(n)。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>顺序表的插入是指在表的第 i 个位序上插入一个值为 X 的新元素。首先将位序之后的元素向后移动，为新元素让出位置；将新元素置入；修改表长度。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>顺序表的删除是指将表中指定位序的元素从线性表中去掉，删除后并改变表长度。将指定位序的元素删除，并将位序之后的元素向前移动；修改表长度。</p><blockquote><p>由于顺序表的存储特点是用物理上的相邻实现了逻辑上的相邻，它要求用连续的存储单元顺序存储线性表中的各元素，因此，对顺序表插入、删除时需要通过移动数据元素来实现，运行效率影响较大。</p></blockquote><h3 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a>线性表的链式存储实现</h3><p>使用链表结构可以克服数组表示线性表的缺陷。下图为单向链表的图示表示形式，它有 n 个数据单元，每个数据单元由数据域和链接域两部分组成。数据域用来存放数值，链接域是线性表数据单元的结构指针。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//DSA-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="线性表的链表表示"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结点的结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$next</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $p1 结点数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $p2 下一个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$p1</span>, <span class="variable">$p2</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;data = <span class="variable">$p1</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;next = <span class="variable">$p2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><p>从链表的第一个元素起，从头到尾遍历一遍。</p><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>线性表的查找有两种：按序号查找、按值查找</p><ul><li>按序号查找</li></ul><p>从链表的第一个元素起，判断结点序号是否相同，相同则返回结点值，不同则继续，没有则返回错误信息。</p><ul><li>按值查找</li></ul><p>从头到尾遍历，知道找到为止；从链表的第一个元素结点起，判断当前结点的值是否相等；若是，则返回结点位置，否则继续，知道表结束为止；找不到则返回错误信息。</p><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>线性表的插入是在指定位序前插入一个新元素。在插入位序为1是，代表插入到链表的头；当位序为表尾时，代表插入到链表最后。新增节点，节点值为新元素值，节点指向指针地址根据位序赋予，链表保持。</p><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>单向链表中删除指定位序元素，首先需要找到被删除结点的前一个元素，然后再删除结点并释放空间。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p><code>堆栈</code>(Stack)是具有一定约束的线性表，插入和删除操作都作用在一个称为栈顶(Top)的端点位置。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//DSA-stack.png" alt="堆栈"></p><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>表达式求值是程序设计语言编译中的一个基本问题，即编译程序要将源程序中描述的表达式转换为正确的机器指令序列或直接求出常量表达式的值。要实现表达式求值，首先需要理解一个表达式，主要是运算的先后顺序。</p><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>类型名称：堆栈(Stack)<br>数据对象集：一个有0个或多个元素的有穷线性表<br>操作集：</p><ul><li>1.CreateStack：生成空堆栈</li><li>2.IsFull：判断堆栈是否已满</li><li>3.Push：将元素压入堆栈</li><li>4.IsEmpty：判断堆栈是否为空</li><li>5.Pop：删除并返回栈顶元素</li></ul><h3 id="堆栈的实现"><a href="#堆栈的实现" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h3><p>由于栈是线性表，因而栈的存储结构可采用顺序和链式两种形式。顺序存储的栈称为顺序栈，链式存储的栈称为链栈。</p><h4 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h4><p>栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成，另外我们还可以用一个变量来存储堆栈的最大容量，这样方便判断什么时候堆栈是满的。</p><h4 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h4><p>栈的链式存储结构(链栈)与单链表类似，但其操作受限制，插入和删除操作只能在链栈的栈顶进行。栈顶指针就是链表的头指针。</p><h3 id="堆栈应用：表达式求值"><a href="#堆栈应用：表达式求值" class="headerlink" title="堆栈应用：表达式求值"></a>堆栈应用：表达式求值</h3><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><code>队列</code>(Queue)是一个有序线性表，队列的插入和删除操作分别在线性表的两个不同端点进行的。先进先出特点。</p><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><p>类型名称：队列(Queue)<br>数据对象集：一个有0个或多个元素的又穷线性表<br>操作集：</p><ul><li>1.CreateQueue：生成空队列</li><li>2.IsFull：判断队列是否已满</li><li>3.AddQ：将新元素压入队列</li><li>4.IsEmpty：判断队列是否为空</li><li>5.DeleteQ：删除并返回队列头元素</li></ul><h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><h4 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h4><p>队列最简单的表示方法是用数组。用数组存储队列有许多种具体的方法。一般可以选择将队列头放数组下标小的位置，而将队列尾放在数组下标大的位置，并用两个变量分别指示队列的头和尾。</p><h4 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h4><p>队列与堆栈一样，也可以采用链式存储结构，但队列的头必须指向链表的头结点，队列的尾指向链表的尾结点</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-树</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04.%E6%A0%91/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04.%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>在计算机科学中，<code>树</code>(Tree)是一种抽象数据类型(ADT)或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。树是一种十分重要的<code>非线性数据结构</code>。</p><h2 id="树的定义、表示和术语"><a href="#树的定义、表示和术语" class="headerlink" title="树的定义、表示和术语"></a>树的定义、表示和术语</h2><p>树是 n(n≥0)个结点构成的有限集合。当 n=0 时，称为空树。对于任意非空树(n&gt;0)，具备如下特点。</p><ul><li>每个节点都只有有限个子节点或无子节点</li><li>没有父节点的节点称为根节点</li><li>每一个非根节点有且只有一个父节点</li><li>除了根节点外，每个子节点可以分为多个不相交的子树</li><li>树里面没有环路(cycle)</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p>在计算机科学中，<code>二叉树</code>(Binary tree)是每个节点最多只有两个分支的树结构。通常分支被称作”左子树”或”右子树”。二叉树的分支具有左右次序，不能随意颠倒。</p><p><img src="" alt="二叉树五种基本形态"></p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h3 id="二叉树的操作"><a href="#二叉树的操作" class="headerlink" title="二叉树的操作"></a>二叉树的操作</h3><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="二叉搜索树的定义"><a href="#二叉搜索树的定义" class="headerlink" title="二叉搜索树的定义"></a>二叉搜索树的定义</h3><h3 id="二叉搜索树的动态查找"><a href="#二叉搜索树的动态查找" class="headerlink" title="二叉搜索树的动态查找"></a>二叉搜索树的动态查找</h3><h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h3><h2 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h2><h3 id="堆及其操作"><a href="#堆及其操作" class="headerlink" title="堆及其操作"></a>堆及其操作</h3><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-散列查找</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-图</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/06.%E5%9B%BE/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/06.%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-排序</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E6%8E%92%E5%BA%8F/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-算法补充</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP 数组</title>
      <link href="/interview/docs/03.PHP/01.PHP%E6%95%B0%E7%BB%84/"/>
      <url>/interview/docs/03.PHP/01.PHP%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-数组"><a href="#PHP-数组" class="headerlink" title="PHP 数组"></a>PHP 数组</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这些函数允许你通过不同的方式来使用和操作数组。数组是存储、管理和操作变量组的必不可少的工具。</p><p>PHP 支持简单数组和多维数组，数组可由用户自己创建也可以由其它函数创建。有很多特殊的数据库处理函数可以从数据库查询中返回数组以及一些返回数组的函数。</p><h2 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h2><p>下列常量作为 PHP 核心的一部分总是可用的。</p><p>CASE_LOWER (integer)</p><blockquote><p>CASE_LOWER 用在 array_change_key_case() 中将数组的键名转换成小写字母。这也是 array_change_key_case() 的默认值。</p></blockquote><p>CASE_UPPER (integer)</p><blockquote><p>CASE_UPPER 用在 array_change_key_case() 中将数组的键名转换成大写字母。<br>排序顺序标识：</p></blockquote><p>SORT_ASC (integer)</p><blockquote><p>SORT_ASC 用在 array_multisort() 函数中，使其升序排列。</p></blockquote><p>SORT_DESC (integer)</p><blockquote><p>SORT_DESC 用在 array_multisort() 函数中，使其降序排列。</p></blockquote><ul><li>排序类型标识：用于各种排序函数</li></ul><p>SORT_REGULAR (integer)</p><blockquote><p>SORT_REGULAR 用于对对象进行通常比较。</p></blockquote><p>SORT_NUMERIC (integer)</p><blockquote><p>SORT_NUMERIC 用于对对象进行数值比较。</p></blockquote><p>SORT_STRING (integer)</p><blockquote><p>SORT_STRING 用于对对象进行字符串比较。</p></blockquote><p>SORT_LOCALE_STRING (integer)</p><blockquote><p>SORT_LOCALE_STRING 基于当前区域来对对象进行字符串比较。PHP 4.4.0 和 5.0.2 新加。</p></blockquote><p>COUNT_NORMAL (integer)</p><p>COUNT_RECURSIVE (integer)</p><p>EXTR_OVERWRITE (integer)</p><p>EXTR_SKIP (integer)</p><p>EXTR_PREFIX_SAME (integer)</p><p>EXTR_PREFIX_ALL (integer)</p><p>EXTR_PREFIX_INVALID (integer)</p><p>EXTR_PREFIX_IF_EXISTS (integer)</p><p>EXTR_IF_EXISTS (integer)</p><p>EXTR_REFS (integer)</p><h2 id="对数组进行排序"><a href="#对数组进行排序" class="headerlink" title="对数组进行排序"></a>对数组进行排序</h2><p>PHP 有一些用来排序数组的函数</p><p>主要区别有：</p><ul><li>有些函数基于 array 的键来排序， 而其他的基于值来排序的：$array[‘key’] = ‘value’;。</li><li>排序之后键和值之间的关联关系是否能够保持， 是指排序之后数组的键可能 会被重置为数字型的（0,1,2 …）。</li><li>排序的顺序有：字母表顺序， 由低到高（升序）， 由高到低（降序），数字排序，自然排序，随机顺序或者用户自定义排序。</li><li>注意：下列的所有排序函数都是直接作用于数组本身， 而不是返回一个新的有序的数组。</li><li>以下函数对于数组中相等的元素，它们在排序后的顺序是未定义的。 （也即相等元素之间的顺序是不稳定的）。</li></ul><table><thead><tr><th>函数名称</th><th>排序依据</th><th>数组索引健保持</th><th>排序的顺序</th><th>相关函数</th></tr></thead><tbody><tr><td>array_multisort()</td><td>值</td><td>键值关联的保持，数字类型的不保持</td><td>第一个数组或者由选项指定</td><td>array_walk()</td></tr><tr><td>asort()</td><td>值</td><td>是</td><td>由低到高</td><td>arsort()</td></tr><tr><td>arsort()</td><td>值</td><td>是</td><td>由高到低</td><td>asort()</td></tr><tr><td>krsort()</td><td>键</td><td>是</td><td>由高到低</td><td>ksort()</td></tr><tr><td>ksort()</td><td>键</td><td>是</td><td>由低到高</td><td>asort()</td></tr><tr><td>natcasesort()</td><td>值</td><td>是</td><td>自然排序，大小写不敏感</td><td>natsort()</td></tr><tr><td>natsort()</td><td>值</td><td>是</td><td>自然排序</td><td>natcasesort()</td></tr><tr><td>rsort()</td><td>值</td><td>否</td><td>由高到低</td><td>sort()</td></tr><tr><td>shuffle()</td><td>值</td><td>否</td><td>随机</td><td>array_rand()</td></tr><tr><td>sort()</td><td>值</td><td>否</td><td>由低到高</td><td>rsort()</td></tr><tr><td>uasort()</td><td>值</td><td>是</td><td>由用户定义</td><td>uksort()</td></tr><tr><td>uksort()</td><td>键</td><td>是</td><td>由用户定义</td><td>uasort()</td></tr><tr><td>usort()</td><td>值</td><td>否</td><td>由用户定义</td><td>uasort()</td></tr></tbody></table><h2 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h2><p>array_change_key_case — 将数组中的所有键名修改为全大写或小写</p><p>array_chunk — 将一个数组分割成多个</p><p>array_column — 返回数组中指定的一列</p><p>array_combine — 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值</p><p>array_count_values — 统计数组中所有的值</p><p>array_diff_assoc — 带索引检查计算数组的差集</p><p>array_diff_key — 使用键名比较计算数组的差集</p><p>array_diff_uassoc — 用用户提供的回调函数做索引检查来计算数组的差集</p><p>array_diff_ukey — 用回调函数对键名比较计算数组的差集</p><p>array_diff — 计算数组的差集</p><p>array_fill_keys — 使用指定的键和值填充数组</p><p>array_fill — 用给定的值填充数组</p><p>array_filter — 用回调函数过滤数组中的单元</p><p>array_flip — 交换数组中的键和值</p><p>array_intersect_assoc — 带索引检查计算数组的交集</p><p>array_intersect_key — 使用键名比较计算数组的交集</p><p>array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引</p><p>array_intersect_ukey — 用回调函数比较键名来计算数组的交集</p><p>array_intersect — 计算数组的交集</p><p>array_key_exists — 检查数组里是否有指定的键名或索引</p><p>array_key_first — Gets the first key of an array</p><p>array_key_last — Gets the last key of an array</p><p>array_keys — 返回数组中部分的或所有的键名</p><p>array_map — 为数组的每个元素应用回调函数</p><p>array_merge_recursive — 递归地合并一个或多个数组</p><p>array_merge — 合并一个或多个数组</p><p>array_multisort — 对多个数组或多维数组进行排序</p><p>array_pad — 以指定长度将一个值填充进数组</p><p>array_pop — 弹出数组最后一个单元（出栈）</p><p>array_product — 计算数组中所有值的乘积</p><p>array_push — 将一个或多个单元压入数组的末尾（入栈）</p><p>array_rand — 从数组中随机取出一个或多个单元</p><p>array_reduce — 用回调函数迭代地将数组简化为单一的值</p><p>array_replace_recursive — 使用传递的数组递归替换第一个数组的元素</p><p>array_replace — 使用传递的数组替换第一个数组的元素</p><p>array_reverse — 返回单元顺序相反的数组</p><p>array_search — 在数组中搜索给定的值，如果成功则返回首个相应的键名</p><p>array_shift — 将数组开头的单元移出数组</p><p>array_slice — 从数组中取出一段</p><p>array_splice — 去掉数组中的某一部分并用其它值取代</p><p>array_sum — 对数组中所有值求和</p><p>array_udiff_assoc — 带索引检查计算数组的差集，用回调函数比较数据</p><p>array_udiff_uassoc — 带索引检查计算数组的差集，用回调函数比较数据和索引</p><p>array_udiff — 用回调函数比较数据来计算数组的差集</p><p>array_uintersect_assoc — 带索引检查计算数组的交集，用回调函数比较数据</p><p>array_uintersect_uassoc — 带索引检查计算数组的交集，用单独的回调函数比较数据和索引</p><p>array_uintersect — 计算数组的交集，用回调函数比较数据</p><p>array_unique — 移除数组中重复的值</p><p>array_unshift — 在数组开头插入一个或多个单元</p><p>array_values — 返回数组中所有的值</p><p>array_walk_recursive — 对数组中的每个成员递归地应用用户函数</p><p>array_walk — 使用用户自定义函数对数组中的每个元素做回调处理</p><p>array — 新建一个数组</p><p>arsort — 对数组进行逆向排序并保持索引关系</p><p>asort — 对数组进行排序并保持索引关系</p><p>compact — 建立一个数组，包括变量名和它们的值</p><p>count — 计算数组中的单元数目，或对象中的属性个数</p><p>current — 返回数组中的当前单元</p><p>each — 返回数组中当前的键／值对并将数组指针向前移动一步</p><p>end — 将数组的内部指针指向最后一个单元</p><p>extract — 从数组中将变量导入到当前的符号表</p><p>in_array — 检查数组中是否存在某个值</p><p>key_exists — 别名 array_key_exists</p><p>key — 从关联数组中取得键名</p><p>krsort — 对数组按照键名逆向排序</p><p>ksort — 对数组按照键名排序</p><p>list — 把数组中的值赋给一组变量</p><p>natcasesort — 用“自然排序”算法对数组进行不区分大小写字母的排序</p><p>natsort — 用“自然排序”算法对数组排序</p><p>next — 将数组中的内部指针向前移动一位</p><p>pos — current 的别名</p><p>prev — 将数组的内部指针倒回一位</p><p>range — 根据范围创建数组，包含指定的元素</p><p>reset — 将数组的内部指针指向第一个单元</p><p>rsort — 对数组逆向排序</p><p>shuffle — 打乱数组</p><p>sizeof — count 的别名</p><p>sort — 对数组排序</p><p>uasort — 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联</p><p>uksort — 使用用户自定义的比较函数对数组中的键名进行排序</p><p>usort — 使用用户自定义的比较函数对数组中的值进行排序</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>echo、print、print_r、var_dump 区别</title>
      <link href="/interview/docs/03.PHP/03.echo%E3%80%81print%E3%80%81print_r%E3%80%81var_dump%E5%8C%BA%E5%88%AB/"/>
      <url>/interview/docs/03.PHP/03.echo%E3%80%81print%E3%80%81print_r%E3%80%81var_dump%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="echo、print、print-r、var-dump-区别"><a href="#echo、print、print-r、var-dump-区别" class="headerlink" title="echo、print、print_r、var_dump 区别"></a>echo、print、print_r、var_dump 区别</h1><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><ul><li>输出单个或多个字符，多个使用逗号分隔</li><li>无返回值</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;String 1&quot;</span>, <span class="string">&quot;String 2&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><ul><li>只可以输出单个字符</li><li>返回<code>1</code>，因此可用于表达式</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$expr</span> &amp;&amp; <span class="keyword">print</span> <span class="string">&quot;foo&quot;</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="print-r"><a href="#print-r" class="headerlink" title="print_r"></a>print_r</h2><ul><li>输出关于变量的易于理解的信息</li><li>支持多种数据类型，包括字符、数组、对象，格式化成易读格式</li><li>在调试时非常有用</li><li>若设置第二个参数，可将输出值返回(而不直接输出)</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$b</span> = [</span><br><span class="line"><span class="string">&#x27;m&#x27;</span> =&gt; <span class="string">&#x27;monkey&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> =&gt; <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;x&#x27;</span> =&gt; [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">];</span><br><span class="line"><span class="variable">$results</span> = <span class="title function_ invoke__">print_r</span>(<span class="variable">$b</span>, <span class="literal">true</span>); <span class="comment">//$results 包含了 print_r 的输出</span></span><br></pre></td></tr></table></figure><h2 id="var-dump"><a href="#var-dump" class="headerlink" title="var_dump"></a>var_dump</h2><ul><li>输出关于变量的易于理解的信息，多个可用分号分隔</li><li>支持多种数据类型，包括字符、数组、对象，格式化成易读格式</li><li>输出格式与<code>print_r</code>不同，<code>var_dump</code>的输出包含<code>数据类型</code></li><li>在调试时非常有用</li><li>无返回值</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>即使<code>print</code>可用于表达式，但这种用法，常常不利于代码可读性，与其他操作符混用容易让人误解</li><li><code>echo</code>和<code>print</code>都是语言结构，<code>print_r</code>和<code>var_dump</code>是普通函数。<code>echo</code>或<code>print</code>使用时，不需要使用括号将变量括起来</li></ul><p><strong>《echo、print、print_r、var_dump区别》 原文链接：<a href="https://blog.maplemark.cn/2019/04/echo-print-print_r-var_dump%E5%8C%BA%E5%88%AB.html">https://blog.maplemark.cn/2019/04/echo-print-print_r-var_dump区别.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP 反射详解</title>
      <link href="/interview/docs/03.PHP/02.PHP%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/interview/docs/03.PHP/02.PHP%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-反射详解"><a href="#PHP-反射详解" class="headerlink" title="PHP 反射详解"></a>PHP 反射详解</h1><p>面向对象编程中对象被赋予了自省的能力，而这个自省的过程就是反射。<br>反射，直观理解就是根据到达地找到出发地和来源。比如，一个光秃秃的对象，我们可以仅仅通过这个对象就能知道它所属的类、拥有哪些方法。<br>反射是指在PHP运行状态中，扩展分析PHP程序，导出或提出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取信息以及动态调用对象方法的功能称为反射API。<br>如何使用反射API</p><h2 id="如何使用反射-API"><a href="#如何使用反射-API" class="headerlink" title="如何使用反射 API"></a>如何使用反射 API</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$gender</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;name,<span class="string">&quot; \tis &quot;</span>,<span class="variable language_">$this</span>-&gt;gender,<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Setting <span class="subst">$name</span> to <span class="subst">$value</span> \r\n&quot;</span>;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="variable">$name</span>= <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;<span class="variable">$name</span>))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;未设置&#x27;</span>;　</span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="variable">$name</span>=<span class="string">&quot;正在为你设置默认值&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="variable">$name</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$student</span> = <span class="keyword">new</span> <span class="title function_ invoke__">person</span>();</span><br><span class="line"><span class="variable">$student</span>-&gt;name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="variable">$student</span>-&gt;gender = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line"><span class="variable">$student</span>-&gt;age = <span class="number">24</span>;</span><br></pre></td></tr></table></figure><p>现在，要获取这个student对象的方法和属性列表该怎么做呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象属性列表</span></span><br><span class="line"><span class="variable">$reflect</span> = <span class="keyword">new</span> <span class="title class_">ReflectionObject</span>(<span class="variable">$student</span>);</span><br><span class="line"><span class="variable">$props</span>　= <span class="variable">$reflect</span>-&gt;<span class="title function_ invoke__">getProperties</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$props</span> <span class="keyword">as</span> <span class="variable">$prop</span>) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$prop</span>-&gt;<span class="title function_ invoke__">getName</span>() .<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取对象方法列表</span></span><br><span class="line"><span class="variable">$m</span> = <span class="variable">$reflect</span>-&gt;<span class="title function_ invoke__">getMethods</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$m</span> <span class="keyword">as</span> <span class="variable">$prop</span>) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$prop</span>-&gt;<span class="title function_ invoke__">getName</span>() .<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以不用反射API，使用class函数，返回对象属性的关联数组以及更多的信息：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回对象属性的关联数组</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">get_object_vars</span>(<span class="variable">$student</span>));</span><br><span class="line"><span class="comment">// 类属性</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">get_class_vars</span>(<span class="title function_ invoke__">get_class</span>(<span class="variable">$student</span>)));</span><br><span class="line"><span class="comment">// 返回由类的方法名组成的数组</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">get_class_methods</span>(<span class="title function_ invoke__">get_class</span>(<span class="variable">$student</span>)));</span><br></pre></td></tr></table></figure><p>假如这个对象是从其他页面传过来的，怎么知道它属于哪个类呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象属性列表所属的类</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">get_class</span>(<span class="variable">$student</span>);</span><br></pre></td></tr></table></figure><p>反射API的功能显然更强大，甚至能还原这个类的原型，包括方法的访问权限等</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射获取类的原型</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">ReflectionClass</span>(<span class="string">&#x27;person&#x27;</span>);</span><br><span class="line"><span class="variable">$className</span> = <span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">getName</span>();</span><br><span class="line"><span class="variable">$Methods</span> = <span class="variable">$Properties</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">getProperties</span>() <span class="keyword">as</span> <span class="variable">$v</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$Properties</span>[<span class="variable">$v</span>-&gt;<span class="title function_ invoke__">getName</span>()] = <span class="variable">$v</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">getMethods</span>() <span class="keyword">as</span> <span class="variable">$v</span>)　　</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$Methods</span>[<span class="variable">$v</span>-&gt;<span class="title function_ invoke__">getName</span>()] = <span class="variable">$v</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;class <span class="subst">&#123;$className&#125;</span>\n&#123;\n&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">is_array</span>(<span class="variable">$Properties</span>) &amp;&amp; <span class="title function_ invoke__">ksort</span>(<span class="variable">$Properties</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$Properties</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$v</span>-&gt;<span class="title function_ invoke__">isPublic</span>() ? <span class="string">&#x27; public&#x27;</span> : <span class="string">&#x27;&#x27;</span>,<span class="variable">$v</span>-&gt;<span class="title function_ invoke__">isPrivate</span>() ? <span class="string">&#x27; private&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="variable">$v</span>-&gt;<span class="title function_ invoke__">isProtected</span>() ? <span class="string">&#x27; protected&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="variable">$v</span>-&gt;<span class="title function_ invoke__">isStatic</span>() ? <span class="string">&#x27; static&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t<span class="subst">&#123;$k&#125;</span>\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_array</span>(<span class="variable">$Methods</span>)) <span class="title function_ invoke__">ksort</span>(<span class="variable">$Methods</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$Methods</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\tfunction <span class="subst">&#123;$k&#125;</span>()&#123;&#125;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&#125;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> gender</span><br><span class="line"><span class="keyword">public</span> name</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅如此，PHP手册中关于反射API更是有几十个，可以说，反射完整地描述了一个类或者对象的原型。反射不仅可以用于类和对象，还可以用于函数、扩展模块、异常等</p><h2 id="反射有什么作用"><a href="#反射有什么作用" class="headerlink" title="反射有什么作用"></a>反射有什么作用</h2><p>反射可以用于文档生成。因此可以用它对文件里的类进行扫描，逐个生成描述文档。<br>既然反射可以探知类的内部结构，那么是不是可以用它做hook实现插件功能呢？或者是做动态代理呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mysql</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"><span class="variable">$db</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;连接到数据库$&#123;db[0]&#125;\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sqlproxy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$target</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">construct</span>(<span class="params"><span class="variable">$tar</span></span>) </span>&#123; </span><br><span class="line"><span class="variable language_">$this</span>-&gt;target[] = <span class="keyword">new</span> <span class="variable">$tar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;target <span class="keyword">as</span> <span class="variable">$obj</span>) &#123;</span><br><span class="line"><span class="variable">$r</span> = <span class="keyword">new</span> <span class="title class_">ReflectionClass</span>(<span class="variable">$obj</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$method</span> = <span class="variable">$r</span>-&gt;<span class="title function_ invoke__">getMethod</span>(<span class="variable">$name</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$method</span>-&gt;<span class="title function_ invoke__">isPublic</span>() &amp;&amp; !<span class="variable">$method</span>-&gt;<span class="title function_ invoke__">isAbstract</span>()) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;方法前拦截记录LOG\r\n&quot;</span>;</span><br><span class="line"><span class="variable">$method</span>-&gt;<span class="title function_ invoke__">invoke</span>(<span class="variable">$obj</span>, <span class="variable">$args</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;方法后拦截\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title function_ invoke__">sqlproxy</span>(<span class="string">&#x27;mysql&#x27;</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;<span class="title function_ invoke__">connect</span>(<span class="string">&#x27;member&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在平常开发中，用到反射的地方不多：一个是对对象进行调试，另一个是获取类的信息。在MVC和插件开发中，使用反射很常见，但是反射的消耗也很大，在可以找到替代方案的情况下，就不要滥用。</p><p>PHP有Token函数，可以通过这个机制实现一些反射功能。从简单灵活的角度讲，使用已经提供的反射API是可取的。</p><p>很多时候，善用反射能保持代码的优雅和简洁，但反射也会破坏类的封装性，因为反射可以使本不应该暴露的方法或属性被强制暴露了出来，这既是优点也是缺点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器的分类</title>
      <link href="/interview/docs/04.Web/02.CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/interview/docs/04.Web/02.CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-选择器的分类"><a href="#CSS-选择器的分类" class="headerlink" title="CSS 选择器的分类"></a>CSS 选择器的分类</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><blockquote><p>通过 CSS 可以向文档中的一组元素类型应用某些规则</p></blockquote><blockquote><p>利用 CSS，可以创建易于修改和编辑的规则，且能很容易地将其应用到定义的所有文本元素</p></blockquote><h3 id="规则结构"><a href="#规则结构" class="headerlink" title="规则结构"></a>规则结构</h3><blockquote><p>每个规则都有两个基本部分：选择器和声明块；声明块由一个或多个声明组成；每个声明则是一个属性-值对</p></blockquote><blockquote><p>每个样式表由一系列规则组成</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//css-%E8%A7%84%E5%88%99%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="规则的结构"></p><blockquote><p>如规则左边所示，选择器定义了将影响文档中的哪些部分</p></blockquote><blockquote><p>规则右边包含声明块，它由一个或多个声明组成。每个声明是一个 CSS 属性和该属性的值的组合</p></blockquote><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><blockquote><p>最常见的选择器往往是 HTML 元素。文档的元素就是最基本的选择器</p></blockquote><h3 id="声明和关键字"><a href="#声明和关键字" class="headerlink" title="声明和关键字"></a>声明和关键字</h3><blockquote><p>声明块包含一个或多个声明。声明总有如下格式：一个属性后面跟一个冒号，再后面是一个值，然后是一个分号。冒号和分号后面可以有0个或多个空格</p></blockquote><blockquote><p>如果一个属性的值可以取多个关键字，在这种情况下，关键字通常由空格分隔。并不是所偶属性都能接受多个关键字，不过确实有许多属性是这样</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font</span>: medium Helvetica;&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h3><blockquote><p>CSS2引入了一种新的简单选择器，称为通配选择器（universal selector），显示为一个星号（*）。这个选择器可以与任何元素匹配，就像是一个通配符</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><blockquote><p>要应用样式而不考虑具体涉及的元素，最常用的方法就是使用类选择器。在使用类选择器之前，需要修改具体的文档标记，以便选择器正常工作</p></blockquote><blockquote><p>为了将一个类选择器的样式与元素关联，必须将 class 属性指定为一个适当的值</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-class">.warning</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.warning</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br><span class="line"><span class="selector-class">.warning</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br></pre></td></tr></table></figure><h4 id="多类选择器"><a href="#多类选择器" class="headerlink" title="多类选择器"></a>多类选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warning</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br><span class="line"><span class="selector-class">.urgent</span> &#123;<span class="attribute">font-style</span>: italic;&#125;</span><br><span class="line"><span class="selector-class">.warning</span><span class="selector-class">.urgent</span> &#123;<span class="attribute">background</span>: silver;&#125;</span><br></pre></td></tr></table></figure><h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><blockquote><p>ID 选择器前面有一个 # 号</p></blockquote><blockquote><p>ID 选择器不引用 class 属性的值</p></blockquote><blockquote><p>在一个 HTML 文档中，ID 选择器会使用一次，且仅一次</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-id">#first-para</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br><span class="line"><span class="selector-id">#first-para</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><blockquote><p>在某些标记语言中，不能使用类和 ID 选择器。为了解决这个问题，CSS2引入了属性选择器（attribute selector），它可以根据元素的属性及属性值来选择元素</p></blockquote><h4 id="简单属性选择"><a href="#简单属性选择" class="headerlink" title="简单属性选择"></a>简单属性选择</h4><blockquote><p>如果希望选择某个属性的元素，而不讨论该属性的值是什么，可以使用一个简单属性选择器</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;hoopla&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;severe&quot;</span>&gt;</span>Serenity<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;fancy&quot;</span>&gt;</span>Fooling<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-attr">[class]</span> &#123;<span class="attribute">color</span>: silver;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[alt]</span> &#123;<span class="attribute">border</span>: <span class="number">3px</span> solid red;&#125; <span class="comment">/*对所有带有 alt 属性的图像应用样式*/</span></span><br><span class="line">*<span class="selector-attr">[title]</span> &#123;<span class="attribute">font-weight</span>: bold;&#125; <span class="comment">/*包含标题(title)信息的所有元素变为粗体显示*/</span></span><br></pre></td></tr></table></figure><h4 id="根据具体属性值选择"><a href="#根据具体属性值选择" class="headerlink" title="根据具体属性值选择"></a>根据具体属性值选择</h4><blockquote><p>除了选择有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将指向 Web 服务器上某个特定超链接变成粗体*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://blog.maplemark.cn&quot;</span>]</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">planet</span>&gt;</span>Venus<span class="tag">&lt;/<span class="name">planet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">planet</span> <span class="attr">moons</span>=<span class="string">&quot;1&quot;</span>&gt;</span>Earth<span class="tag">&lt;/<span class="name">planet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">planet</span> <span class="attr">moons</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Mars<span class="tag">&lt;/<span class="name">planet</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将第二个元素文本变成粗体*/</span></span><br><span class="line">planet<span class="selector-attr">[moons=<span class="string">&quot;1&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据部分属性值选择"><a href="#根据部分属性值选择" class="headerlink" title="根据部分属性值选择"></a>根据部分属性值选择</h4><blockquote><p>如果属性能接受词列表（词之间用空格分隔），可以根据其中的任意一个词进行选择</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[title~=<span class="string">&quot;Figure&quot;</span>]</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> solid gray;&#125;</span><br></pre></td></tr></table></figure><ul><li>子串匹配属性选择器</li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>[foo^=”bar”]</td><td>选择 foo 属性值以”bar”开头的所有元素</td></tr><tr><td>[foo$=”bar”]</td><td>选择 foo 属性值以”bar”结尾的所有元素</td></tr><tr><td>[foo*=”bar”]</td><td>选择 foo 属性值中包含子串”bar”的所有元素</td></tr></tbody></table><h4 id="特定属性选择类型"><a href="#特定属性选择类型" class="headerlink" title="特定属性选择类型"></a>特定属性选择类型</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;en-us&quot;</span>&gt;</span>Greetings!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">lang</span>=<span class="string">&quot;en-au&quot;</span>&gt;</span>G&#x27;day!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>Bonjour!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">lang</span>=<span class="string">&quot;cy-en&quot;</span>&gt;</span>Jrooana!<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[lang|=<span class="string">&quot;en&quot;</span>]</span> &#123;<span class="attribute">color</span>: white;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种属性选择器最常见的用途是匹配语言值</p></blockquote><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//css-%E6%96%87%E6%A1%A3%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="文档树结构"></p><blockquote><p>通过文档树结构，可以很形象的理解什么是后代选择器（descendant selector），也称为包含选择器/上下文选择器。定义后代选择器就是来创建一些规则，它们仅在某些结构中起作用，而在另外一些结构中不起作用</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>文字一<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>文字一后代<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span>文字二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文字三<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h4 id="选择子元素"><a href="#选择子元素" class="headerlink" title="选择子元素"></a>选择子元素</h4><blockquote><p>在某些情况下，可能并不想选择一个任意的后代元素；而是希望缩小范围，只选择另一个元素的子元素</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row</span> &gt; <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h4 id="选择相邻兄弟元素"><a href="#选择相邻兄弟元素" class="headerlink" title="选择相邻兄弟元素"></a>选择相邻兄弟元素</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>A list item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Another list item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Yet Another list item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Lat list item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span> + <span class="selector-tag">ul</span> &#123;<span class="attribute">font-weight</span>: bold;&#125; <span class="comment">/*将命中 ul*/</span></span><br></pre></td></tr></table></figure><blockquote><p>ul 必须紧跟在 ol 后面</p></blockquote><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><blockquote><p>锚类型称为伪类</p></blockquote><h4 id="链接伪类"><a href="#链接伪类" class="headerlink" title="链接伪类"></a>链接伪类</h4><p>CSS2.1定义了两个只应用于超链接的伪类</p><table><thead><tr><th>伪类名</th><th>描述</th></tr></thead><tbody><tr><td>:link</td><td>指示作为超链接并指向一个未访问地址的所有锚</td></tr><tr><td>:visited</td><td>指示作为已访问超链接的所有锚</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: black;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: bule;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h4 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h4><blockquote><p>CSS2.1定义了3个动态伪类，它们可以根据用户行为改变文档的外观</p></blockquote><table><thead><tr><th>伪类名</th><th>描述</th></tr></thead><tbody><tr><td>:focus</td><td>指示当前拥有输入焦点的元素</td></tr><tr><td>:hover</td><td>指示鼠标指针停留在哪个元素上</td></tr><tr><td>:active</td><td>指示被用户输入激活的元素</td></tr></tbody></table><blockquote><p>伪类顺序：link-visited-focus-hover-active</p></blockquote><h4 id="选择第一个子元素"><a href="#选择第一个子元素" class="headerlink" title="选择第一个子元素"></a>选择第一个子元素</h4><blockquote><p>可以使用静态伪类:first-child 来选择元素的第一个子元素</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br></pre></td></tr></table></figure><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><blockquote><p>就像伪类为锚指定幻像类一样，伪元素能够在文档中插入假象的元素，从而得到某种效果。CSS2.1中定义了4个伪元素：设置首字母样式、设置第一行样式、设置之前和之后元素的样式</p></blockquote><h4 id="设置首字母样式"><a href="#设置首字母样式" class="headerlink" title="设置首字母样式"></a>设置首字母样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-letter &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><h4 id="设置第一行样式"><a href="#设置第一行样式" class="headerlink" title="设置第一行样式"></a>设置第一行样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-line &#123;<span class="attribute">color</span>: purple;&#125;</span><br></pre></td></tr></table></figure><h4 id="first-letter-和-first-line-的限制"><a href="#first-letter-和-first-line-的限制" class="headerlink" title=":first-letter 和 :first-line 的限制"></a>:first-letter 和 :first-line 的限制</h4><blockquote><p>在 CSS2 中，:first-letter 和:first-line 伪元素只能应用于标记或段落之类的块级元素，而不能应用于超链接等的行内元素</p></blockquote><h4 id="设置之前和之后元素的样式"><a href="#设置之前和之后元素的样式" class="headerlink" title="设置之前和之后元素的样式"></a>设置之前和之后元素的样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">color</span>: black;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:after</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><p><strong>《CSS选择器的分类》原文链接：<a href="https://blog.maplemark.cn/2019/04/css%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB.html">https://blog.maplemark.cn/2019/04/css选择器的分类.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP QA</title>
      <link href="/interview/docs/03.PHP/QA/"/>
      <url>/interview/docs/03.PHP/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="PHP-篇"><a href="#PHP-篇" class="headerlink" title="PHP 篇"></a>PHP 篇</h2><h3 id="echo、print、print-r、var-dump-区别"><a href="#echo、print、print-r、var-dump-区别" class="headerlink" title="echo、print、print_r、var_dump 区别"></a>echo、print、print_r、var_dump 区别</h3><blockquote><p><code>echo</code>和<code>print</code>是语言结构、<code>print_r</code>和<code>var_dump</code>是普通函数</p></blockquote><ul><li><p>echo：输出一个或多个字符串</p></li><li><p>print：输出字符串</p></li><li><p>print_r：打印关于变量的易于理解的信息</p></li><li><p>var_dump：打印关于变量的易于理解的信息(带类型)</p></li></ul><p>拓展阅读 <a href="./03.echo%E3%80%81print%E3%80%81print_r%E3%80%81var_dump%E5%8C%BA%E5%88%AB.md">《echo、print、print_r、var_dump区别》</a></p><h3 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h3><p>双引号可以被分析器解析，单引号则不行</p><h3 id="isset-和-empty-的区别"><a href="#isset-和-empty-的区别" class="headerlink" title="isset 和 empty 的区别"></a>isset 和 empty 的区别</h3><p>isset：检测变量是否已设置并且非 NULL</p><p>empty：判断变量是否为空，变量为 0/false 也会被认为是空；变量不存在，不会产生警告</p><h3 id="static、self、-this-的区别"><a href="#static、self、-this-的区别" class="headerlink" title="static、self、$this 的区别"></a>static、self、$this 的区别</h3><p>static：static 可以用于静态或非静态方法中，也可以访问类的静态属性、静态方法、常量和非静态方法，但不能访问非静态属性</p><p>self：可以用于访问类的静态属性、静态方法和常量，但 self 指向的是当前定义所在的类，这是 self 的限制</p><p>$this：指向的是实际调用时的对象，也就是说，实际运行过程中，谁调用了类的属性或方法，$this 指向的就是哪个对象。但 $this 不能访问类的静态属性和常量，且 $this 不能存在于静态方法中</p><h3 id="include、require、include-once、require-once-的区别"><a href="#include、require、include-once、require-once-的区别" class="headerlink" title="include、require、include_once、require_once 的区别"></a>include、require、include_once、require_once 的区别</h3><p>require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行</p><p>include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含。如同此语句名字暗示的那样，只会包含一次</p><h3 id="常见数组函数"><a href="#常见数组函数" class="headerlink" title="常见数组函数"></a>常见数组函数</h3><p>array_count_values — 统计数组中所有的值</p><p>array_flip — 交换数组中的键和值</p><p>array_merge — 合并一个或多个数组</p><p>array_multisort — 对多个数组或多维数组进行排序</p><p>array_pad — 以指定长度将一个值填充进数组</p><p>array_pop — 弹出数组最后一个单元(出栈)</p><p>array_push — 将一个或多个单元压入数组的末尾(入栈)</p><p>array_rand — 从数组中随机(伪随机)取出一个或多个单元</p><p>array_keys — 返回数组中部分的或所有的键名</p><p>array_values — 返回数组中所有的值</p><p>count — 计算数组中的单元数目，或对象中的属性个数</p><p>sort — 对数组排序</p><h3 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h3><p>Cookie：PHP 透明的支持 HTTP cookie 。cookie 是一种远程浏览器端存储数据并以此来跟踪和识别用户的机制</p><p>Session：会话机制(Session)在 PHP 中用于保持用户连续访问Web应用时的相关数据</p><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>对于全部脚本而言，PHP 提供了大量的预定义变量</p><p>超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$GLOBALS — 引用全局作用域中可用的全部变量</span><br><span class="line">$_SERVER — 服务器和执行环境信息</span><br><span class="line">$_GET — HTTP GET 变量</span><br><span class="line">$_POST — HTTP POST 变量</span><br><span class="line">$_FILES — HTTP 文件上传变量</span><br><span class="line">$_REQUEST — HTTP Request 变量</span><br><span class="line">$_SESSION — Session 变量</span><br><span class="line">$_ENV — 环境变量</span><br><span class="line">$_COOKIE — HTTP Cookies</span><br><span class="line">$php_errormsg — 前一个错误信息</span><br><span class="line">$HTTP_RAW_POST_DATA — 原生POST数据</span><br><span class="line">$http_response_header — HTTP 响应头</span><br><span class="line">$argc — 传递给脚本的参数数目</span><br><span class="line">$argv — 传递给脚本的参数数组</span><br></pre></td></tr></table></figure><ul><li>超全局变量</li></ul><p>PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们</p><p>超全局变量：$GLOBALS、$_SERVER、$_GET、$_POST、$_FILES、$_COOKIE、$_SESSION、$_REQUEST、$_ENV</p><h3 id="传值和传引用的区别"><a href="#传值和传引用的区别" class="headerlink" title="传值和传引用的区别"></a>传值和传引用的区别</h3><p>传值导致对象生成了一个拷贝，传引用则可以用两个变量指向同一个内容</p><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>构造函数：PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作</p><p>析构函数：PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行</p><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p>__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke() 等方法在 PHP 中被称为”魔术方法”（Magic methods）</p><h3 id="public、protected、private、final-区别"><a href="#public、protected、private、final-区别" class="headerlink" title="public、protected、private、final 区别"></a>public、protected、private、final 区别</h3><p>对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问</p><p>PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承</p><h3 id="客户端-服务端-IP-获取，了解代理透传-实际IP-的概念"><a href="#客户端-服务端-IP-获取，了解代理透传-实际IP-的概念" class="headerlink" title="客户端/服务端 IP 获取，了解代理透传 实际IP 的概念"></a>客户端/服务端 IP 获取，了解代理透传 实际IP 的概念</h3><p>客户端IP: $_SERVER[‘REMOTE_ADDR’]</p><p>服务端IP: $_SERVER[‘SERVER_ADDR’]</p><p>客户端IP(代理透传): $_SERVER[‘HTTP_X_FORWARDED_FOR’]</p><h3 id="类的静态调用和实例化调用"><a href="#类的静态调用和实例化调用" class="headerlink" title="类的静态调用和实例化调用"></a>类的静态调用和实例化调用</h3><ul><li>占用内存</li></ul><p>静态方法在内存中只有一份，无论调用多少次，都是共用的</p><p>实例化不一样，每一个实例化是一个对象，在内存中是多个的</p><ul><li>不同点</li></ul><p>静态调用不需要实例化即可调用</p><p>静态方法不能调用非静态属性，因为非静态属性需要实例化后，存放在对象里</p><p>静态方法可以调用非静态方法，使用 self 关键字。php 里，一个方法被 <code>self::</code> 后，自动转变为静态方法</p><p>调用类的静态函数时不会自动调用类的构造函数</p><h3 id="接口和抽象的区别"><a href="#接口和抽象的区别" class="headerlink" title="接口和抽象的区别"></a>接口和抽象的区别</h3><p>抽象用于描述不同的事物，接口用于描述事物的行为。</p><h3 id="PHP-不实例化调用方法"><a href="#PHP-不实例化调用方法" class="headerlink" title="PHP 不实例化调用方法"></a>PHP 不实例化调用方法</h3><p>静态调用、使用 PHP 反射方式</p><h3 id="php-ini-配置选项"><a href="#php-ini-配置选项" class="headerlink" title="php.ini 配置选项"></a>php.ini 配置选项</h3><ul><li>配置选项</li></ul><table><thead><tr><th>名字</th><th>默认</th><th>备注</th></tr></thead><tbody><tr><td>short_open_tag</td><td>“1”</td><td>是否开启缩写形式(<code>&lt;? ?&gt;</code>)</td></tr><tr><td>precision</td><td>“14”</td><td>浮点数中显示有效数字的位数</td></tr><tr><td>disable_functions</td><td>“”</td><td>禁止某些函数</td></tr><tr><td>disable_classes</td><td>“”</td><td>禁用某些类</td></tr><tr><td>expose_php</td><td>“”</td><td>是否暴露 PHP 被安装在服务器上</td></tr><tr><td>max_execution_time</td><td>30</td><td>最大执行时间</td></tr><tr><td>memory_limit</td><td>128M</td><td>每个脚本执行的内存限制</td></tr><tr><td>error_reporting</td><td>NULL</td><td>设置错误报告的级别 <code>E_ALL</code> &amp; ~`E_NOTICE<code> &amp; ~</code>E_STRICT<code> &amp; ~</code>E_DEPRECATED`</td></tr><tr><td>display_errors</td><td>“1”</td><td>显示错误</td></tr><tr><td>log_errors</td><td>“0”</td><td>设置是否将错误日志记录到 error_log 中</td></tr><tr><td>error_log</td><td>NULL</td><td>设置脚本错误将被记录到的文件</td></tr><tr><td>upload_max_filesize</td><td>“2M”</td><td>最大上传文件大小</td></tr><tr><td>post_max_size</td><td>“8M”</td><td>设置POST最大数据限制</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -ini | grep short_open_tag //查看 php.ini 配置</span><br></pre></td></tr></table></figure><ul><li>动态设置</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="keyword">string</span> <span class="variable">$varname</span> , <span class="keyword">string</span> <span class="variable">$newvalue</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;date.timezone&#x27;</span>, <span class="string">&#x27;Asia/Shanghai&#x27;</span>); <span class="comment">//设置时区</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;display_errors&#x27;</span>, <span class="string">&#x27;1&#x27;</span>); <span class="comment">//设置显示错误</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;memory_limit&#x27;</span>, <span class="string">&#x27;256M&#x27;</span>); <span class="comment">//设置最大内存限制</span></span><br></pre></td></tr></table></figure><h3 id="php-fpm-conf-配置"><a href="#php-fpm-conf-配置" class="headerlink" title="php-fpm.conf 配置"></a>php-fpm.conf 配置</h3><table><thead><tr><th>名称</th><th>默认</th><th>备注</th></tr></thead><tbody><tr><td>pid</td><td></td><td>PID文件的位置</td></tr><tr><td>error_log</td><td></td><td>错误日志的位置</td></tr><tr><td>log_level</td><td>notice</td><td>错误级别 alert:必须立即处理、error:错误情况、warning:警告情况、notice:一般重要信息、debug:调试信息</td></tr><tr><td>daemonize</td><td>yes</td><td>设置 FPM 在后台运行</td></tr><tr><td>listen</td><td>ip:port、port、/path/to/unix/socket</td><td>设置接受 FastCGI 请求的地址</td></tr><tr><td>pm</td><td>static、ondemand、dynamic</td><td>设置进程管理器如何管理子进程</td></tr><tr><td>request_slowlog_timeout</td><td>‘0’</td><td>慢日志记录阀值</td></tr><tr><td>slowlog</td><td></td><td>慢请求的记录日志</td></tr></tbody></table><h3 id="502、504-错误产生原因及解决方式"><a href="#502、504-错误产生原因及解决方式" class="headerlink" title="502、504 错误产生原因及解决方式"></a>502、504 错误产生原因及解决方式</h3><h4 id="502"><a href="#502" class="headerlink" title="502"></a>502</h4><p>502 表示网关错误，当 PHP-CGI 得到一个无效响应，网关就会输出这个错误</p><ul><li><code>php.ini</code> 的 memory_limit 过小</li><li><code>php-fpm.conf</code> 中 max_children、max_requests 设置不合理</li><li><code>php-fpm.conf</code> 中 request_terminate_timeout、max_execution_time 设置不合理</li><li>php-fpm 进程处理不过来，进程数不足、脚本存在性能问题</li></ul><h4 id="504"><a href="#504" class="headerlink" title="504"></a>504</h4><p>504 表示网关超时，PHP-CGI 没有在指定时间响应请求，网关将输出这个错误</p><ul><li>Nginx+PHP 架构，可以调整 FastCGI 超时时间，fastcgi_connect_timeout、fastcgi_send_timeout、fastcgi_read_timeout</li></ul><h4 id="500"><a href="#500" class="headerlink" title="500"></a>500</h4><p>php 代码问题，文件权限问题，资源问题</p><h4 id="503"><a href="#503" class="headerlink" title="503"></a>503</h4><p>超载或者停机维护</p><h3 id="如何返回一个301重定向"><a href="#如何返回一个301重定向" class="headerlink" title="如何返回一个301重定向"></a>如何返回一个301重定向</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;HTTP/1.1 301 Moved Permanently&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: https://blog.maplemark.cn&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="PHP-与-MySQL-连接方式"><a href="#PHP-与-MySQL-连接方式" class="headerlink" title="PHP 与 MySQL 连接方式"></a>PHP 与 MySQL 连接方式</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&#x27;127.0.0.1:3306&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$conn</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>() . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;SET NAMES &#x27;utf8&#x27;&quot;</span>);</span><br><span class="line"><span class="variable">$select_db</span> = <span class="title function_ invoke__">mysql_select_db</span>(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$select_db</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>() . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM `user` LIMIT 1&quot;</span>;</span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$res</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>() . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_assoc</span>(<span class="variable">$res</span>)) &#123;</span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="variable">$row</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysql_close</span>(<span class="variable">$conn</span>);</span><br></pre></td></tr></table></figure><h4 id="MySQLi"><a href="#MySQLi" class="headerlink" title="MySQLi"></a>MySQLi</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$conn</span> = @<span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="string">&#x27;127.0.0.1:3306&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$conn</span>-&gt;connect_errno) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="variable">$conn</span>-&gt;connect_error . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;set names &#x27;utf8&#x27;;&quot;</span>);</span><br><span class="line"><span class="variable">$select_db</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">select_db</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$select_db</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="variable">$conn</span>-&gt;error . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM `user` LIMIT 1&quot;</span>;</span><br><span class="line"><span class="variable">$res</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$res</span>) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="variable">$conn</span>-&gt;error . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$res</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="variable">$row</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$res</span>-&gt;<span class="title function_ invoke__">free</span>();</span><br><span class="line"><span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure><h4 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$pdo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PDO</span>(<span class="string">&#x27;mysql:host=127.0.0.1:3306;dbname=user&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">exec</span>(<span class="string">&quot;set names &#x27;utf8&#x27;&quot;</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM `user` LIMIT 1&quot;</span>;</span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bindValue</span>(<span class="number">1</span>, <span class="number">1</span>, PDO::<span class="variable constant_">PARAM_STR</span>);</span><br><span class="line"><span class="variable">$rs</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$rs</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>(PDO::<span class="variable constant_">FETCH_ASSOC</span>)) &#123;</span><br><span class="line">        <span class="title function_ invoke__">var_dump</span>(<span class="variable">$row</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$pdo</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="MySQL、MySQLi、PDO-区别"><a href="#MySQL、MySQLi、PDO-区别" class="headerlink" title="MySQL、MySQLi、PDO 区别"></a>MySQL、MySQLi、PDO 区别</h3><h4 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a>MySQL</h4><ul><li>允许 PHP 应用与 MySQL 数据库交互的早期扩展</li><li>提供了一个面向过程的接口，不支持后期的一些特性</li></ul><h4 id="MySQLi-1"><a href="#MySQLi-1" class="headerlink" title="MySQLi"></a>MySQLi</h4><ul><li>面向对象接口</li><li>prepared 语句支持</li><li>多语句执行支持</li><li>事务支持</li><li>增强的调试能力</li></ul><h4 id="PDO-1"><a href="#PDO-1" class="headerlink" title="PDO"></a>PDO</h4><ul><li>PHP 应用中的一个数据库抽象层规范</li><li>PDO 提供一个统一的 API 接口，无须关心数据库类型</li><li>使用标准的 PDO API，可以快速无缝切换数据库</li></ul><h3 id="数据库持久连接"><a href="#数据库持久连接" class="headerlink" title="数据库持久连接"></a>数据库持久连接</h3><p>把 PHP 用作多进程 web 服务器的一个模块，这种方法目前只适用于 Apache。</p><p>对于一个多进程的服务器，其典型特征是有一个父进程和一组子进程协调运行，其中实际生成 web 页面的是子进程。每当客户端向父进程提出请求时，该请求会被传递给还没有被其它的客户端请求占用的子进程。这也就是说当相同的客户端第二次向服务端提出请求时，它将有可能被一个不同的子进程来处理。在开启了一个持久连接后，所有请求 SQL 服务的后继页面都能够重用这个已经建立的 SQL Server 连接。</p><h3 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h3><p>PHP 代码 =&gt; 启动 php 及 zend 引擎，加载注册拓展模块 =&gt; 对代码进行词法/语法分析 =&gt; 编译成opcode(opcache) =&gt; 执行 opcode</p><blockquote><p>PHP7 新增了抽象语法树(AST)，在语法分析阶段生成 AST，然后再生成 opcode 数组</p></blockquote><h3 id="base64-编码原理"><a href="#base64-编码原理" class="headerlink" title="base64 编码原理"></a>base64 编码原理</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//php-base64.png" alt="base64"></p><h3 id="ip2long-实现"><a href="#ip2long-实现" class="headerlink" title="ip2long 实现"></a>ip2long 实现</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//php-ip2long.png" alt="ip2long"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">124.205.30.150=2093817494</span><br><span class="line"></span><br><span class="line">list($p1,$p2,$p3,$p4) = explode(&#x27;.&#x27;,&#x27;124.205.30.150&#x27;);</span><br><span class="line"></span><br><span class="line">$realNum = $p1&lt;&lt;24+$p2&lt;&lt;16+$p3&lt;&lt;8+$p4;</span><br></pre></td></tr></table></figure><h3 id="MVC-的理解"><a href="#MVC-的理解" class="headerlink" title="MVC 的理解"></a>MVC 的理解</h3><p>MVC 包括三类对象。模型 Model 是应用对象，视图 View 是它在屏幕上的表示，控制器 Controller 定义用户界面对用户输入的响应方式。不使用 MVC，用户界面设计往往将这些对象混在一起，而 MVC 则将它们分离以提高灵活性和复用性</p><h3 id="主流-PHP-框架特点"><a href="#主流-PHP-框架特点" class="headerlink" title="主流 PHP 框架特点"></a>主流 PHP 框架特点</h3><h4 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h4><p>易于访问，功能强大，并提供大型，强大的应用程序所需的工具</p><ul><li>简单快速的路由引擎</li><li>强大的依赖注入容器</li><li>富有表现力，直观的数据库 ORM</li><li>提供数据库迁移功能</li><li>灵活的任务调度器</li><li>实时事件广播</li></ul><h4 id="Symfony"><a href="#Symfony" class="headerlink" title="Symfony"></a>Symfony</h4><ul><li>Database engine-independent</li><li>Simple to use, in most cases, but still flexible enough to adapt to complex cases</li><li>Based on the premise of convention over configuration–the developer needs to configure only the unconventional</li><li>Compliant with most web best practices and design patterns</li><li>Enterprise-ready–adaptable to existing information technology (IT) policies and architectures, and stable enough for long-term projects</li><li>Very readable code, with phpDocumentor comments, for easy maintenance</li><li>Easy to extend, allowing for integration with other vendor libraries</li></ul><h4 id="CodeIgniter"><a href="#CodeIgniter" class="headerlink" title="CodeIgniter"></a>CodeIgniter</h4><ul><li>基于模型-视图-控制器的系统</li><li>框架比较轻量</li><li>全功能数据库类，支持多个平台</li><li>Query Builder 数据库支持</li><li>表单和数据验证</li><li>安全性和 XSS 过滤</li><li>全页面缓存</li></ul><h4 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h4><ul><li>采用容器统一管理对象</li><li>支持 Facade</li><li>更易用的路由</li><li>注解路由支持</li><li>路由跨域请求支持</li><li>验证类增强</li><li>配置和路由目录独立</li><li>取消系统常量</li><li>类库别名机制</li><li>模型和数据库增强</li><li>依赖注入完善</li><li>支持 PSR-3 日志规范</li><li>中间件支持</li><li>支持 Swoole/Workerman 运行</li></ul><h3 id="对象关系映射-ORM"><a href="#对象关系映射-ORM" class="headerlink" title="对象关系映射/ORM"></a>对象关系映射/ORM</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>缩短编码时间、减少甚至免除对 model 的编码，降低数据库学习成本</li><li>动态的数据表映射，在表结构发生改变时，减少代码修改</li><li>可以很方便的引入附加功能(cache 层)</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>映射消耗性能、ORM 对象消耗内存</li><li>SQL 语句较为复杂时，ORM 语法可读性不高(使用原生 SQL)</li></ul><h3 id="链式调用实现"><a href="#链式调用实现" class="headerlink" title="链式调用实现"></a>链式调用实现</h3><p>类定义一个内置变量，让类中其他定义方法可访问到</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>set_exception_handler — 设置用户自定义的异常处理函数</p><p>使用 try / catch 捕获</p><h3 id="串行、并行、并发的区别"><a href="#串行、并行、并发的区别" class="headerlink" title="串行、并行、并发的区别"></a>串行、并行、并发的区别</h3><p>串行：执行多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个<br>并行：多个任务在同一时刻执行<br>并发：同一时刻需要执行多个任务</p><h3 id="同步与异步的理解"><a href="#同步与异步的理解" class="headerlink" title="同步与异步的理解"></a>同步与异步的理解</h3><p><strong>同步和异步是一种消息通信机制</strong>。其关注点在于 <code>被调用者返回</code> 和 <code>结果返回</code> 之间的关系，描述对象是被调用对象的行为。</p><h3 id="阻塞与非阻塞的理解"><a href="#阻塞与非阻塞的理解" class="headerlink" title="阻塞与非阻塞的理解"></a>阻塞与非阻塞的理解</h3><p><strong>阻塞和非阻塞是一种业务流程处理方式</strong>。其关注点在于调用发生时 <code>调用者状态</code> 和 <code>被调用者返回结果</code> 之间的关系，描述对象是等待结果时候调用者的状态。</p><h3 id="同步阻塞与非同步阻塞的理解"><a href="#同步阻塞与非同步阻塞的理解" class="headerlink" title="同步阻塞与非同步阻塞的理解"></a>同步阻塞与非同步阻塞的理解</h3><p>同步阻塞：打电话问老板有没有某书（调用），老板说查一下，让你别挂电话（同步），你一直等待老板给你结果，什么事也不做（阻塞）。</p><p>同步非阻塞：打电话问老板有没有某书（调用），老板说查一下，让你别挂电话（同步），等电话的过程中你还一边嗑瓜子（非阻塞）。</p><h3 id="异步阻塞与异步非阻塞的理解"><a href="#异步阻塞与异步非阻塞的理解" class="headerlink" title="异步阻塞与异步非阻塞的理解"></a>异步阻塞与异步非阻塞的理解</h3><p>异步阻塞：打电话问老板有没有某书（调用），老板说你先挂电话，有了结果通知你（异步），你挂了电话后（结束调用）, 除了等老板电话通知结果，什么事情也不做（阻塞）。</p><p>异步非阻塞：打电话问老板有没有某书（调用），老板说你先挂电话，有了结果通知你（异步），你挂电话后（结束调用），一遍等电话，一遍嗑瓜子。（非阻塞）</p><h3 id="如何实现异步调用"><a href="#如何实现异步调用" class="headerlink" title="如何实现异步调用"></a>如何实现异步调用</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="string">&quot;blog.maplemark.cn&quot;</span>, <span class="number">80</span>, <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$out</span> = <span class="string">&quot;GET /backend.php  / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Host: blog.maplemark.cn\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">    <span class="comment">/*忽略执行结果</span></span><br><span class="line"><span class="comment">    while (!feof($fp)) &#123;</span></span><br><span class="line"><span class="comment">        echo fgets($fp, 128);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多进程同时写一个文件"><a href="#多进程同时写一个文件" class="headerlink" title="多进程同时写一个文件"></a>多进程同时写一个文件</h3><p>加锁、队列</p><h3 id="PHP-进程模型，进程通讯方式，进程线程区别"><a href="#PHP-进程模型，进程通讯方式，进程线程区别" class="headerlink" title="PHP 进程模型，进程通讯方式，进程线程区别"></a>PHP 进程模型，进程通讯方式，进程线程区别</h3><p>消息队列、socket、信号量、共享内存、信号、管道</p><h3 id="PHP-支持回调的函数，实现一个"><a href="#PHP-支持回调的函数，实现一个" class="headerlink" title="PHP 支持回调的函数，实现一个"></a>PHP 支持回调的函数，实现一个</h3><p>array_map、array_filter、array_walk、usort</p><p>is_callable + callbacks + 匿名函数实现</p><h3 id="发起-HTTP-请求有哪几种方式，它们有何区别"><a href="#发起-HTTP-请求有哪几种方式，它们有何区别" class="headerlink" title="发起 HTTP 请求有哪几种方式，它们有何区别"></a>发起 HTTP 请求有哪几种方式，它们有何区别</h3><p>cURL、file_get_contents、fopen、fsockopen</p><h3 id="php-for-while-foreach-迭代数组时候，哪个效率最高"><a href="#php-for-while-foreach-迭代数组时候，哪个效率最高" class="headerlink" title="php for while foreach 迭代数组时候，哪个效率最高"></a>php for while foreach 迭代数组时候，哪个效率最高</h3><h3 id="弱类型变量如何实现"><a href="#弱类型变量如何实现" class="headerlink" title="弱类型变量如何实现"></a>弱类型变量如何实现</h3><p>PHP 中声明的变量，在 zend 引擎中都是用结构体 zval 来保存，通过共同体实现弱类型变量声明</p><h3 id="PHP-拓展初始化"><a href="#PHP-拓展初始化" class="headerlink" title="PHP 拓展初始化"></a>PHP 拓展初始化</h3><ul><li>初始化拓展</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">php /php-src/ext/ext_skel.php --ext</span></span><br></pre></td></tr></table></figure><ul><li>定义拓展函数</li></ul><p>zend_module_entry 定义 Extension name 编写 PHP_FUNCTION 函数</p><ul><li>编译安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">phpize $ ./configure $ make &amp;&amp; make install</span></span><br></pre></td></tr></table></figure><h3 id="如何获取扩展安装路径"><a href="#如何获取扩展安装路径" class="headerlink" title="如何获取扩展安装路径"></a>如何获取扩展安装路径</h3><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>引用计数器</p><h3 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h3><p>自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait</p><h3 id="yield-是什么，说个使用场景-yield、yield-核心原理是什么"><a href="#yield-是什么，说个使用场景-yield、yield-核心原理是什么" class="headerlink" title="yield 是什么，说个使用场景 yield、yield 核心原理是什么"></a>yield 是什么，说个使用场景 yield、yield 核心原理是什么</h3><p>一个生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以yield生成许多它所需要的值。</p><p>yield核心原理: PHP在使用生成器的时候，会返回一个Generator类的对象。每一次迭代，PHP会通过Generator实例计算出下一次需要迭代的值。简述即yield用于生成值。</p><p>yield使用场景：读取大文件、大量计算。</p><p>yield好处：节省内存、优化性能</p><h3 id="traits-与-interfaces-区别-及-traits-解决了什么痛点"><a href="#traits-与-interfaces-区别-及-traits-解决了什么痛点" class="headerlink" title="traits 与 interfaces 区别 及 traits 解决了什么痛点"></a>traits 与 interfaces 区别 及 traits 解决了什么痛点</h3><h3 id="如何-foreach-迭代对象、如何数组化操作对象-obj-key-、如何函数化对象-obj-123"><a href="#如何-foreach-迭代对象、如何数组化操作对象-obj-key-、如何函数化对象-obj-123" class="headerlink" title="如何 foreach 迭代对象、如何数组化操作对象 $obj[key]、如何函数化对象 $obj(123);"></a>如何 foreach 迭代对象、如何数组化操作对象 $obj[key]、如何函数化对象 $obj(123);</h3><h3 id="Swoole-适用场景，协程实现方式"><a href="#Swoole-适用场景，协程实现方式" class="headerlink" title="Swoole 适用场景，协程实现方式"></a>Swoole 适用场景，协程实现方式</h3><p>Swoole 是一个使用 C++ 语言编写的基于异步事件驱动和协程的并行网络通信引擎，为 PHP 提供协程、高性能网络编程支持。提供了多种通信协议的网络服务器和客户端模块，可以方便快速的实现 TCP/UDP服务、高性能Web、WebSocket服务、物联网、实时通讯、游戏、微服务等，使 PHP 不再局限于传统的 Web 领域。</p><p>协程可以简单理解为线程，只不过这个线程是用户态的，不需要操作系统参与，创建销毁和切换的成本非常低，和线程不同的是协程没法利用多核 cpu 的，想利用多核 cpu 需要依赖 Swoole 的多进程模型。<br>在底层实现上是单线程的，因此同一时间只有一个协程在工作，协程的执行是串行的。<br>采用 CSP 编程模型，即不要以共享内存的方式来通信，相反，要通过通信来共享内存。<br>swoole4.0采用双栈方式，通过栈桢切换来实现协程；即遇到IO等待就切换到。</p><h4 id="swoole的进程模型"><a href="#swoole的进程模型" class="headerlink" title="swoole的进程模型"></a>swoole的进程模型</h4><p>同一台主机上两个进程间通信 (简称 IPC) 的方式有很多种，在 Swoole 中使用了 2 种方式 Unix Socket 和 sysvmsg。</p><p>swoole启动后会生成master进程、reactor线程、worker进程、task进程以及manager进程</p><p>master进程是一个多线程进程，会生成多个reactor线程<br>reactor线程负载网络监听、数据收发<br>work进程处理reactor线程投递的请求数据<br>task进程处理work进程投递的任务<br>manager进程用于管理work进程和task进程</p><h3 id="PHP-数组底层实现-（HashTable-Linked-list）"><a href="#PHP-数组底层实现-（HashTable-Linked-list）" class="headerlink" title="PHP 数组底层实现 （HashTable + Linked list）"></a>PHP 数组底层实现 （HashTable + Linked list）</h3><p>PHP 数组底层依赖的散列表数据结构，定义如下（位于 Zend/zend_types.h）。</p><p>数据存储在一个散列表中，通过中间层来保存索引与实际存储在散列表中位置的映射。</p><p>由于哈希函数会存在哈希冲突的可能，因此对冲突的值采用链表来保存。</p><p>哈希表的查询效率是o（1），链表查询效率是o（n）；因此PHP数据索引速度很快；但是相对比较占用空间。</p><h3 id="Copy-on-write-原理，何时-GC"><a href="#Copy-on-write-原理，何时-GC" class="headerlink" title="Copy on write 原理，何时 GC"></a>Copy on write 原理，何时 GC</h3><h3 id="如何解决-PHP-内存溢出问题"><a href="#如何解决-PHP-内存溢出问题" class="headerlink" title="如何解决 PHP 内存溢出问题"></a>如何解决 PHP 内存溢出问题</h3><h3 id="ZVAL"><a href="#ZVAL" class="headerlink" title="ZVAL"></a>ZVAL</h3><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h3 id="PHP7-新特性"><a href="#PHP7-新特性" class="headerlink" title="PHP7 新特性"></a>PHP7 新特性</h3><p>标量类型声明、返回值类型声明、通过 define() 定义常量数组、匿名类、相同命名空间类一次性导入</p><h3 id="PHP7-底层优化"><a href="#PHP7-底层优化" class="headerlink" title="PHP7 底层优化"></a>PHP7 底层优化</h3><p>ZVAL 结构体优化，占用由24字节降低为16字节</p><p>内部类型 zend_string，结构体成员变量采用 char 数组，不是用 char*</p><p>PHP 数组实现由 hashtable 变为 zend array</p><p>函数调用机制，改进函数调用机制，通过优化参数传递环节，减少了一些指令</p><h3 id="PSR-介绍，PSR-1-2-4-7"><a href="#PSR-介绍，PSR-1-2-4-7" class="headerlink" title="PSR 介绍，PSR-1, 2, 4, 7"></a>PSR 介绍，PSR-1, 2, 4, 7</h3><h3 id="Xhprof-、Xdebug-性能调试工具使用"><a href="#Xhprof-、Xdebug-性能调试工具使用" class="headerlink" title="Xhprof 、Xdebug 性能调试工具使用"></a>Xhprof 、Xdebug 性能调试工具使用</h3><h3 id="字符串、数字比较大小的原理，注意-0-开头的8进制、0x-开头16进制"><a href="#字符串、数字比较大小的原理，注意-0-开头的8进制、0x-开头16进制" class="headerlink" title="字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制"></a>字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制</h3><h3 id="BOM-头是什么，怎么除去"><a href="#BOM-头是什么，怎么除去" class="headerlink" title="BOM 头是什么，怎么除去"></a>BOM 头是什么，怎么除去</h3><p>WINDOWS自带的记事本，在保存一个以 UTF-8 编码的文件时，会在文件开始的地方插入三个不可见的字符（0xEF 0xBB 0xBF，即BOM）；它是一串隐藏的字符，用于让记事本等编辑器识别这个文件是否以UTF-8编码。<br>去除方法：$result = trim($result, “\xEF\xBB\xBF”);</p><h3 id="模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）"><a href="#模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）" class="headerlink" title="模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）"></a>模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）</h3><h3 id="写一个函数，尽可能高效的从一个标准-URL-中取出文件的扩展名"><a href="#写一个函数，尽可能高效的从一个标准-URL-中取出文件的扩展名" class="headerlink" title="写一个函数，尽可能高效的从一个标准 URL 中取出文件的扩展名"></a>写一个函数，尽可能高效的从一个标准 URL 中取出文件的扩展名</h3><p>parse_str,explode</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初探 SEO</title>
      <link href="/interview/docs/04.Web/01.%E5%88%9D%E6%8E%A2SEO/"/>
      <url>/interview/docs/04.Web/01.%E5%88%9D%E6%8E%A2SEO/</url>
      
        <content type="html"><![CDATA[<h1 id="初探-SEO"><a href="#初探-SEO" class="headerlink" title="初探 SEO"></a>初探 SEO</h1><h2 id="初探-SEO-1"><a href="#初探-SEO-1" class="headerlink" title="初探 SEO"></a>初探 SEO</h2><h3 id="SEO-的基本概念"><a href="#SEO-的基本概念" class="headerlink" title="SEO 的基本概念"></a>SEO 的基本概念</h3><blockquote><p>搜索引擎优化（英语：search engine optimization，缩写为 SEO），是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式</p></blockquote><blockquote><p>一般的可以理解为，通过了解谷歌/百度搜索引擎规则，从而提高网站在某些关键字下的排名，提高网站访问量</p></blockquote><h3 id="SEO-优缺点"><a href="#SEO-优缺点" class="headerlink" title="SEO 优缺点"></a>SEO 优缺点</h3><blockquote><p>成本较低。从某个角度上看，SEO 是一种”免费”的搜索引擎营销方式。对个人网站来说，只要站长掌握一定的搜索引擎优化技术即可。而对于企业来说，成本主要来自于从引擎优化员工的薪酬或雇用专业搜索引擎优化公司所花的费用</p></blockquote><blockquote><p>持久性。一般情况下，采用正规方法优化的网站，排名效果会比较稳定。除非搜索算法发生重大的改变或强大的竞争对手后来居上，否则不会有太大的变化</p></blockquote><h3 id="SEO-应用领域"><a href="#SEO-应用领域" class="headerlink" title="SEO 应用领域"></a>SEO 应用领域</h3><ul><li>企业网站</li></ul><blockquote><p>企业网站通过优化后，大大增加了向目标客户展示产品或者服务的机会，从而增强企业的影响力，提升品牌知名度</p></blockquote><ul><li>电子商务型网站</li></ul><blockquote><p>电子商务类网站经过优化后可以通过搜索引擎向更多的潜在消费者推销自身的产品，从而节省巨额的广告费用，提高产品销量</p></blockquote><ul><li>内容型网站</li></ul><blockquote><p>资讯内容类网站经过优化后，可以大大提高网站的流量，从而进一步蚕食强大的竞争对手的市场，最终后来居上，成为行业领先者</p></blockquote><h3 id="SEO-主要工作"><a href="#SEO-主要工作" class="headerlink" title="SEO 主要工作"></a>SEO 主要工作</h3><ul><li>SEO 的主要工作可以分为内部优化与外部优化</li></ul><blockquote><p>内部优化：从网站内部出发，对网站的基本要素（如网站结构、页面结构、关键字分布等）进行适当的调整，如果经过调整后，网站在搜索引擎中的表现达到了我们预期的效果，则内部优化工作就基本完成；否则，需要反复地对网站进行调整，直至达到预期效果为止</p></blockquote><blockquote><p>外部优化：主要围绕增强外部链接关系而展开的，此项工作必须贯彻优化的全过程。常用于增加外部链接的方法包括交换友情链接、登录分类目录、发布链接诱饵等</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//seo-%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="网站优化流程"></p><h3 id="SEO-宗旨"><a href="#SEO-宗旨" class="headerlink" title="SEO 宗旨"></a>SEO 宗旨</h3><blockquote><p>SEO 工作应该以用户为中心，围绕提高用户体验、完善网站功能而进行，不能为了优化而优化</p></blockquote><h2 id="搜索引擎工作原理"><a href="#搜索引擎工作原理" class="headerlink" title="搜索引擎工作原理"></a>搜索引擎工作原理</h2><blockquote><p>搜索引擎优化的主要任务之一就是提高网站的搜索引擎友好性，因此，搜索引擎优化的每个环节都与搜索引擎存在必然的联系，研究搜索引擎优化实际上是对搜索引擎工作过程的逆向推理。因此，学习搜索引擎优化应该从了解搜索引擎的工作原理开始</p></blockquote><blockquote><p>搜索引擎的主要工作包括：页面收录、页面分析、页面排序及关键字查询</p></blockquote><h3 id="页面收录"><a href="#页面收录" class="headerlink" title="页面收录"></a>页面收录</h3><blockquote><p>页面收录指搜索引擎通过蜘蛛程序在互联网上抓取页面并进行存储的过程，它为搜索引擎开展各项工作提供了数据支持</p></blockquote><ul><li>页面收录流程</li></ul><blockquote><p>在互联网中，URL 是每个页面的入口地址，搜索引擎蜘蛛程序就是通过 URL 抓取到页面的。搜索引擎蜘蛛程序从 URL 列表出发，通过 URL 抓取并存储原始页面；同时，提取原始页面中的 URL 资源并加入到 URL 列表中。如此不断地循环，就可以从互联网获取足够多的页面</p></blockquote><blockquote><p>利用搜索引擎提供的网站登录入口，想搜索引擎提交网站域名</p></blockquote><blockquote><p>通过与外部网站建立链接关系，使搜索引擎可以通过外部网站发现我们的网站，从而实现对网站的收录</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//seo-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%93%E5%8F%96%E9%A1%B5%E9%9D%A2%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B.png" alt="搜索引擎抓取页面简单流程"></p><ul><li>页面收录原理</li></ul><blockquote><p>如果把网站页面组成的集合看作是一个有向图，从指定的页面出发，沿着页面中的链接，按照某种特定的策略对网站中的页面进行遍历。不停地从 URL 列表中移出已经访问过的 URL，并存储原始页面，同时提取原始页面中的 URL 信息；再将 URL 分为域名及内部 URL 两大类，同时判断 URL 是否被访问过，将未访问的 URL 加入 URL 列表中。递归地扫描 URL 列表，直至耗尽所有 URL 资源为止。经过这些工作，搜索引擎就可以建立庞大的域名列表、页面 URL 列表并存储足够多的原始页面</p></blockquote><ul><li>页面收录方式</li></ul><blockquote><p>在互联网数以亿计的页面中，搜索引擎怎样才能从中抓取到相对重要的页面呢？这就涉及搜索引擎的页面收录方式</p></blockquote><blockquote><p>页面收录方式是指搜索引擎抓取页面时所使用的策略，目的是为了能在互联网中筛选出相对重要的信息</p></blockquote><blockquote><p>搜索引擎收录页面的方式主要有广度优先、深度优先及用户提交三种</p></blockquote><blockquote><p>广度优先：如果把整个网站看作是一棵树，首页就是根，每个页面就是叶子。广度优先是一种横向的页面抓取方式，先从树的较浅层开始抓取页面，直至抓取完同层次的所有页面后才进入下一层</p></blockquote><blockquote><p>深度优先：与广度优先抓取方式相反，深度优先首先跟踪浅层页面中的某一链接逐步抓取深层页面，直至抓取完最深的页面后才返回浅层页面再跟踪其另一链接，继续向深层页面抓取，这是一种纵向的页面抓取方式</p></blockquote><blockquote><p>用户提交：为了抓取更多的网页，搜索引擎还允许网站管理员主动提交页面。网站管理员只需要把网站中页面 URL 按照指定的格式制作成文件，提交给搜索引擎，搜索引擎即可通过该文件对网站中的页面进行抓取及更新</p></blockquote><ul><li>如何避免重复性收录</li></ul><blockquote><p>在互联网中，信息的重复是在所难免的。搜索引擎怎样识别重复信息呢？怎样判断哪些网页的信息是原创的，哪些是“复制”的？又会认为哪些重复的信息是有价值的，哪些又是可以舍弃的？</p></blockquote><blockquote><p>在网站中，重复信息主要包括转载内容及镜像内容两大类</p></blockquote><blockquote><p>转载页面：通过将网页正文内容划分，进行比对，判断相识度，确定互为转载关系后，再结合搜索引擎的抓取存储时间、页面权重等因素判断页面是否是原创页面还是转载页面</p></blockquote><blockquote><p>镜像页面：与转载页面判别类似</p></blockquote><blockquote><p>镜像网站：指两个内容完全相同的网站，形成镜像网站主要有两种情况，第一种是多个域名或 IP 指向同一服务器的同一个物理目录；另一个整个网站内容被复制到使用不同域名或者IP服务器上</p></blockquote><blockquote><p>转载页面、镜像页面、镜像网站，综合多项因素（网站权重值、建立时间）等因素，可能只收录极少页面，甚至不收录页面</p></blockquote><h3 id="页面分析"><a href="#页面分析" class="headerlink" title="页面分析"></a>页面分析</h3><blockquote><p>页面分析首先是对原始页面建立索引，实现对页面的快速定位；然后，提取页面的正文信息，并对正文信息进行切词以及为这些词（即关键字）建立索引，从而得到页面与关键字的对应关系；最后，对关键字进行重组，并建立关键字与网页相对于的反向索引列表，从而能够根据关键字快速定位至相应网页</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//seo-%E7%BD%91%E9%A1%B5%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="网页分析处理流程"></p><ul><li>页面索引</li></ul><blockquote><p>为了提高页面检索的效率，搜索引擎需要对抓取回来的原始页面建立索引，由于 URL 就是页面的入口地址，为了原始页面建立索引实际上就是为页面的 URL 建立索引，这样就可以实现根据 URL 快速定位到对应页面</p></blockquote><ul><li>网页分析</li></ul><blockquote><p>页面分析是整个网页处理中最重要的环节，包括了网页正文信息的提取、切词、建立关键字索引列表及关键字重组几个重要的步骤。结果形成了一个关键字对应多个原始页面的关系，即形成了与用户习惯相符合的信息雏形</p></blockquote><h3 id="页面排序"><a href="#页面排序" class="headerlink" title="页面排序"></a>页面排序</h3><blockquote><p>搜索引擎结合页面的内外部因素计算出页面与某个关键字的相关程度，从而得到与该关键字相关的页面排序列表</p></blockquote><ul><li>页面相关性</li></ul><blockquote><p>页面相关性是指页面内容与用户所查询的关键字的接近程度，主要由关键字匹配度、关键字密度、关键字分布及关键字的权重标签决定</p></blockquote><ul><li>链接权重</li></ul><blockquote><p>链接主要分内部链接及外部链接，是网页制作或者编辑者在对页面内容进行规划或者编辑时加入到页面中的，加入的理由可能是该链接所指向的页面非常重要，或者它是大部分用户所需要的。因此，某一页面得到的链接越多，从一定程度上反映了该页面越重要，链接权重值就越高</p></blockquote><ul><li>用户行为</li></ul><blockquote><p>搜索引擎在完成页面基本权重计算后，就可以向用户展示初步的排序结果。但这个排序结果不一定能让大部分用户满意，因此还要结合其他因素对该排序结果进行改进。列如，统计每条搜索结果的点击次数来推测用户对搜索结果的偏好</p></blockquote><h3 id="关键字查询"><a href="#关键字查询" class="headerlink" title="关键字查询"></a>关键字查询</h3><blockquote><p>搜索引擎接收来自用户的查询请求，并对查询信息进行切词及匹配后，再向用户返回相应的页面排序列表</p></blockquote><ul><li>查询流程</li></ul><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//seo-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="查询处理流程"></p><blockquote><p>先对用户提供的查询条件进行切词，并删除查询条件中没有的字或词，例如的、得等停用词</p></blockquote><blockquote><p>再以切词结果作为条件在关键字反向索引列表中进行匹配</p></blockquote><blockquote><p>如果存在匹配结果，则把所有与关键字相匹配的页面组成一个列表</p></blockquote><blockquote><p>最后，把匹配的页面按照权重值从高到低进行排序，并返回给用户</p></blockquote><ul><li>用户行为</li></ul><blockquote><p>用户在搜索中的行为主要包括搜索及点击。搜索是用户获取信息的过程，点击是用户得到需要信息后的表现</p></blockquote><blockquote><p>用户的搜索及点击行为中蕴含着非常丰富和重要的信息。例如，在用户搜索行为中包含了“提交的关键字”、“提交时间”、“用户IP地址”等信息，而在点击行为中则包含了“每个结果的点击次数”等信息</p></blockquote><blockquote><p>搜索引擎通过对用户行为的分析可以进一步发掘用户的需求，提高搜索结果的精准度。例如，从用户的搜索行为中，搜索引擎还可以发现新词汇；而从用户对搜索结果的点击行为中，可以分析出用户对每个搜索结果的偏好等</p></blockquote><ul><li>缓存机制</li></ul><blockquote><p>为了能在极短的时间内响应用户的查询请求，搜索引擎除了在用户提交查询信息前就生成关键字的页面排序列表外，还需要为那些查询最频繁的关键字对应的页面排序列表建立缓存机制</p></blockquote><h3 id="搜索引擎介绍"><a href="#搜索引擎介绍" class="headerlink" title="搜索引擎介绍"></a>搜索引擎介绍</h3><ul><li>Google</li></ul><blockquote><p>Google 十分重视链接关系，对于链接的质量、数量及相关性方面的分析技术在业界更是遥遥领先。尽管百度、雅虎也非常重视链接关系，但对链接的质量及相关性方面的分析则远不如 Google</p></blockquote><blockquote><p>在切词算法上，Google 与其他中文搜索引擎也存在一定的区别</p></blockquote><blockquote><p>在对待新网站方面，Google 非常严格，新网站只有同时满足多个条件时，才能正常参与排名竞争，这就是所谓的“沙盒效应”现象。这样做可以有效避免垃圾网站，但同时也给了一些新的优秀网站诸多制肘，很难通过 Google 向用户展示其极具价值的信息</p></blockquote><blockquote><p>在对垃圾信息处理方面，尽管 Google 目前还是以人工为主，但与其他搜索引擎相比，Google Spam 检测算法已经比较成熟。对于一些常见的作弊手段，例如伪装（cloaking）、门页（doorway page）、堆砌关键字、隐藏文字、垃圾链接等，Google 可以轻易识别</p></blockquote><ul><li>百度</li></ul><blockquote><p>如果把决定页面权重的因素分内部因素与外部因素两大类。在百度中，内部因素与外部因素在影响页面权重方面的差距比较小</p></blockquote><blockquote><p>百度对新网站比较宽松，这就造成了搜索结果中充斥着大量的垃圾信息，严重影响了用户体验</p></blockquote><blockquote><p>百度也非常重视链接关系，对于被高质量页面链接的页面会赋予极高的权重，但却忽悠了链接关系中网站间的主题相关性</p></blockquote><blockquote><p>百度对搜索结果的人工干预非常强</p></blockquote><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><blockquote><p>要对网站进行优化，首先需要为网站中的页面选择合适的关键词；然后，围绕突出关键字、提高页面相关性开展一系列的工作，以提高页面在相关关键字搜索结果中的排名</p></blockquote><h3 id="关键字介绍"><a href="#关键字介绍" class="headerlink" title="关键字介绍"></a>关键字介绍</h3><blockquote><p>关键字（keyword）在不同的领域有不同的含义。在搜索引擎中，关键字是指用户在寻找相关信息时所使用的内容，是搜索应用的基础，也是搜索引擎优化的基础。搜索引擎优化的目的之一就是提高页面与某个关键字间的相关性，要了解关键字与页面相关性的关系，我们要从认识关键字词频及关键字密度开始</p></blockquote><h3 id="关键字词频"><a href="#关键字词频" class="headerlink" title="关键字词频"></a>关键字词频</h3><blockquote><p>关键字词频是指某个关键字的页面中出现的概率，也即关键字在页面中出现的次数，从一定程度上反映了页面与该关键字的相关性</p></blockquote><blockquote><p>在搜索引擎发展初期，搜索结果中页面的排序基本是由关键字词频决定的。也就是说，页面中某个关键字出现的次数越多，说明该页面与此关键字间的相关性就越高，在此关键字的搜索结果中排名就越靠前。这种单纯以词频决定排序的方式，极容易被恶意操纵，从而影响搜索引擎的用户体验。因此，搜索引擎逐渐引进了诸如“关键字密度”、“关键字分布”及“外部链接”等因素进行制约</p></blockquote><h3 id="关键字密度"><a href="#关键字密度" class="headerlink" title="关键字密度"></a>关键字密度</h3><blockquote><p>在实际中，常用关键字密度来衡量页面中关键字的词频是否合理。关键字密度主要是由“关键字词频”及“网页总词汇量”两个因素决定，这三者关系如下：</p></blockquote><blockquote><p>关键字密度=关键字词频/网页总词汇量</p></blockquote><blockquote><p>式中，总词汇量是指页面程序标签（如 HTML 标签及 ASP、JSP、PHP 等）以外的所有词汇的数量</p></blockquote><h3 id="关键字分布及表现形式"><a href="#关键字分布及表现形式" class="headerlink" title="关键字分布及表现形式"></a>关键字分布及表现形式</h3><blockquote><p>搜索引擎分析网页时，在 HTML 源代码中是自上而下地进行的；而从页面布局的角度上看，则是自上而下、自左而右地进行（这也符合用户浏览网页的习惯）。因此，搜索引擎会更加重视网页中首先出现的内容，故我们在规划页面时也应该把相对重要的内容安排在页面的顶部，搜索引擎对页面的重视程度沿箭头方向逐渐减低</p></blockquote><blockquote><p>关键字表现形式是指关键字在页面中的显示样式，常见的关键字表现形式包括字体的字号、颜色、样式等；而字体样式又包括加粗、下划线、斜体、段落标题等</p></blockquote><blockquote><p>关键字描述指在页面中通过多种方式表达主辅关键字，以达到合理增加主辅关键字的词频及控制主关键字密度的目的</p></blockquote><h3 id="关键字策略"><a href="#关键字策略" class="headerlink" title="关键字策略"></a>关键字策略</h3><blockquote><p>制定符合自己网站特点的科学的关键字策略，可以避免与强大的竞争对手直接硬碰硬的竞争，从而占据属于自己的一席之地，为以后的生存打下坚实的基础。制定关键字策略，首先要寻找与页面主题相关的关键字，然后再根据实际情况从中筛选出一部分合适的关键字</p></blockquote><blockquote><p>利用搜索引擎的搜索功能，我们可轻松地找到与页面主题相关的关键字</p></blockquote><blockquote><p>用户搜索习惯是指用户在搜索引擎中寻找相关内容时所使用的关键字形式。对于不同类别的产品，用户的搜索习惯会存在一定的差别，而我们应该优先选择那些符合大部分用户搜索习惯的关键字形式</p></blockquote><blockquote><p>一个关键字是否具有优化可行性，需要首先对该关键字进行综合的评估，包括关键字的“搜索量”、“商业价值”及“竞争程度”；再从中筛选出高搜索量、高相关性、低竞争的关键字</p></blockquote><blockquote><p>关键字选择技巧：次关键字法、长尾理论法</p></blockquote><h2 id="URL-优化"><a href="#URL-优化" class="headerlink" title="URL 优化"></a>URL 优化</h2><h3 id="URL-优化简介"><a href="#URL-优化简介" class="headerlink" title="URL 优化简介"></a>URL 优化简介</h3><blockquote><p>URL 优化就是指通过对 URL 各组成部分进行适当的调整，以提高 URL 的搜索引擎友好性。它包括三大部分：第一，对域名、目录、文件的命名；第二，分隔符的使用；第三，URL 长度及关键字词频的控制。这三部分之间相互制约、相互影响。在优化的过程中，我们必须掌握着三部分的内在联系，对各部分进行充分的协调，才能达到最佳的优化效果，否则就功败垂成</p></blockquote><h3 id="URL-命名技巧"><a href="#URL-命名技巧" class="headerlink" title="URL 命名技巧"></a>URL 命名技巧</h3><blockquote><p>URL 命名是针对 URL 各组成部分而进行的，是 URL 优化最重要的环节。URL 命名的关键在于使用合适的关键字为 URL 各组成部分进行命名，即该关键字所表达的意义必须与 URL 所指向的页面的主题是相关的，这样有利于提高页面的相关性，突出页面的主题</p></blockquote><h3 id="分隔符的使用"><a href="#分隔符的使用" class="headerlink" title="分隔符的使用"></a>分隔符的使用</h3><blockquote><p>为了让搜索引擎能够正确识别以英文形式命名的 URL 中的关键字，我们需要使用相应的符号对单词进行分隔，常见的分隔符包括：空格“ ”、横杠“-”、下划线“_”、逗号“，”及加号“+”等</p></blockquote><h3 id="URL-长度"><a href="#URL-长度" class="headerlink" title="URL 长度"></a>URL 长度</h3><blockquote><p>搜索引擎在抓取页面时，对页面的 URL 长度存在一定的限制。对于超过限定长度的 URL 所指向的页面，搜索引擎就有可能放弃收录。决定 URL 长度的主要因素包括域名长度、路径长度及文件名长度</p></blockquote><h3 id="关键字词频-1"><a href="#关键字词频-1" class="headerlink" title="关键字词频"></a>关键字词频</h3><blockquote><p>在一定完整的 URL 中，主关键字只出现一次，不管对于普通用户还是搜索引擎都是较为友好的。一方面涉及 URL 长度的问题；另一方面，如果同一关键字在 URL 中多次重复出现，还会涉嫌关键字堆砌，严重者可能遭到搜索引擎的惩罚</p></blockquote><h3 id="关键字结合"><a href="#关键字结合" class="headerlink" title="关键字结合"></a>关键字结合</h3><blockquote><p>在 URL 中，还可以利用分隔符对 URL 各组成的名称进行组合，从而产生新的词组（或短语）来扩展 URL 的意义</p></blockquote><h3 id="URL-重定向"><a href="#URL-重定向" class="headerlink" title="URL 重定向"></a>URL 重定向</h3><blockquote><p>重定向是指把对一个域名、目录或者文件的访问请求转发至另一个域名、目录或其他服务器空间上，当用户发出相应的访问请求时将自动跳转到指定的位置</p></blockquote><blockquote><p>常见的重定向欧301（永久重定向）及302（暂时重定向）两种</p></blockquote><h3 id="URL-静态化"><a href="#URL-静态化" class="headerlink" title="URL 静态化"></a>URL 静态化</h3><blockquote><p>不管是普通用户还是搜索引擎，都更钟情于静态页面</p></blockquote><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="代码优化简介"><a href="#代码优化简介" class="headerlink" title="代码优化简介"></a>代码优化简介</h3><blockquote><p>代码优化就是对网页中的 HTML 源代码进行必要的调整，以提高页面的友好性。页面经过代码优化后，一方面可以有效精简页面中的冗余代码，加快页面的显示速度，同时也降低页面占用搜索引擎服务器的存储空间，从而提高页面的用户体验及搜索引擎友好性；另一方面，还可以有效地突出页面的主题，提高页面的相关性。代码优化的主要工作包括精简代码、头部优化、权重标签使用及图片优化。在这四个环节中，精简代码是最基础、最根本的</p></blockquote><h3 id="精简代码"><a href="#精简代码" class="headerlink" title="精简代码"></a>精简代码</h3><blockquote><p>精简代码是指清除或者简化页面中的代码，从而达到降低页面体积、提高页面的用户体验及搜索引擎友好性的目的。页面代码的精简包括五大环节，它们是清理垃圾代码、 HTML 标签转换、 CSS 优化、 Js 优化及表格优化。其中，清理垃圾代码又是精简代码中最重要、最基础的</p></blockquote><h3 id="页面头部优化"><a href="#页面头部优化" class="headerlink" title="页面头部优化"></a>页面头部优化</h3><blockquote><p>摘要信息的生成在不同的搜索引擎中会存在比较大的差别，即使是同一个搜索引擎也会由于页面的实际情况而有所不同。一般情况下，搜索引擎会提取页面标题标签中的内容作为摘要信息的标题，而描述则常来自页面描述标签的内容或直接从页面正文中截取</p></blockquote><blockquote><p>&lt;title&gt;标签也称为标题标签，标题标签内容是对网页主题的概括，相当于一篇文章的题目。标题标签的优化是网站优化中最重要的内容之一，对页面相关性产生决定性的影响。大多数搜索引擎都是提取网页标题中的全部或部分内容作为搜索结果中摘要信息的标题向用户展示。因此，在拟写标题内容时，要做到主题突出、内容简洁</p></blockquote><blockquote><p>描述标签，即&lt;description&gt;标签，其内容是对页面内容的概括，相当于页面的简介。由于描述标签常被一些不法分子用于堆砌关键字，导致其对页面相关性的影响力日渐下降。但是，Google 仍然相当重视描述标签的内容。在 Google 的搜索结果中，大部分页面的描述都是来自页面描述标签里的内容</p></blockquote><blockquote><p>关键字标签即&lt;keywords&gt;标签，是头部三大标签之一。相对于标题标签及描述标签，关键字标签所起的作用微乎其微，甚至己经被忽略。但无论如何，为了能在残酷的竞争中脱颖而出，我们还是要把握好每一个可能会影响页面相关性的细节。</p></blockquote><h3 id="权重标签使用"><a href="#权重标签使用" class="headerlink" title="权重标签使用"></a>权重标签使用</h3><blockquote><p>&lt;h&gt;标签又称为标题标签，是所有权重标签中最重要的。它一共有六种样式，从&lt;h1&gt;至&lt;h6&gt;</p></blockquote><blockquote><p>字体标签（&lt;font&gt;）包括字体颜色、字号大小等属性，其中最重要的就是字号及颜色属性</p></blockquote><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><blockquote><p>在制作网页的时候，为了增强网页的视觉效果，在网页中或多或少会使用图片或者多媒体元素。然而，相对于文本来说，图片的体积庞大（少则二三十千字节，多则上百千字节），这就造成页面显示缓慢等现象。此外，搜索引擎也不能识别图片叭的文本内容。所以，对于页面中的重要内容，例如主关键字、辅关键字、频道名称、栏目名称等，我们不能以图片形式进行展示</p></blockquote><blockquote><p>为了减轻图片带来的负面影响，我们需要对图片进行相应的处理（即图片优化），以满足搜索引擎索引信息的要求。图片优化主要包括“图片描述”及“图片压缩”两大块，前者主要是为了向搜索引擎表达图片蕴含的信息，而后者主要是为了降低图片体积，加快页面显示速度</p></blockquote><h2 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h2><h3 id="网页结构简介"><a href="#网页结构简介" class="headerlink" title="网页结构简介"></a>网页结构简介</h3><blockquote><p>网页结构即网页内容的布局，创建网页结构，实际上就是对网页内容的布局进行规划。网页结构的创建是页面优化的重要环节之一，直接影响页面的用户体验及相关性。而且，还在一定程度上影响网站的整体结构及页面被收录的数量</p></blockquote><h3 id="网页组成元素"><a href="#网页组成元素" class="headerlink" title="网页组成元素"></a>网页组成元素</h3><blockquote><p>从页面结构的角度上看，网页主要由”导航栏”、”栏目”及”正文内容”这三大元素组成。网页结构的创建，网页内容的规划实际也是围绕这三大组成元素展开的</p></blockquote><blockquote><p>导航栏是构成网页的重要元素之一，是网站频道入口的集合区域，相当于网站的菜单</p></blockquote><blockquote><p>栏目是指页面中存放相同性质（或特征）内容的区域。在对页面内容进行内容布局时，把性质（或特征）相同的内容安排在页面上的同一区域，可以帮助用户快速获取所需的信息，对网站内容起到非常好的导航作用</p></blockquote><blockquote><p>正文内容是指页面中的主体内容。例如一个文章类页面，正文内容就是文章本身；而对于展示产品的网站，正文内容就是产品信息</p></blockquote><h3 id="页面重要区域分布规律"><a href="#页面重要区域分布规律" class="headerlink" title="页面重要区域分布规律"></a>页面重要区域分布规律</h3><blockquote><p>左上 &gt; 右上 &gt; 左 &gt; 右 &gt; 左下 &gt; 右下</p></blockquote><blockquote><p>搜索引擎分析网页时，在 HTML 源代码中是自上而下地进行的。因此，搜索引擎更加重视接近页面顶部的代码</p></blockquote><h3 id="网页结构类型"><a href="#网页结构类型" class="headerlink" title="网页结构类型"></a>网页结构类型</h3><blockquote><p>创建网页结构实际就是对导航栏、栏目及正文内容这三大页面基本组成元素进行组织布局。</p></blockquote><h2 id="搜索引擎优化工具"><a href="#搜索引擎优化工具" class="headerlink" title="搜索引擎优化工具"></a>搜索引擎优化工具</h2><h3 id="关键字查询工具"><a href="#关键字查询工具" class="headerlink" title="关键字查询工具"></a>关键字查询工具</h3><blockquote><p>关键字查询工具是指可以提供指定关键字的搜索量及相关信息的工具。这些工具可以帮助我们寻找与网站相关的关键字，常见的关键字查询工具包括 overtrue 关键字选择器、百度火爆地带、百度指数、 Google 趋势及 Google Adwords 关键字选择工具</p></blockquote><h3 id="Google-管理员工具"><a href="#Google-管理员工具" class="headerlink" title="Google 管理员工具"></a>Google 管理员工具</h3><blockquote><p>Google 管理员工具是 Google 为了加强网站管理员间的互动及提高搜索质量而退出的一款网站管理员工具。通过 Google 管理员工具，网站管理员可以了解 Google 查看网站的方式，并与 Google 协调工作，进一步提高网站的友好性</p></blockquote><h3 id="Sitemap-生成器"><a href="#Sitemap-生成器" class="headerlink" title="Sitemap 生成器"></a>Sitemap 生成器</h3><blockquote><p>可以利用相关工具生成 Sitemap，并将入口置于站点首页底部，便于爬虫快速爬取整站</p></blockquote><p><strong>《初探SEO》原文链接：<a href="https://blog.maplemark.cn/2019/03/%E5%88%9D%E6%8E%A2-seo.html">https://blog.maplemark.cn/2019/03/初探-seo.html</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS Sprite的应用</title>
      <link href="/interview/docs/04.Web/03.CSS-Sprite%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/interview/docs/04.Web/03.CSS-Sprite%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="雪碧图CSS-Sprite的应用"><a href="#雪碧图CSS-Sprite的应用" class="headerlink" title="雪碧图CSS Sprite的应用"></a>雪碧图CSS Sprite的应用</h1><blockquote><p>CSS雪碧，即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。例如常见的商品分类导航其实所有商品的背景图用的都是一个所有小图标拼凑成的大图，只是在不同类别显示对应类别的图标时，通过li背景定位到大图的对应图标的位置。背景图位置可以使用一些雪碧图生成工具的时候，生成对应的CSS样式文件里面会有对应的位置信息。</p></blockquote><h2 id="好处优点"><a href="#好处优点" class="headerlink" title="好处优点"></a>好处优点</h2><blockquote><p>有效减少网站的http请求数量，加速图片的显示。</p></blockquote><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><blockquote><p>静态图片，图片不随用户信息的变化而变化。</p></blockquote><blockquote><p>小图片，容量比较小的(2-3KB)</p></blockquote><blockquote><p>图片加载量比较大的。</p></blockquote><blockquote><p>注意：大图片不建议用雪碧图咯，图片那么大，拼完之后岂不是拆机无敌大咯，加载就慢了，得不偿失！！！</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>利用 css3的 background-position控制一个层可显示区域范围大小，通过一个窗口，对背景图进行滑动。<br>简单来说，就是利用这个属性，设置背景图需要显示的起始位置，在通过标签来控制背景图显示的范围。</p></blockquote><h2 id="background-position属性"><a href="#background-position属性" class="headerlink" title="background-position属性"></a>background-position属性</h2><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-%E9%9B%AA%E7%A2%A7%E5%9B%BE1.jpg" alt="CSS sprite 1"></p><blockquote><p>根据图所知：</p></blockquote><blockquote><p>以左上角为（0,0）坐标</p></blockquote><blockquote><p>x,y都是负值</p></blockquote><blockquote><p>综上所诉，所以background-position的取值就是背景图显示的起始坐标，形式就是background-position：0, 0;</p></blockquote><h2 id="拼图"><a href="#拼图" class="headerlink" title="拼图"></a>拼图</h2><blockquote><p>拼图可以用ps，或者网上很多在线雪碧图生成工具，可以利用这些去生成雪碧图。</p></blockquote><blockquote><p>其实最好的拼图就是每个图标边距是多少和图标周围的留白留多少都控制好，对css的background-position的坐标写起来有规律的话，好些很多（然而这个是我自己手动拖拉的，位置很没有规律，所以下面的坐标值都是调试过才取值的）</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-%E9%9B%AA%E7%A2%A7%E5%9B%BE2.png" alt="CSS sprite 2"></p><blockquote><p>讲完这些了，可以来正题了，html和css代码了，下面代码是模仿生成一个菜单~~~</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>女装/男装/内衣<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>鞋靴/箱包/配件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-3&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>童装玩具/孕产/用品<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-4&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>家电/数码/手机<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-5&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>美妆/洗护/保健品<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-6&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>珠宝/眼镜/手表<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-7&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>运动/户外/乐器<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-8&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>游戏/动漫/影视<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-9&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>美食/生鲜/零食<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-10&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>鲜花/宠物/农资<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;cat-11&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>房产/装修/建材<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">180px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f8f8f8</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#bbb</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h3</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">h3</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;  </span><br><span class="line">  <span class="attribute">margin</span>:  <span class="number">3px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">31px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">31px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#dedede</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:  <span class="built_in">url</span>(<span class="string">sprite.png</span>);</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-1</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">7px</span> -<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-2</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">2px</span> -<span class="number">35px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-3</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">7px</span> -<span class="number">65px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-4</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">7px</span> -<span class="number">105px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-5</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">7px</span> -<span class="number">129px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-6</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">7px</span> -<span class="number">151px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-7</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>:-<span class="number">60px</span> -<span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-8</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>:-<span class="number">56px</span> -<span class="number">33px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-9</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">56px</span> -<span class="number">66px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-10</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>:-<span class="number">60px</span> -<span class="number">103px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cat-11</span> <span class="selector-tag">i</span>&#123;</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">51px</span> -<span class="number">128px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果图如下"><a href="#效果图如下" class="headerlink" title="效果图如下"></a>效果图如下</h2><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-%E9%9B%AA%E7%A2%A7%E5%9B%BE3.jpg" alt="CSS sprite 3"></p><p><strong>本文转载自 忆桐之家的博客，<a href="http://hongyitong.github.io/2016/12/23/雪碧图CSS%20Sprite的应用/" rel="nofollow">《雪碧图CSS Sprite的应用》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 水平居中设置</title>
      <link href="/interview/docs/04.Web/05.CSS%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E8%AE%BE%E7%BD%AE/"/>
      <url>/interview/docs/04.Web/05.CSS%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-水平居中设置"><a href="#CSS-水平居中设置" class="headerlink" title="CSS 水平居中设置"></a>CSS 水平居中设置</h1><h2 id="行内元素水平居中"><a href="#行内元素水平居中" class="headerlink" title="行内元素水平居中"></a>行内元素水平居中</h2><blockquote><p>如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。如下代码：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;txtCenter&quot;</span>&gt;</span>我是文本，哈哈，我想要在父容器中水平居中显示。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.txtCenter</span>&#123;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定宽块状元素水平居中"><a href="#定宽块状元素水平居中" class="headerlink" title="定宽块状元素水平居中"></a>定宽块状元素水平居中</h2><blockquote><p>当被设置元素为块状元素时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。下面来讲讲定宽块状元素。</p></blockquote><blockquote><p>满足定宽和块状两个条件的元素是可以通过设置 “左右margin” 值为 “auto” 来实现居中的。我们来看个例子就是设置 div 这个块状元素水平居中</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是定宽块状元素，哈哈，我要水平居中显示。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid red;  <span class="comment">/*为了显示居中效果明显为 div 设置了边框*/</span></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">500px</span>;   <span class="comment">/*定宽*/</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span> auto;  <span class="comment">/* margin-left 与 margin-right 设置为 auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以写成</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>:auto;</span><br><span class="line"><span class="attribute">margin-right</span>:auto;</span><br></pre></td></tr></table></figure><blockquote><p>注意：元素的“上下 margin” 是可以随意设置的</p></blockquote><h2 id="不定宽块状元素水平居中"><a href="#不定宽块状元素水平居中" class="headerlink" title="不定宽块状元素水平居中"></a>不定宽块状元素水平居中</h2><blockquote><p>在实际工作中我们会遇到需要为“不定宽度的块状元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。</p></blockquote><blockquote><p>不定宽度的块状元素有三种方法居中（这三种方法目前使用的都比多）：</p></blockquote><ul><li>加入 table 标签</li><li>设置 display;inline 方法</li><li>设置 position:relative 和 left:50%;</li></ul><blockquote><p>加入 table 标签</p></blockquote><blockquote><p>第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 <tbody>、<tr>、<td> )。</p></blockquote><blockquote><p>第二步：为这个 table 设置 “左右 margin 居中”（这个和定宽块状元素的方法一样）。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>:<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方法相比第一种方法的优势是不用增加无语义标签，简化了标签的嵌套深度，但也存在着一些问题：它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。</p></blockquote><blockquote><p>设置 position:relative 和 left:50%</p></blockquote><blockquote><p>通过给父元素设置 float，然后给父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:-50% 来实现水平居中。举例如下：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">list-style</span>:none;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">li</span>&#123;<span class="attribute">float</span><span class="selector-pseudo">:left</span>;<span class="attribute">display</span>:inline;<span class="attribute">margin-right</span>:<span class="number">8px</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方法可以保留块状元素仍以 display:block 的形式显示，优点不添加无语议表标签，不增加嵌套深度，但它的缺点是设置了 position:relative，带来了一定的副作用。</p></blockquote><blockquote><p>这三种方法使用得都非常广泛，各有优缺点，具体选用哪种方法，可以视具体情况而定。</p></blockquote><p><strong>本文转载自 陈浩的个人博客，<a href="http://cighao.com/2016/01/17/set-level-center-in-CSS/" rel="nofollow">《CSS 水平居中设置》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 垂直居中设置</title>
      <link href="/interview/docs/04.Web/06.CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E8%AE%BE%E7%BD%AE/"/>
      <url>/interview/docs/04.Web/06.CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-垂直居中设置"><a href="#CSS-垂直居中设置" class="headerlink" title="CSS 垂直居中设置"></a>CSS 垂直居中设置</h1><h2 id="父元素高度确定的单行文本"><a href="#父元素高度确定的单行文本" class="headerlink" title="父元素高度确定的单行文本"></a>父元素高度确定的单行文本</h2><blockquote><p>父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。如下代码</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    hi,imooc!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父元素高度确定的多行文本"><a href="#父元素高度确定的多行文本" class="headerlink" title="父元素高度确定的多行文本"></a>父元素高度确定的多行文本</h2><blockquote><p>父元素高度确定的多行文本、图片、块状元素的竖直居中的方法有两种</p></blockquote><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><blockquote><p>使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle</p></blockquote><blockquote><p>说到竖直居中，css 中有一个用于竖直居中的属性 vertical-align，但这个样式只有在父元素为 td 或 th 时，才会生效。所以又要插入 table 标签了。下面看一下例子：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">td</span>&#123;<span class="attribute">height</span>:<span class="number">500px</span>;<span class="attribute">background</span>:<span class="number">#ccc</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了</p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><blockquote><p>在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell，激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">display</span>:table-cell;<span class="comment">/*IE8以上及Chrome、Firefox*/</span></span><br><span class="line">    <span class="attribute">vertical-align</span>:middle;<span class="comment">/*IE8以上及Chrome、Firefox*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方法的好处是不用添加多余的无意义的标签，但缺点也很明显，它的兼容性不是很好，不兼容 IE6、7</p></blockquote><p><strong>本文转载自 陈浩的个人博客，<a href="http://cighao.com/2016/01/17/set-vertical-center-in-CSS/" rel="nofollow">《CSS 垂直居中设置》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flex 布局的基本概念</title>
      <link href="/interview/docs/04.Web/07.flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/interview/docs/04.Web/07.flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="flex-布局的基本概念"><a href="#flex-布局的基本概念" class="headerlink" title="flex 布局的基本概念"></a>flex 布局的基本概念</h1><blockquote><p>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。本文给出了 flexbox 的主要特性，更多的细节将在别的文档中探索。</p></blockquote><blockquote><p>我们说 flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局 CSS Grid Layout，可以同时处理行和列上的布局。</p></blockquote><h2 id="flexbox-的两根轴线"><a href="#flexbox-的两根轴线" class="headerlink" title="flexbox 的两根轴线"></a>flexbox 的两根轴线</h2><blockquote><p>当使用 flex 布局时，首先想到的是两根轴线 — 主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关, 所以有必要在一开始首先理解它。</p></blockquote><h3 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h3><blockquote><p>主轴由 flex-direction 定义，可以取4个值：</p></blockquote><ul><li>row</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul><blockquote><p>如果你选择了 row 或者 row-reverse，你的主轴将沿着 inline 方向延伸。</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-flex-01.png" alt="flex-图1"></p><blockquote><p>选择 column 或者 column-reverse 时，你的主轴会沿着上下方向延伸 — 也就是 block 排列的方向。</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-flex-02.png" alt="flex-图2"></p><h3 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h3><blockquote><p>交叉轴垂直于主轴，所以如果你的flex-direction (主轴) 设成了 row 或者 row-reverse 的话，交叉轴的方向就是沿着列向下的。</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-flex-03.png" alt="flex-图3"></p><blockquote><p>如果主轴方向设成了 column 或者 column-reverse，交叉轴就是水平方向。</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-flex-04.png" alt="flex-图4"></p><blockquote><p>理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。</p></blockquote><h2 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h2><blockquote><p>另外一个需要理解的重点是 flexbox 不会对文档的书写模式提供假设。过去，CSS的书写模式主要被认为是水平的，从左到右的。现代的布局方式涵盖了书写模式的范围，所以我们不再假设一行文字是从文档的左上角开始向右书写, 新的行也不是必须出现在另一行的下面。</p></blockquote><blockquote><p>你可以在接下来的文章中学到更多 flexbox 和书写模式关系的详细说明。下面的描述是来帮助我们理解为什么不用上下左右来描述 flexbox 元素的方向。</p></blockquote><blockquote><p>如果 flex-direction 是 row ，并且我是在书写英文，那么主轴的起始线是左边，终止线是右边。</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-flex-05.png" alt="flex-图5"></p><blockquote><p>如果我在书写阿拉伯文，那么主轴的起始线是右边，终止线是左边。</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-flex-06.png" alt="flex-图6"></p><blockquote><p>在这两种情况下，交叉轴的起始线是flex容器的顶部，终止线是底部，因为两种语言都是水平书写模式。</p></blockquote><blockquote><p>之后，你会觉得用起始和终止来描述比左右更合适，这会对你理解其他相同模式的布局方法（例如：CSS Grid Layout）起到帮助的作用。</p></blockquote><h2 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h2><blockquote><p>文档中采用了 flexbox 的区域就叫做 flex 容器。为了创建 flex 容器， 我们把一个容器的 display 属性值改为 flex 或者 inline-flex。 完成这一步之后，容器中的直系子元素就会变为 flex 元素。所有CSS属性都会有一个初始值，所以 flex 容器中的所有 flex 元素都会有下列行为：</p></blockquote><ul><li>元素排列为一行 (flex-direction 属性的初始值是 row)。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li>flex-basis 属性为 auto。</li><li>flex-wrap 属性为 nowrap。</li></ul><blockquote><p>这会让你的元素呈线形排列，并且把自己的大小作为主轴上的大小。如果有太多元素超出容器，它们会溢出而不会换行。如果一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Three</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>has</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>extra</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>text</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改flex方向-flex-direction"><a href="#更改flex方向-flex-direction" class="headerlink" title="更改flex方向 flex-direction"></a>更改flex方向 flex-direction</h3><blockquote><p>在 flex 容器中添加 flex-direction 属性可以让我们更改 flex 元素的排列方向。设置 flex-direction: row-reverse 可以让元素沿着行的方向显示，但是起始线和终止线位置会交换。</p></blockquote><blockquote><p>把 flex 容器的属性 flex-direction 改为 column ，主轴和交叉轴交换，元素沿着列的方向排列显示。改为 column-reverse ，起始线和终止线交换。</p></blockquote><blockquote><p>下面的例子中，flex-direction 值为 row-reverse。尝试使用其他的值 row ，column，column-reverse，看看内容会发生什么改变。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-direction</span>: row-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用flex-wrap实现多行Flex容器"><a href="#用flex-wrap实现多行Flex容器" class="headerlink" title="用flex-wrap实现多行Flex容器"></a>用flex-wrap实现多行Flex容器</h2><blockquote><p>虽然flexbox是一维模型，但可以使我们的flex项目应用到多行中。 在这样做的时候，您应该把每一行看作一个新的flex容器。 任何空间分布都将在该行上发生，而不影响该空间分布的其他行。</p></blockquote><blockquote><p>为了实现多行效果，请为属性flex-wrap添加一个属性值wrap。 现在，如果您的项目太大而无法全部显示在一行中，则会换行显示。 下面的实时例子包含已给出宽度的项目，对于flex容器，项目的子元素总宽度大于容器最大宽度。 由于flex-wrap的值设置为wrap，所以项目的子元素换行显示。若将其设置为nowrap，这也是初始值，它们将会缩小以适应容器，因为它们使用的是允许缩小的初始Flexbox值。 如果项目的子元素无法缩小，使用nowrap会导致溢出，或者缩小程度还不够小。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简写属性-flex-flow"><a href="#简写属性-flex-flow" class="headerlink" title="简写属性 flex-flow"></a>简写属性 flex-flow</h2><blockquote><p>你可以将两个属性 flex-direction 和 flex-wrap 组合为简写属性 flex-flow。第一个指定的值为 flex-direction ，第二个指定的值为 flex-wrap.</p></blockquote><blockquote><p>在下面的例子中，尝试将第一个值修改为 flex-direction 的允许取值之一，即 row, row-reverse, column 或 column-reverse, 并尝试将第二个指定值修改为 wrap 或 nowrap。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex-元素上的属性"><a href="#flex-元素上的属性" class="headerlink" title="flex 元素上的属性"></a>flex 元素上的属性</h2><blockquote><p>为了更好地控制 flex 元素，有三个属性可以作用于它们：</p></blockquote><ul><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li></ul><blockquote><p>在这里，我们只会大概介绍一下它们的用法，更详细的细节请参阅其它的文章。</p></blockquote><blockquote><p>在考虑这几个属性的作用之前，需要先了解一下 布局空白 available space 这个概念。这几个 flex 属性的作用其实就是改变了 flex 容器中的布局空白的行为。同时，布局空白对于 flex 元素的对齐行为也是很重要的。</p></blockquote><blockquote><p>假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的布局空白。在默认情况下， flexbox 的行为会把这 200px 的空白留在最后一个元素的后面。</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-flex-07.png" alt="flex-图7"></p><blockquote><p>如果期望这些元素能自动地扩展去填充满剩下的空白，那么我们需要去控制布局空白在这几个元素间如何分配，这就是元素上的那些 flex 属性要做的事。</p></blockquote><h3 id="Flex-元素属性：flex-basis"><a href="#Flex-元素属性：flex-basis" class="headerlink" title="Flex 元素属性：flex-basis"></a>Flex 元素属性：flex-basis</h3><blockquote><p>flex-basis 定义了该元素的布局空白（available space）的基准值。 该属性的默认值是 auto 。此时，浏览器会检测这个元素是否具有确定的尺寸。 在上面的例子中, 所有元素都设定了宽度（width）为100px，所以 flex-basis 的值为100px。</p></blockquote><blockquote><p>如果没有给元素设定尺寸，flex-basis 的值采用元素内容的尺寸。这就解释了：我们给只要给Flex元素的父元素声明 display: flex ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p></blockquote><h3 id="Flex-元素属性：flex-grow"><a href="#Flex-元素属性：flex-grow" class="headerlink" title="Flex 元素属性：flex-grow"></a>Flex 元素属性：flex-grow</h3><blockquote><p>flex-grow 若被赋值为一个正整数， flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的布局空白（available space）。如果有其他元素也被允许延展，那么他们会各自占据布局空白的一部分。</p></blockquote><blockquote><p>如果我们给上例中的所有元素设定 flex-grow 值为1， 容器中的布局空白会被这些元素平分。它们会延展以填满容器主轴方向上的空间。</p></blockquote><blockquote><p>flex-grow 属性可以按比例分配空间。如果第一个元素 flex-grow 值为2， 其他元素值为1，则第一个元素将占有2/4（上例中，即为 200px 中的 100px）, 另外两个元素各占有1/4（各50px）。</p></blockquote><h3 id="Flex-元素属性：-flex-shrink"><a href="#Flex-元素属性：-flex-shrink" class="headerlink" title="Flex 元素属性： flex-shrink"></a>Flex 元素属性： flex-shrink</h3><blockquote><p>flex-grow属性是处理flex元素在主轴上增加空间的问题，相反flex-shrink属性是处理flex元素收缩的问题。如果我们的容器中没有足够排列flex元素的空间，那么可以把flex元素flex-shrink属性设置为正整数来缩小它所占空间到flex-basis以下。与flex-grow属性一样，可以赋予不同的值来控制flex元素收缩的程度 —— 给flex-shrink属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。</p></blockquote><h3 id="Flex属性的简写"><a href="#Flex属性的简写" class="headerlink" title="Flex属性的简写"></a>Flex属性的简写</h3><blockquote><p>你可能很少看到 flex-grow，flex-shrink，和 flex-basis 属性单独使用，而是混合着写在 flex 简写形式中。 Flex 简写形式允许你把三个数值按这个顺序书写 — flex-grow，flex-shrink，flex-basis。</p></blockquote><blockquote><p>你可以在下面的实例中尝试把flex简写形式中的数值更改为不同数值，但要记得第一个数值是 flex-grow。赋值为正数的话是让元素增加所占空间。第二个数值是flex-shrink — 正数可以让它缩小所占空间，但是只有在flex元素总和超出主轴才会生效。最后一个数值是 flex-basis；flex元素是在这个基准值的基础上缩放的。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>大多数情况下可以用预定义的简写形式。 在这个教程中你可能经常会看到这种写法，许多情况下你都可以这么使用。下面是几种预定义的值：</p></blockquote><ul><li>flex: initial</li><li>flex: auto</li><li>flex: none</li><li>flex: <positive-number></li></ul><blockquote><p>flex: initial 是把flex元素重置为Flexbox的初始值，它相当于 flex: 0 1 auto。在这里 flex-grow 的值为0，所以flex元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为1, 所以可以缩小flex元素来防止它们溢出。flex-basis 的值为 auto. Flex元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。</p></blockquote><blockquote><p>flex: auto 等同于 flex: 1 1 auto；和上面的 flex:initial 基本相同，但是这种情况下，flex元素在需要的时候既可以拉伸也可以收缩。</p></blockquote><blockquote><p>flex: none 可以把flex元素设置为不可伸缩。它和设置为 flex: 0 0 auto 是一样的。元素既不能拉伸或者收缩，但是元素会按具有 flex-basis: auto 属性的flexbox进行布局。</p></blockquote><blockquote><p>你在教程中常看到的 flex: 1 或者 flex: 2 等等。它相当于flex: 1 1 0。元素可以在flex-basis为0的基础上伸缩。</p></blockquote><blockquote><p>尝试在下面的实例中应用这些简写值。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素间的对齐和空间分配"><a href="#元素间的对齐和空间分配" class="headerlink" title="元素间的对齐和空间分配"></a>元素间的对齐和空间分配</h2><blockquote><p>Flexbox的一个关键特性是能够设置flex元素沿主轴方向和交叉轴方向的对齐方式，以及它们之间的空间分配。</p></blockquote><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><blockquote><p>align-items 属性可以使元素在交叉轴方向对齐。</p></blockquote><blockquote><p>这个属性的初始值为stretch，这就是为什么flex元素会默认被拉伸到最高元素的高度。实际上，它们被拉伸来填满flex容器 —— 最高的元素定义了容器的高度。</p></blockquote><blockquote><p>你也可以设置align-items的值为flex-start，使flex元素按flex容器的顶部对齐, flex-end 使它们按flex容器的下部对齐, 或者center使它们居中对齐. 在实例中尝试——我给出了flex容器的高度，以便你可以看到元素在容器中移动。看看如果更改 align-items的值为下列值会发生什么：</p></blockquote><ul><li>stretch</li><li>flex-start</li><li>flex-end</li><li>center</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Three</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>has</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>extra</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span>text</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><blockquote><p>justify-content属性用来使元素在主轴方向上对齐，主轴方向是通过 flex-direction 设置的方向。初始值是flex-start，元素从容器的起始线排列。但是你也可以把值设置为flex-end，从终止线开始排列，或者center，在中间排列.</p></blockquote><blockquote><p>你也可以把值设置为space-between，把元素排列好之后的剩余空间拿出来，平均分配到元素之间，所以元素之间间隔相等。或者使用space-around，使每个元素的左右空间相等。</p></blockquote><blockquote><p>在实例中尝试下列justify-content属性的值：</p></blockquote><ul><li>stretch</li><li>flex-start</li><li>flex-end</li><li>center</li><li>space-around</li><li>space-between</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>本文转载自 MDN web docs，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" rel="nofollow">《flex 布局的基本概念》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 的性能优化 - 加载和执行</title>
      <link href="/interview/docs/04.Web/09.JavaScript%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/"/>
      <url>/interview/docs/04.Web/09.JavaScript%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-的性能优化：加载和执行"><a href="#JavaScript-的性能优化：加载和执行" class="headerlink" title="JavaScript 的性能优化：加载和执行"></a>JavaScript 的性能优化：加载和执行</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>无论当前 JavaScript 代码是内嵌还是在外链文件中，页面的下载和渲染都必须停下来等待脚本执行完成。JavaScript 执行过程耗时越久，浏览器等待响应用户输入的时间就越长。浏览器在下载和执行脚本时出现阻塞的原因在于，脚本可能会改变页面或 JavaScript 的命名空间，它们对后面页面内容造成影响。一个典型的例子就是在页面中使用document.write()。例如清单 1</p><p>清单 1 JavaScript 代码内嵌示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Today is &quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">toDateString</span>());</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当浏览器遇到<code>&lt;script&gt;</code>标签时，当前 HTML 页面无从获知 JavaScript 是否会向<code>&lt;p&gt;</code>标签添加内容，或引入其他元素，或甚至移除该标签。因此，这时浏览器会停止处理页面，先执行 JavaScript代码，然后再继续解析和渲染页面。同样的情况也发生在使用 src 属性加载 JavaScript的过程中，浏览器必须先花时间下载外链文件中的代码，然后解析并执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。</p><h2 id="脚本位置"><a href="#脚本位置" class="headerlink" title="脚本位置"></a>脚本位置</h2><p>HTML 4 规范指出<code>&lt;script&gt;</code>标签可以放在 HTML 文档的<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>中，并允许出现多次。Web 开发人员一般习惯在<code>&lt;head&gt;</code>中加载外链的 JavaScript，接着用<code>&lt;link&gt;</code>标签用来加载外链的 CSS 文件或者其他页面信息。例如清单 2</p><p>清单 2 低效率脚本位置示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;script1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而这种常规的做法却隐藏着严重的性能问题。在清单 2 的示例中，当浏览器解析到 <code>&lt;script&gt;</code> 标签（第 4 行）时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，这意味着，其后的 styles.css 样式文件和<code>&lt;body&gt;</code>标签都无法被加载，由于<code>&lt;body&gt;</code>标签无法被加载，那么页面自然就无法渲染了。因此在该 JavaScript 代码完全执行完之前，页面都是一片空白。图 1 描述了页面加载过程中脚本和样式文件的下载过程。</p><p>图1 JavaScript 文件的加载和执行阻塞其他文件的下载<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-%E6%80%A7%E8%83%BD01.jpg" alt="JavaScript性能优化"></p><p>我们可以发现一个有趣的现象：第一个 JavaScript 文件开始下载，与此同时阻塞了页面其他文件的下载。此外，从 script1.js 下载完成到 script2.js 开始下载前存在一个延时，这段时间正好是 script1.js 文件的执行过程。每个文件必须等到前一个文件下载并执行完成才会开始下载。在这些文件逐个下载过程中，用户看到的是一片空白的页面。</p><p>从 IE 8、Firefox 3.5、Safari 4 和 Chrome 2 开始都允许并行下载 JavaScript 文件。这是个好消息，因为<code>&lt;script&gt;</code>标签在下载外部资源时不会阻塞其他<code>&lt;script&gt;</code>标签。遗憾的是，JavaScript 下载过程仍然会阻塞其他资源的下载，比如样式文件和图片。尽管脚本的下载过程不会互相影响，但页面仍然必须等待所有 JavaScript 代码下载并执行完成才能继续。因此，尽管最新的浏览器通过允许并行下载提高了性能，但问题尚未完全解决，脚本阻塞仍然是一个问题。</p><p>由于脚本会阻塞页面其他资源的下载，因此推荐将所有<code>&lt;script&gt;</code>标签尽可能放到<code>&lt;body&gt;</code>标签的底部，以尽量减少对整个页面下载的影响。例如清单 3</p><p>清单 3 推荐的代码放置位置示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- Example of efficient script positioning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;script1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;script3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码展示了在 HTML 文档中放置<code>&lt;script&gt;</code>标签的推荐位置。尽管脚本下载会阻塞另一个脚本，但是页面的大部分内容都已经下载完成并显示给了用户，因此页面下载不会显得太慢。这是优化 JavaScript 的首要规则：将脚本放在底部。</p><h2 id="组织脚本"><a href="#组织脚本" class="headerlink" title="组织脚本"></a>组织脚本</h2><p>由于每个<code>&lt;script&gt;</code>标签初始下载时都会阻塞页面渲染，所以减少页面包含的<code>&lt;script&gt;</code>标签数量有助于改善这一情况。这不仅针对外链脚本，内嵌脚本的数量同样也要限制。浏览器在解析 HTML 页面的过程中每遇到一个<code>&lt;script&gt;</code>标签，都会因执行脚本而导致一定的延时，因此最小化延迟时间将会明显改善页面的总体性能。</p><p>这个问题在处理外链 JavaScript 文件时略有不同。考虑到 HTTP 请求会带来额外的性能开销，因此下载单个 100Kb 的文件将比下载 5 个 20Kb 的文件更快。也就是说，减少页面中外链脚本的数量将会改善性能。</p><p>通常一个大型网站或应用需要依赖数个 JavaScript 文件。您可以把多个文件合并成一个，这样只需要引用一个<code>&lt;script&gt;</code>标签，就可以减少性能消耗。文件合并的工作可通过离线的打包工具或者一些实时的在线服务来实现。</p><p>需要特别提醒的是，把一段内嵌脚本放在引用外链样式表的<code>&lt;link&gt;</code>之后会导致页面阻塞去等待样式表的下载。这样做是为了确保内嵌脚本在执行时能获得最精确的样式信息。因此，建议不要把内嵌脚本紧跟在<code>&lt;link&gt;</code>标签后面。</p><h2 id="无阻塞的脚本"><a href="#无阻塞的脚本" class="headerlink" title="无阻塞的脚本"></a>无阻塞的脚本</h2><p>减少 JavaScript 文件大小并限制 HTTP 请求数在功能丰富的 Web 应用或大型网站上并不总是可行。Web 应用的功能越丰富，所需要的 JavaScript 代码就越多，尽管下载单个较大的 JavaScript 文件只产生一次 HTTP 请求，却会锁死浏览器的一大段时间。为避免这种情况，需要通过一些特定的技术向页面中逐步加载 JavaScript 文件，这样做在某种程度上来说不会阻塞浏览器。</p><p>无阻塞脚本的秘诀在于，在页面加载完成后才加载 JavaScript 代码。这就意味着在 window 对象的 onload事件触发后再下载脚本。有多种方式可以实现这一效果。</p><h3 id="延迟加载脚本"><a href="#延迟加载脚本" class="headerlink" title="延迟加载脚本"></a>延迟加载脚本</h3><p>HTML 4 为<code>&lt;script&gt;</code>标签定义了一个扩展属性：defer。Defer 属性指明本元素所含的脚本不会修改 DOM，因此代码能安全地延迟执行。defer 属性只被 IE 4 和 Firefox 3.5 更高版本的浏览器所支持，所以它不是一个理想的跨浏览器解决方案。在其他浏览器中，defer 属性会被直接忽略，因此<code>&lt;script&gt;</code>标签会以默认的方式处理，也就是说会造成阻塞。然而，如果您的目标浏览器支持的话，这仍然是个有用的解决方案。清单 4 是一个例子</p><p>清单 4 defer 属性使用方法示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;script1.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>带有 defer 属性的<code>&lt;script&gt;</code>标签可以放置在文档的任何位置。对应的 JavaScript 文件将在页面解析到<code>&lt;script&gt;</code>标签时开始下载，但不会执行，直到 DOM 加载完成，即onload事件触发前才会被执行。当一个带有 defer 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载。</p><p>任何带有 defer 属性的<code>&lt;script&gt;</code>元素在 DOM 完成加载之前都不会被执行，无论内嵌或者是外链脚本都是如此。清单 5 的例子展示了defer属性如何影响脚本行为：</p><p>清单 5 defer 属性对脚本行为的影响</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Script Defer Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">defer</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;defer&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;script&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;load&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码在页面处理过程中弹出三次对话框。不支持 defer 属性的浏览器的弹出顺序是：“defer”、“script”、“load”。而在支持 defer 属性的浏览器上，弹出的顺序则是：“script”、“defer”、“load”。请注意，带有 defer 属性的<code>&lt;script&gt;</code>元素不是跟在第二个后面执行，而是在 onload 事件被触发前被调用。</p><p>如果您的目标浏览器只包括 Internet Explorer 和 Firefox 3.5，那么 defer 脚本确实有用。如果您需要支持跨领域的多种浏览器，那么还有更一致的实现方式。</p><p>HTML 5 为<code>&lt;script&gt;</code>标签定义了一个新的扩展属性：async。它的作用和 defer 一样，能够异步地加载和执行脚本，不因为加载脚本而阻塞页面的加载。但是有一点需要注意，在有 async 的情况下，JavaScript 脚本一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 JavaScript 脚本前后有依赖性，使用 async 就很有可能出现错误。</p><h3 id="动态脚本元素"><a href="#动态脚本元素" class="headerlink" title="动态脚本元素"></a>动态脚本元素</h3><p>文档对象模型（DOM）允许您使用 JavaScript 动态创建 HTML 的几乎全部文档内容。<code>&lt;script&gt;</code>元素与页面其他元素一样，可以非常容易地通过标准 DOM 函数创建：</p><p>清单 6 通过标准 DOM 函数创建<code>&lt;script&gt;</code>元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;script&quot;</span>);</span><br><span class="line">   script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">   script.<span class="property">src</span> = <span class="string">&quot;script1.js&quot;</span>;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>新的<code>&lt;script&gt;</code>元素加载 script1.js 源文件。此文件当元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。您甚至可以将这些代码放在<code>&lt;head&gt;</code>部分而不会对其余部分的页面代码造成影响（除了用于下载文件的 HTTP 连接）。</p><p>当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 Firefox 和 Opera，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时，这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，您需要跟踪脚本下载完成并是否准备妥善。可以使用动态 <code>&lt;script&gt;</code> 节点发出事件得到相关信息。</p><p>Firefox、Opera, Chorme 和 Safari 3+会在<code>&lt;script&gt;</code>节点接收完成之后发出一个 onload 事件。您可以监听这一事件，以得到脚本准备好的通知：</p><p>清单 7 通过监听 onload 事件加载 JavaScript 脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;script&quot;</span>)</span><br><span class="line">script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Firefox, Opera, Chrome, Safari 3+</span></span><br><span class="line">script.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Script loaded!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;script1.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>Internet Explorer 支持另一种实现方式，它发出一个 readystatechange 事件。<code>&lt;script&gt;</code>元素有一个 readyState 属性，它的值随着下载外部文件的过程而改变。readyState 有五种取值：</p><ul><li>“uninitialized”：默认状态</li><li>“loading”：下载开始</li><li>“loaded”：下载完成</li><li>“interactive”：下载完成但尚不可用</li><li>“complete”：所有数据已经准备好</li></ul><p>微软文档上说，在<code>&lt;script&gt;</code>元素的生命周期中，readyState 的这些取值不一定全部出现，但并没有指出哪些取值总会被用到。实践中，我们最感兴趣的是“loaded”和“complete”状态。Internet Explorer 对这两个 readyState 值所表示的最终状态并不一致，有时<code>&lt;script&gt;</code>元素会得到“loader”却从不出现“complete”，但另外一些情况下出现“complete”而用不到“loaded”。最安全的办法就是在 readystatechange 事件中检查这两种状态，并且当其中一种状态出现时，删除 readystatechange 事件句柄（保证事件不会被处理两次）：</p><p>清单 8 通过检查 readyState 状态加载 JavaScript 脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>)</span><br><span class="line">script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Internet Explorer</span></span><br><span class="line">script.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (script.<span class="property">readyState</span> == <span class="string">&quot;loaded&quot;</span> || script.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>)&#123;</span><br><span class="line">           script.<span class="property">onreadystatechange</span> = <span class="literal">null</span>;</span><br><span class="line">           <span class="title function_">alert</span>(<span class="string">&quot;Script loaded.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;script1.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>大多数情况下，您希望调用一个函数就可以实现 JavaScript 文件的动态加载。下面的函数封装了标准实现和 IE 实现所需的功能：</p><p>清单 9 通过函数进行封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">url, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;script&quot;</span>)</span><br><span class="line">    script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (script.<span class="property">readyState</span>)&#123; <span class="comment">//IE</span></span><br><span class="line">        script.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (script.<span class="property">readyState</span> == <span class="string">&quot;loaded&quot;</span> || script.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>)&#123;</span><br><span class="line">                script.<span class="property">onreadystatechange</span> = <span class="literal">null</span>;</span><br><span class="line">                <span class="title function_">callback</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//Others</span></span><br><span class="line">        script.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">callback</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    script.<span class="property">src</span> = url;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数接收两个参数：JavaScript 文件的 URL，和一个当 JavaScript 接收完成时触发的回调函数。属性检查用于决定监视哪种事件。最后一步，设置 src 属性，并将<code>&lt;script&gt;</code>元素添加至页面。此 loadScript() 函数使用方法如下：</p><p>清单 10 loadScript()函数使用方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadScript</span>(<span class="string">&quot;script1.js&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;File is loaded!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>您可以在页面中动态加载很多 JavaScript 文件，但要注意，浏览器不保证文件加载的顺序。所有主流浏览器之中，只有 Firefox 和 Opera 保证脚本按照您指定的顺序执行。其他浏览器将按照服务器返回它们的次序下载并运行不同的代码文件。您可以将下载操作串联在一起以保证他们的次序，如下：</p><p>清单 11 通过 loadScript()函数加载多个 JavaScript 脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loadScript</span>(<span class="string">&quot;script1.js&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">loadScript</span>(<span class="string">&quot;script2.js&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">loadScript</span>(<span class="string">&quot;script3.js&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;All files are loaded!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此代码等待 script1.js 可用之后才开始加载 script2.js，等 script2.js 可用之后才开始加载 script3.js。虽然此方法可行，但如果要下载和执行的文件很多，还是有些麻烦。如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。</p><p>动态脚本加载是非阻塞 JavaScript 下载中最常用的模式，因为它可以跨浏览器，而且简单易用。</p><h3 id="使用-XMLHttpRequest-XHR-对象"><a href="#使用-XMLHttpRequest-XHR-对象" class="headerlink" title="使用 XMLHttpRequest(XHR)对象"></a>使用 XMLHttpRequest(XHR)对象</h3><p>此技术首先创建一个 XHR 对象，然后下载 JavaScript 文件，接着用一个动态 <code>&lt;script&gt;</code> 元素将 JavaScript 代码注入页面。清单 12 是一个简单的例子：</p><p>清单 12 通过 XHR 对象加载 JavaScript 脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;script1.js&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span> || xhr.<span class="property">status</span> == <span class="number">304</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="property">createElement</span> (<span class="string">&quot;script&quot;</span>);</span><br><span class="line">            script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">            script.<span class="property">text</span> = xhr.<span class="property">responseText</span>;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>此代码向服务器发送一个获取 script1.js 文件的 GET 请求。onreadystatechange 事件处理函数检查 readyState 是不是 4，然后检查 HTTP 状态码是不是有效（2XX 表示有效的回应，304 表示一个缓存响应）。如果收到了一个有效的响应，那么就创建一个新的<code>&lt;script&gt;</code>元素，将它的文本属性设置为从服务器接收到的 responseText 字符串。这样做实际上会创建一个带有内联代码的<code>&lt;script&gt;</code>元素。一旦新<code>&lt;script&gt;</code>元素被添加到文档，代码将被执行，并准备使用。</p><p>这种方法的主要优点是，您可以下载不立即执行的 JavaScript 代码。由于代码返回在<code>&lt;script&gt;</code>标签之外（换句话说不受<code>&lt;script&gt;</code>标签约束），它下载后不会自动执行，这使得您可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。</p><p>此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内，不能从 CDN 下载（CDN 指”内容投递网络（Content Delivery Network）”，所以大型网页通常不采用 XHR 脚本注入技术。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>减少 JavaScript 对性能的影响有以下几种方法：</p><p>将所有的<code>&lt;script&gt;</code>标签放到页面底部，也就是<code>&lt;/body&gt;</code>闭合标签之前，这能确保在脚本执行前页面已经完成了渲染。<br>尽可能地合并脚本。页面中的<code>&lt;script&gt;</code>标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。</p><p>采用无阻塞下载 JavaScript 脚本的方法：</p><ul><li>使用<code>&lt;script&gt;</code>标签的 defer 属性（仅适用于 IE 和 Firefox 3.5 以上版本）；</li><li>使用动态创建的<code>&lt;script&gt;</code>元素来下载并执行代码；</li><li>使用 XHR 对象下载 JavaScript 代码并注入页面中。</li></ul><p>通过以上策略，可以在很大程度上提高那些需要使用大量 JavaScript 的 Web 网站和应用的实际性能。</p><p><strong>本文转载自 IBM Developer，<a href="https://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/" rel="nofollow">《JavaScript 的性能优化：加载和执行》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS Position学习</title>
      <link href="/interview/docs/04.Web/08.CSS-Position%E5%AD%A6%E4%B9%A0/"/>
      <url>/interview/docs/04.Web/08.CSS-Position%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-Position学习"><a href="#CSS-Position学习" class="headerlink" title="CSS Position学习"></a>CSS Position学习</h1><h2 id="CSS-Position有四个属性："><a href="#CSS-Position有四个属性：" class="headerlink" title="CSS Position有四个属性："></a>CSS Position有四个属性：</h2><ul><li>relative</li><li>absolute</li><li>fixed</li><li>static（默认）</li></ul><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sub1&quot;</span>&gt;</span>sub1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sub2&quot;</span>&gt;</span>sub2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>sub1和sub2是同级关系，parent是它们的父级元素。</p><h2 id="relative（相对定位）"><a href="#relative（相对定位）" class="headerlink" title="relative（相对定位）"></a>relative（相对定位）</h2><p>相对定位指的是相对于这个元素原位置的定位，且会占住原来的位置。</p><p>所谓原位置指不设置relative属性时它的位置（既static属性时的位置）</p><p>relative偏移相对的是margin的左上侧。</p><p>例如对sub1设置relative属性后，会根据top，right，bottom，left属性偏移，而sub2的位置不变（sub1会占住原来的位置）</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-position-01.png" alt="css position 图1"></p><p>再对sub2设置relative属性，它也会相对其原来的位置偏移（sub2位置还会被占着）</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-position-02.png" alt="css position 图2"></p><h2 id="absolute（绝对定位）"><a href="#absolute（绝对定位）" class="headerlink" title="absolute（绝对定位）"></a>absolute（绝对定位）</h2><p>绝对定位是根据其最近进行定位的父对象的 padding 的左上角进行定位，基本分为以下两种情况：</p><ul><li><p>例如对sub1设置absolute，如果sub1的父级元素（parent或者其父级元素）设置了absolute或relative，那么sub1就会相对这个父元素定位。</p></li><li><p>如果父级元素都没有设置absolute或relative，那sub1相对body定位。</p></li></ul><p>这时由于sub1的位置“腾出来了”，sub2就会跑到sub1的位置（也可以理解sub1浮起来了，dreamweaver中叫做层），它的文档流就会基于parent。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-position-03.png" alt="css position 图3"></p><p>如果再对sub2设置absolute，那其也是相对parent的。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-position-04.png" alt="css position 图4"></p><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p>fixed是特殊的absolute，即fixed总是以body为定位对象的，按照浏览器的窗口进行定位。</p><h2 id="static（默认）"><a href="#static（默认）" class="headerlink" title="static（默认）"></a>static（默认）</h2><p>position的默认值，一般不设置position属性时，会按照正常的文档流进行排列。</p><p><strong>本文转载自 小磊的博客，<a href="http://www.xiaoleilu.com/css-position" rel="nofollow">《CSS Position学习》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 盒模型</title>
      <link href="/interview/docs/04.Web/04.CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/interview/docs/04.Web/04.CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><blockquote><p>网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。</p></blockquote><blockquote><p>这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。</p></blockquote><blockquote><p>CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。</p></blockquote><h2 id="盒模型中的边框"><a href="#盒模型中的边框" class="headerlink" title="盒模型中的边框"></a>盒模型中的边框</h2><blockquote><p>盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。</p></blockquote><blockquote><p>如下面代码为 div 来设置边框粗细为 2px、样式为实心的、颜色为红色的边框：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123; <span class="attribute">border</span>:<span class="number">2px</span>  solid  red;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面是 border 代码的缩写形式，可以分开写：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意</li></ul><blockquote><p>border-style（边框样式）常见样式有：</p></blockquote><blockquote><p>dashed（虚线）| dotted（点线）| solid（实线）。</p></blockquote><blockquote><p>border-color（边框颜色）中的颜色可设置为十六进制颜色，如:</p></blockquote><blockquote><p>border-color:#888;//前面的井号不要忘掉。</p></blockquote><blockquote><p>border-width（边框宽度）中的宽度也可以设置为：</p></blockquote><blockquote><p>thin | medium | thick（但不是很常用），最常还是用象素（px）。</p></blockquote><blockquote><p>现在有一个问题，如果有想为 p 标签单独设置下边框，而其它三边都不设置边框样式怎么办呢？css 样式中允许只为一个方向的边框设置样式：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;border-bottom:1px solid red;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样可以使用下面代码实现其它三边(上、右、左)边框的设置：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>:<span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">border-right</span>:<span class="number">1px</span> solid red; </span><br><span class="line"><span class="attribute">border-left</span>:<span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure><h2 id="宽度和高度"><a href="#宽度和高度" class="headerlink" title="宽度和高度"></a>宽度和高度</h2><blockquote><p>盒模型宽度和高度和我们平常所说的物体的宽度和高度理解是不一样的，css内定义的宽（width）和高（height），指的是填充以里的内容范围。</p></blockquote><blockquote><p>因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</p></blockquote><h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><blockquote><p>元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。如下代码：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺序一定不要搞混。也可以分开写上面代码。</p></blockquote><blockquote><p>如果上、右、下、左的填充都为10px;可以这么写</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果上下填充一样为10px，左右一样为20px，可以这么写：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><blockquote><p>元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。如下代码：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也也可以分开写。</p></blockquote><blockquote><p>如果上右下左的边界都为10px;可以这么写：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123; <span class="attribute">margin</span>:<span class="number">10px</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果上下边界一样为10px，左右一样为20px，可以这么写：</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123; <span class="attribute">margin</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结一下：padding和margin的区别，padding在边框里，margin在边框外。</p></blockquote><p><strong>本文转载自 陈浩的个人博客，<a href="http://cighao.com/2016/01/17/box-pattern-in-CSS/" rel="nofollow">《CSS 盒模型》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 数据类型和数据结构</title>
      <link href="/interview/docs/04.Web/10.JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/interview/docs/04.Web/10.JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-数据类型和数据结构"><a href="#JavaScript-数据类型和数据结构" class="headerlink" title="JavaScript 数据类型和数据结构"></a>JavaScript 数据类型和数据结构</h1><p>编程语言都具有内建的数据结构，但各种编程语言的数据结构常有不同之处。本文试图列出 JavaScript 语言中内建的数据结构及其属性，它们可以用来构建其他的数据结构；同时尽可能的描述与其他语言的不同之处</p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;    <span class="comment">// foo is a Number now</span></span><br><span class="line">foo = <span class="string">&quot;bar&quot;</span>; <span class="comment">// foo is a String now</span></span><br><span class="line">foo = <span class="literal">true</span>;  <span class="comment">// foo is a Boolean now</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>最新的 ECMAScript 标准定义了 7 种数据类型:</p><ul><li>6 种原始类型:<ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>String</li><li>Symbol (ECMAScript 6 新定义)</li></ul></li><li>和 Object</li></ul><h2 id="原始值-primitive-values"><a href="#原始值-primitive-values" class="headerlink" title="原始值( primitive values )"></a>原始值( primitive values )</h2><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔表示一个逻辑实体，可以有两个值：true 和 false。</p><h3 id="Null-类型节"><a href="#Null-类型节" class="headerlink" title="Null 类型节"></a>Null 类型节</h3><p>Null 类型只有一个值： null，更多详情可查看 null 和 Null 。</p><h3 id="Undefined-类型节"><a href="#Undefined-类型节" class="headerlink" title="Undefined 类型节"></a>Undefined 类型节</h3><p>一个没有被赋值的变量会有个默认值 undefined，更多详情可查看 undefined 和 Undefined。</p><h3 id="数字类型节"><a href="#数字类型节" class="headerlink" title="数字类型节"></a>数字类型节</h3><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。</p><p>要检查值是否大于或小于 +/-Infinity，你可以使用常量 Number.MAX_VALUE 和 Number.MIN_VALUE。另外在 ECMAScript 6 中，你也可以通过 Number.isSafeInteger() 方法还有 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。</p><p>数字类型只有一个整数，它有两种表示方法： 0 可表示为 -0 和 +0（”0” 是 +0 的简写）。 在实践中，这也几乎没有影响。 例如 +0 === -0 为真。 但是，你可能要注意除以0的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> / +<span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">42</span> / -<span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><p>尽管一个数字常常仅代表它本身的值，但JavaScript提供了一些位运算符。 这些位运算符和一个单一数字通过位操作可以用来表现一些布尔值。然而自从 JavaScript 提供其他的方式来表示一组布尔值（如一个布尔值数组或一个布尔值分配给命名属性的对象）后，这种方式通常被认为是不好的。位操作也容易使代码难以阅读，理解和维护， 在一些非常受限的情况下，可能需要用到这些技术，比如试图应付本地存储的存储限制。 位操作只应该是用来优化尺寸的最后选择。</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。</p><p>不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。例如：</p><ul><li>获取一个字符串的子串可通过选择个别字母或者使用 String.substr().</li><li>两个字符串的连接使用连接操作符 (+) 或者 String.concat().</li></ul><h3 id="注意代码中的“字符串类型”！"><a href="#注意代码中的“字符串类型”！" class="headerlink" title="注意代码中的“字符串类型”！"></a>注意代码中的“字符串类型”！</h3><p>可以使用字符串来表达复杂的数据。以下是一些很好的性质：</p><ul><li>容易连接构造复杂的字串符</li><li>字符串容易被调试(你看到的往往在字符串里)</li><li>字符串通常是许多APIs的常见标准 (input fields, local storage values, XMLHttpRequest当使用responseText等的时候回应) 而且他只能与字符串一同使用。</li></ul><p>按照惯例, 字符串一般可以用来表达任何数据结构。这不是一个好主意。例如，使用一个分隔符，一个可以模仿一个列表(一个JavaScript的数组可能更适合一些) 。不幸的是，当一个分隔符在用于列表中的元素时，打乱了这个列表。 一个转义字符等。所有这些惯例都变成了一个不存在的维护负担而没有正确的工具使用。</p><p>表达文本数据和符号数据时候推荐使用字符串。当表达复杂的数据时，使用字符串解析和适当的缩写。</p><h3 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h3><p>符号(Symbols)是ECMAScript 第6版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值(如下). 在某些语言当中也有类似的原子类型(Atoms). 你也可以认为为它们是C里面的枚举类型. 更多细节请看 Symbol 和 Symbol 。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在计算机科学中, 对象是指内存中的可以被 标识符引用的一块区域.</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。（也就是说，你定义一个var a = “Hello”，那么a本身就会有a.substring这个方法，以及a.length这个属性，以及其它；如果你定义了一个对象，var a = {}，那么a就会自动有a.hasOwnProperty及a.constructor等属性和方法。）而后，这些属性还可以被增减。属性的值可以是任意类型，包括具有复杂数据结构的对象。属性使用键来标识，它的键值可以是一个字符串或者符号值（Symbol）。</p><p>ECMAScript定义的对象中有两种属性：数据属性和访问器属性。</p><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>数据属性是键值对，并且每个数据属性拥有下列特性:</p><ul><li>数据属性的特性(Attributes of a data property)</li></ul><table><thead><tr><th>特性</th><th>数据类型</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>[[Value]]</td><td>任何Javascript类型</td><td>包含这个属性的数据值。</td><td>undefined</td></tr><tr><td>[[Writable]]</td><td>Boolean</td><td>如果该值为 false，则该属性的 [[Value]] 特性 不能被改变。</td><td>true</td></tr><tr><td>[[Enumerable]]</td><td>Boolean</td><td>如果该值为 true，则该属性可以用 for…in 循环来枚举。</td><td>true</td></tr><tr><td>[[Configurable]]</td><td>Boolean</td><td>如果该值为 false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。</td><td>true</td></tr></tbody></table><ul><li>过时的属性(在ECMAScript 3定义的, 在ECMAScript 5被重命名)</li></ul><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Read-only</td><td>Boolean</td><td>ES5 [[Writable]]</td></tr><tr><td>DontEnum</td><td>Boolean</td><td>ES5 [[Enumerable]]</td></tr><tr><td>DontDelete</td><td>Boolean</td><td>ES5 [[Configurable]]</td></tr></tbody></table><h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>访问器属性有一个或两个访问器函数 (get 和 set) 来存取数值，并且有以下特性:</p><ul><li>一个访问器属性的特性</li></ul><table><thead><tr><th>特性</th><th>类型</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>[[Get]]</td><td>函数对象或者 undefined</td><td>该函数使用一个空的参数列表，能够在有权访问的情况下读取属性值。另见 get。</td><td>undefined</td></tr><tr><td>[[Set]]</td><td>函数对象或者 undefined</td><td>该函数有一个参数，用来写入属性值，另见 set。</td><td>undefined</td></tr><tr><td>[[Enumerable]]</td><td>Boolean</td><td>如果该值为 true，则该属性可以用 for…in 循环来枚举。</td><td>true</td></tr><tr><td>[[Configurable]]</td><td>Boolean</td><td>如果该值为 false，则该属性不能被删除，并且不能被转变成一个数据属性。</td><td>true</td></tr></tbody></table><blockquote><p>注意：这些特性只有 JavaScript 引擎才用到，因此你不能直接访问它们。所以特性被放在两对方括号中，而不是一对。</p></blockquote><h3 id="“标准的”-对象-和函数"><a href="#“标准的”-对象-和函数" class="headerlink" title="“标准的” 对象, 和函数"></a>“标准的” 对象, 和函数</h3><p>一个 Javascript 对象就是键和值之间的映射.。键是一个字符串（或者 Symbol） ，值可以是任意类型的值。 这使得对象非常符合 哈希表。</p><p>函数是一个附带可被调用功能的常规对象。</p><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>当你想要显示日期时，毋庸置疑，使用内建的 Date 对象。</p><h3 id="有序集-数组和类型数组"><a href="#有序集-数组和类型数组" class="headerlink" title="有序集: 数组和类型数组"></a>有序集: 数组和类型数组</h3><p>数组是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象。此外，数组对象还继承了 Array.prototype 的一些操作数组的便捷方法。例如, indexOf (搜索数组中的一个值) or push (向数组中添加一个元素)，等等。 这使得数组是表示列表或集合的最优选择。</p><p>类型数组(Typed Arrays)是ECMAScript Edition 6中新定义的 JavaScript 内建对象，提供了一个基本的二进制数据缓冲区的类数组视图。下面的表格能帮助你找到对等的 C 语言数据类型：</p><h4 id="TypedArray-objects"><a href="#TypedArray-objects" class="headerlink" title="TypedArray objects"></a>TypedArray objects</h4><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-TypedArray-objects.jpg" alt="TypedArray objects"></p><h3 id="键控集-Maps-Sets-WeakMaps-WeakSets"><a href="#键控集-Maps-Sets-WeakMaps-WeakSets" class="headerlink" title="键控集: Maps, Sets, WeakMaps, WeakSets"></a>键控集: Maps, Sets, WeakMaps, WeakSets</h3><p>这些数据结构把对象的引用当作键，其在ECMAScript第6版中有介绍。当 Map 和 WeakMap 把一个值和对象关联起来的时候， Set 和 WeakSet 表示一组对象。 Map和WeakMaps之间的差别在于，在前者中，对象键是可枚举的。这允许垃圾收集器优化后面的枚举(This allows garbage collection optimizations in the latter case)。</p><p>在纯ECMAScript 5下可以实现Maps和Sets。然而，因为对象并不能进行比较（就对象“小于”示例来讲），所以查询必定是线性的。他们本地实现（包括WeakMaps）查询所花费的时间可能是对数增长。</p><p>通常，可以通过直接在对象上设置属性或着使用<code>data-*</code>属性，来绑定数据到DOM节点。然而缺陷是在任何的脚本里，数据都运行在同样的上下文中。Maps和WeakMaps方便将数据私密的绑定到一个对象。 </p><h3 id="结构化数据-JSON"><a href="#结构化数据-JSON" class="headerlink" title="结构化数据: JSON"></a>结构化数据: JSON</h3><p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，来源于 JavaScript 同时也被多种语言所使用。 JSON 用于构建通用的数据结构。参见 JSON 以及 JSON 了解更多。</p><h3 id="标准库中更多的对象"><a href="#标准库中更多的对象" class="headerlink" title="标准库中更多的对象"></a>标准库中更多的对象</h3><p>JavaScript 有一个内置对象的标准库。请查看参考来了解更多对象。</p><h2 id="使用-typeof-操作符判断对象类型"><a href="#使用-typeof-操作符判断对象类型" class="headerlink" title="使用 typeof 操作符判断对象类型"></a>使用 typeof 操作符判断对象类型</h2><p>typeof 运算符可以帮助你查询变量的类型。要了解更多细节和注意事项请阅读参考页。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><table><thead><tr><th>规范</th><th>状态</th><th>注释</th></tr></thead><tbody><tr><td>ECMAScript 1st Edition (ECMA-262)</td><td>Standard</td><td>初始定义</td></tr><tr><td>ECMAScript 5.1 (ECMA-262)</td><td>Standard</td><td></td></tr><tr><td>ECMAScript 2015 (6th Edition, ECMA-262)</td><td>Standard</td><td></td></tr></tbody></table><p><strong>本文转载自 MDN web docs，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" rel="nofollow">《JavaScript 数据类型和数据结构》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的同源策略</title>
      <link href="/interview/docs/04.Web/12.%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
      <url>/interview/docs/04.Web/12.%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h1><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><h2 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a>同源的定义</h2><p>如果两个页面的协议，端口（如果有指定）和主机都相同，则两个页面具有相同的源。我们也可以把它称为“协议/主机/端口 tuple”，或简单地叫做“tuple”. (“tuple” ，“元”，是指一些事物组合在一起形成一个整体，比如（1，2）叫二元，（1，2，3）叫三元)</p><p>下表给出了相对 <code>http://store.company.com/dir/page.html</code> 同源检测的示例:</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://store.company.com/dir2/other.html">http://store.company.com/dir2/other.html</a></td><td>成功</td><td>只有路径不同</td></tr><tr><td><a href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td><td>成功</td><td>只有路径不同</td></tr><tr><td><a href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td><td>失败</td><td>不同协议 ( https和http )</td></tr><tr><td><a href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td><td>失败</td><td>不同端口 ( http:// 80是默认的)</td></tr><tr><td><a href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td><td>失败</td><td>不同域名 ( news和store )</td></tr></tbody></table><h3 id="源的继承"><a href="#源的继承" class="headerlink" title="源的继承"></a>源的继承</h3><p>在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。</p><p>例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过  Window.open()  机制）。 如果此弹出窗口也包含代码，则该代码将继承与创建它的脚本相同的源。</p><blockquote><p>注意：在Gecko 6.0之前，如果用户在位置栏中输入 data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。</p></blockquote><blockquote><p>data：URLs 获得一个新的，空的安全上下文。</p></blockquote><h3 id="IE-例外"><a href="#IE-例外" class="headerlink" title="IE 例外"></a>IE 例外</h3><p>当涉及到同源策略时，Internet Explorer 有两个主要的不同点</p><ul><li>授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。</li><li>端口：IE 未将端口号加入到同源策略的组成部分之中，因此 <a href="http://company.com:81/index.html">http://company.com:81/index.html</a> 和 <a href="http://company.com/index.html">http://company.com/index.html</a>  属于同源并且不受任何限制。</li></ul><p>这些例外是非标准的，其它浏览器也未做出支持，但会助于开发基于window RT IE的应用程序。</p><h2 id="源的更改"><a href="#源的更改" class="headerlink" title="源的更改"></a>源的更改</h2><p>页面可能会因某些限制而改变他的源。脚本可以将 <code>document.domain</code> 的值设置为其当前域或其当前域的父域。如果将其设置为其当前域的父域，则这个较短的父域将用于后续源检查。假设 <a href="http://store.company.com/dir/other.html">http://store.company.com/dir/other.html</a> 文档中的一个脚本执行以下语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;company.com&quot;</span>;</span><br></pre></td></tr></table></figure><p>这条语句执行之后，页面将会成功地通过对 <a href="http://company.com/dir/page.html">http://company.com/dir/page.html</a> 的同源检测（假设<a href="http://company.com/dir/page.html">http://company.com/dir/page.html</a> 将其 document.domain 设置为“company.com”，以表明它希望允许这样做 - 更多有关信息，请参阅 document.domain ）。然而，company.com 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的父域。</p><p>端口号是由浏览器另行检查的。任何对document.domain的赋值操作，包括 document.domain = document.domain 都会导致端口号被重写为 null 。因此 company.com:8080 不能仅通过设置 document.domain = “company.com” 来与company.com 通信。必须在他们双方中都进行赋值，以确保端口号都为 null 。</p><blockquote><p>注意：使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。这是必要的，即使这样做只是将父域设置回其原始值。不这样做可能会导致权限错误</p></blockquote><h2 id="跨源网络访问"><a href="#跨源网络访问" class="headerlink" title="跨源网络访问"></a>跨源网络访问</h2><p>同源策略控制了不同源之间的交互，例如在使用<code>XMLHttpRequest</code> 或 <code>&lt;img&gt;</code> 标签时则会受到同源策略的约束。这些交互通常分为三类：</p><ul><li>通常允许跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。</li><li>通常允许跨域资源嵌入（Cross-origin embedding）。之后下面会举例说明。</li><li>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或availability of an embedded resource.</li></ul><p>以下是可能嵌入跨源的资源的一些示例：</p><ul><li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。</li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code> 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type 消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。</li><li><code>&lt;img&gt;</code>嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,…</li><li><code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 嵌入多媒体资源。</li><li><code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code> 和 <code>&lt;applet&gt;</code> 的插件。</li><li>@font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。</li><li><code>&lt;frame&gt;</code> 和 <code>&lt;iframe&gt;</code> 载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。</li></ul><h3 id="如何允许跨源访问"><a href="#如何允许跨源访问" class="headerlink" title="如何允许跨源访问"></a>如何允许跨源访问</h3><p>使用 CORS 允许跨源访问。</p><h3 id="如何阻止跨源访问"><a href="#如何阻止跨源访问" class="headerlink" title="如何阻止跨源访问"></a>如何阻止跨源访问</h3><ul><li>阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。</li><li>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。</li><li>阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 Conten-Type 消息头。例如，如果您在HTML文档中指定 <code>&lt;script&gt;</code> 标记，则浏览器将尝试将HTML解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入。</li></ul><h2 id="跨源脚本API访问"><a href="#跨源脚本API访问" class="headerlink" title="跨源脚本API访问"></a>跨源脚本API访问</h2><p>Javascript的APIs中，如 iframe.contentWindow, window.parent, window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制，如下两节所述。</p><p>为了在不同源中文档进一步交流，可以使用window.postMessage。</p><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>规范:  <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-window">http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-window</a>.</p><p>允许以下对 Window 属性的跨源访问：</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>window.blur<br>window.close<br>window.focus<br>window.postMessage</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>window.closed    只读<br>window.frames    只读<br>window.length    只读<br>window.location    读/写<br>window.opener    只读<br>window.parent    只读<br>window.self    只读<br>window.top    只读<br>window.window    只读</p><p>某些浏览器允许访问比规范允许的更多属性。</p><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><p>规范:  <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-location">http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-location</a>.</p><p>允许以下对 Location 属性的跨源访问：</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>location.replace</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>URLUtils.href    只写</p><p>某些浏览器允许访问比规范允许的更多属性。</p><h2 id="跨源数据存储访问"><a href="#跨源数据存储访问" class="headerlink" title="跨源数据存储访问"></a>跨源数据存储访问</h2><p>存储在浏览器中的数据，如localStorage和IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。</p><p>Cookies 使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可。Firefox 和 Chrome 使用 Public Suffix List 决定一个域是否是一个公共后缀（public suffix）。Internet Explorer使用其自己的内部方法来确定域是否是公共后缀。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains) 访问 cookie。设置 cookie 时，你可以使用Domain，Path，Secure，和Http-Only标记来限定其访问性。读取 cookie 时，不会知晓它的出处。 即使您仅使用安全的https连接，您看到的任何cookie都可能使用不安全的连接进行设置。</p><p><strong>本文转载自 MDN web docs，<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" rel="nofollow">《浏览器的同源策略》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端常见跨域解决方案</title>
      <link href="/interview/docs/04.Web/13.%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/interview/docs/04.Web/13.%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前端常见跨域解决方案"><a href="#前端常见跨域解决方案" class="headerlink" title="前端常见跨域解决方案"></a>前端常见跨域解决方案</h1><h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><h3 id="广义的跨域："><a href="#广义的跨域：" class="headerlink" title="广义的跨域："></a>广义的跨域：</h3><p>1.) 资源跳转： A链接、重定向、表单提交<br>2.) 资源嵌入： <code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;frame&gt;</code>等dom标签，还有样式中background:url()、@font-face()等文件外链<br>3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等<br>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p><h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><p>1.) Cookie、LocalStorage 和 IndexDB 无法读取<br>2.) DOM 和 Js对象无法获得<br>3.) AJAX 请求不能发送</p><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h2><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><code>http://www.domain.com/a.js</code> <code>http://www.domain.com/b.js</code> <code>http://www.domain.com/lab/c.js</code></td><td>同一域名，不同文件或路径</td><td>允许</td></tr><tr><td><code>http://www.domain.com:8000/a.js</code> <code>http://www.domain.com/b.js</code></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><code>http://www.domain.com/a.js</code> <code>https://www.domain.com/b.js</code></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><code>http://www.domain.com/a.js</code> <code>http://192.168.4.12/b.js</code></td><td>域名和域名对应相同ip</td><td>不允许</td></tr><tr><td><code>http://www.domain.com/a.js</code> <code>http://x.domain.com/b.js</code> <code>http://domain.com/c.js</code></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><code>http://www.domain1.com/a.js</code> <code>http://www.domain2.com/b.js</code></td><td>不同域名</td><td>不允许</td></tr></tbody></table><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="通过jsonp跨域"><a href="#通过jsonp跨域" class="headerlink" title="通过jsonp跨域"></a>通过jsonp跨域</h3><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><h4 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调执行函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onBack</span>(<span class="params">res</span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端返回如下（返回时即执行全局函数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBack</span>(&#123;<span class="string">&quot;status&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;admin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="jquery-ajax："><a href="#jquery-ajax：" class="headerlink" title="jquery ajax："></a>jquery ajax：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;jsonp&#x27;</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    <span class="attr">jsonpCallback</span>: <span class="string">&quot;onBack&quot;</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="vue-js："><a href="#vue-js：" class="headerlink" title="vue.js："></a>vue.js：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">jsonp</span>(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">jsonp</span>: <span class="string">&#x27;onBack&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>后端node.js代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.<span class="title function_">parse</span>(req.<span class="property">url</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span> &#125;);</span><br><span class="line">    res.<span class="title function_">write</span>(fn + <span class="string">&#x27;(&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><p>jsonp缺点：只能实现get一种请求。</p><h3 id="document-domain-iframe跨域"><a href="#document-domain-iframe跨域" class="headerlink" title="document.domain + iframe跨域"></a>document.domain + iframe跨域</h3><p>此方案仅限主域相同，子域不同的跨域应用场景。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>1.）父窗口：(<a href="http://www.domain.com/a.html">http://www.domain.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.）子窗口：(<a href="http://child.domain.com/b.html">http://child.domain.com/b.html</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;domain.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 获取父窗口中变量</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">user</span>);</span><br></pre></td></tr></table></figure><h3 id="location-hash-iframe跨域"><a href="#location-hash-iframe跨域" class="headerlink" title="location.hash + iframe跨域"></a>location.hash + iframe跨域</h3><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 向b.html传hash值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">src</span> = iframe.<span class="property">src</span> + <span class="string">&#x27;#user=admin&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 开放给同域c.html的回调方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">onCallback</span>(<span class="params">res</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;data from c.html ---&gt; &#x27;</span> + res);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.）b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain1.com/c.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">src</span> = iframe.<span class="property">src</span> + location.<span class="property">hash</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.）c.html：(<a href="http://www.domain1.com/c.html">http://www.domain1.com/c.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听b.html传来的hash值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">parent</span>.<span class="title function_">onCallback</span>(<span class="string">&#x27;hello: &#x27;</span> + location.<span class="property">hash</span>.<span class="title function_">replace</span>(<span class="string">&#x27;#user=&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="window-name-iframe跨域"><a href="#window-name-iframe跨域" class="headerlink" title="window.name + iframe跨域"></a>window.name + iframe跨域</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">function</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载跨域页面</span></span><br><span class="line">    iframe.<span class="property">src</span> = url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">            <span class="title function_">callback</span>(iframe.<span class="property">contentWindow</span>.<span class="property">name</span>);</span><br><span class="line">            <span class="title function_">destoryFrame</span>();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">            iframe.<span class="property">contentWindow</span>.<span class="property">location</span> = <span class="string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">destoryFrame</span>(<span class="params"></span>) &#123;</span><br><span class="line">        iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        iframe.<span class="property">contentWindow</span>.<span class="title function_">close</span>();</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求跨域b页面数据</span></span><br><span class="line"><span class="title function_">proxy</span>(<span class="string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.）proxy.html：(<a href="http://www.domain1.com/proxy">http://www.domain1.com/proxy</a>….<br>中间代理页，与a.html同域，内容为空即可。</p><p>3.）b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;This is domain2 data!&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="postMessage跨域"><a href="#postMessage跨域" class="headerlink" title="postMessage跨域"></a>postMessage跨域</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为<code>&quot;*&quot;</code>，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p><p>1.）a.html：(<a href="http://www.domain1.com/a.html">http://www.domain1.com/a.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">       </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;aym&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 向domain2传送跨域数据</span></span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.）b.html：(<a href="http://www.domain2.com/b.html">http://www.domain2.com/b.html</a>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (data) &#123;</span></span><br><span class="line"><span class="language-javascript">            data.<span class="property">number</span> = <span class="number">16</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h3><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p><p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><p>1、 前端设置：</p><p>1.）原生ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.）jQuery ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="attr">xhrFields</span>: &#123;</span><br><span class="line">       <span class="attr">withCredentials</span>: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">crossDomain</span>: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.）vue框架</p><p>a.) axios设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>b.) vue-resource设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">http</span>.<span class="property">options</span>.<span class="property">credentials</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>2、 服务端设置：<br>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>1.）Java后台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment"> * 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&#x27;/&#x27;</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://www.domain1.com&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许前端带认证cookie：启用此项后，上面的域名不能为&#x27;*&#x27;，必须指定具体的域名，否则浏览器会提示</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;Content-Type,X-Requested-With&quot;</span>);</span><br></pre></td></tr></table></figure><p>2.）Nodejs后台示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.<span class="title function_">addListener</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.<span class="title function_">addListener</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        postData = qs.<span class="title function_">parse</span>(postData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://www.domain1.com&#x27;</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(postData));</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h3><p>1、 nginx配置解决iconfont跨域<br>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">  <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 nginx反向代理接口跨域<br>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#proxy服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin http://www.domain1.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.) 前端代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><p>2.) Nodejs后台示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.<span class="title function_">parse</span>(req.<span class="property">url</span>.<span class="title function_">substring</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params));</span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="Nodejs中间件代理跨域"><a href="#Nodejs中间件代理跨域" class="headerlink" title="Nodejs中间件代理跨域"></a>Nodejs中间件代理跨域</h3><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><p>1、 非vue框架的跨域（2次跨域）<br>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><p>1.）前端代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问http-proxy-middleware代理服务器</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><p>2.）中间件服务器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, <span class="title function_">proxy</span>(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,</span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    <span class="attr">onProxyRes</span>: <span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) &#123;</span><br><span class="line">        res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">        res.<span class="title function_">header</span>(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure><p>3.）Nodejs后台同（六：nginx）</p><p>2、 vue框架的跨域（1次跨域）<br>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">proxy</span>: [&#123;</span><br><span class="line">            <span class="attr">context</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">secure</span>: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            <span class="attr">cookieDomainRewrite</span>: <span class="string">&#x27;www.domain1.com&#x27;</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        <span class="attr">noInfo</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h3><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.）前端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> socket = <span class="title function_">io</span>(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="language-javascript">socket.<span class="title function_">on</span>(<span class="string">&#x27;connect&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="language-javascript">    socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="language-javascript">    socket.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server socket has closed.&#x27;</span>); </span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    socket.<span class="title function_">send</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.）Nodejs socket后台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.<span class="title function_">listen</span>(server).<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span>(<span class="params">client</span>) &#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        client.<span class="title function_">send</span>(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Client socket has closed.&#x27;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>本文转载自 安静de沉淀的专栏，<a href="https://segmentfault.com/a/1190000011145364" rel="nofollow">《前端常见跨域解决方案》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 闭包</title>
      <link href="/interview/docs/04.Web/14.JavaScript%E9%97%AD%E5%8C%85/"/>
      <url>/interview/docs/04.Web/14.JavaScript%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h1><p>闭包是函数和声明该函数的词法环境的组合。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>考虑如下情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>; <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">displayName</span>(<span class="params"></span>) &#123; <span class="comment">// displayName() 是内部函数,一个闭包</span></span><br><span class="line">        <span class="title function_">alert</span>(name); <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">displayName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><p>init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在 init() 里的内部函数，仅在该函数体内可用。displayName() 内没有自己的局部变量，然而它可以访问到外部函数的变量，所以 displayName() 可以使用父函数 init() 中声明的变量 name 。但是，如果有同名变量 name 在 displayName() 中被定义，则会使用 displayName() 中定义的 name 。</p><p>运行代码可以发现 displayName() 内的 alert() 语句成功的显示了在其父函数中声明的 name 变量的值。这个词法作用域的例子介绍了引擎是如何解析函数嵌套中的变量的。词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>现在来考虑如下例子 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">displayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = <span class="title function_">makeFunc</span>();</span><br><span class="line"><span class="title function_">myFunc</span>();</span><br></pre></td></tr></table></figure><p>运行这段代码和之前的 init() 示例的效果完全一样。其中的不同 — 也是有意思的地方 — 在于内部函数 displayName() 在执行前，被外部函数返回。</p><p>第一眼看上去，也许不能直观的看出这段代码能够正常运行。在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。一旦 makeFunc() 执行完毕，我们会认为 name 变量将不能被访问。然而，因为代码运行得没问题，所以很显然在 JavaScript 中并不是这样的。</p><p>这个谜题的答案是，JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。在我们的例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name 。由此，当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。</p><p>下面是一个更有意思的示例 — makeAdder 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeAdder</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = <span class="title function_">makeAdder</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = <span class="title function_">makeAdder</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add10</span>(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。</p><p>从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p><p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p><h2 id="实用的闭包"><a href="#实用的闭包" class="headerlink" title="实用的闭包"></a>实用的闭包</h2><p>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p><p>因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。</p><p>在 Web 中，你想要这样做的情况特别常见。大部分我们所写的 JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。</p><p>假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如header）的字号：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的文本尺寸调整按钮可以修改 body 元素的 font-size 属性，由于我们使用相对单位，页面中的其它元素也会相应地调整。</p><p>以下是 JavaScript：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeSizer</span>(<span class="params">size</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = size + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size12 = <span class="title function_">makeSizer</span>(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> size14 = <span class="title function_">makeSizer</span>(<span class="number">14</span>);</span><br><span class="line"><span class="keyword">var</span> size16 = <span class="title function_">makeSizer</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>size12，size14 和 size16 三个函数将分别把 body 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-12&#x27;</span>).<span class="property">onclick</span> = size12;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-14&#x27;</span>).<span class="property">onclick</span> = size14;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;size-16&#x27;</span>).<span class="property">onclick</span> = size16;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;size-12&quot;</span>&gt;</span>12<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;size-14&quot;</span>&gt;</span>14<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">id</span>=<span class="string">&quot;size-16&quot;</span>&gt;</span>16<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h2><p>编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p><p>而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p><p>下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br><span class="line"><span class="title class_">Counter</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="title class_">Counter</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 2 */</span></span><br><span class="line"><span class="title class_">Counter</span>.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure><p>在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。</p><p>该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。</p><p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。</p><blockquote><p>你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> makeCounter = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter1</span> = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter2</span> = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 2 */</span></span><br><span class="line"><span class="title class_">Counter1</span>.<span class="title function_">decrement</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter1</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Counter2</span>.<span class="title function_">value</span>()); <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure><p>请注意两个计数器 counter1 和 counter2 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 privateCounter 。</p><p>每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。</p><blockquote><p>以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。</p></blockquote><h2 id="在循环中创建闭包：一个常见错误"><a href="#在循环中创建闭包：一个常见错误" class="headerlink" title="在循环中创建闭包：一个常见错误"></a>在循环中创建闭包：一个常见错误</h2><p>在 ECMAScript 2015 引入 let 关键字 之前，在循环中有一个常见的闭包创建问题。参考下面的示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;help&quot;</span>&gt;</span>Helpful notes will appear here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showHelp</span>(<span class="params">help</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;help&#x27;</span>).<span class="property">innerHTML</span> = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupHelp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(item.<span class="property">id</span>).<span class="property">onfocus</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">showHelp</span>(item.<span class="property">help</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setupHelp</span>();</span><br></pre></td></tr></table></figure><p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的input 的 ID。通过循环这三项定义，依次为相应input添加了一个 onfocus  事件处理函数，以便显示帮助信息。</p><p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个input上，显示的都是关于年龄的信息。</p><p>原因是赋值给 onfocus 的是闭包。这些闭包是由他们的函数定义和在 setupHelp 作用域中捕获的环境所组成的。这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量item。当onfocus的回调执行时，item.help的值被决定。由于循环在事件触发之前早已执行完毕，变量对象item（被三个闭包所共享）已经指向了helpText的最后一项。</p><p>解决这个问题的一种方案是使用更多的闭包：特别是使用前面所述的函数工厂：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showHelp</span>(<span class="params">help</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;help&#x27;</span>).<span class="property">innerHTML</span> = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeHelpCallback</span>(<span class="params">help</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">showHelp</span>(help);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupHelp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(item.<span class="property">id</span>).<span class="property">onfocus</span> = <span class="title function_">makeHelpCallback</span>(item.<span class="property">help</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setupHelp</span>();</span><br></pre></td></tr></table></figure><p>避免使用过多的闭包，可以用let关键词：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showHelp</span>(<span class="params">help</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;help&#x27;</span>).<span class="property">innerHTML</span> = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupHelp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = helpText[i];</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(item.<span class="property">id</span>).<span class="property">onfocus</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">showHelp</span>(item.<span class="property">help</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setupHelp</span>();</span><br></pre></td></tr></table></figure><p>这个例子使用let而不是var，因此每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。</p><h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><p>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</p><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。</p><p>考虑以下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getMessage</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getMessage</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但我们不建议重新定义原型。可改成如下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyObject</span>(<span class="params">name, message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MyObject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMessage</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在前面的两个示例中，继承的原型可以为所有对象共享，不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。</p><p><strong>本文转载自 MDN web docs，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" rel="nofollow">《JavaScript 闭包》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-经典算法题</title>
      <link href="/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/interview/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09.%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="经典算法题"><a href="#经典算法题" class="headerlink" title="经典算法题"></a>经典算法题</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WEB QA</title>
      <link href="/interview/docs/04.Web/QA/"/>
      <url>/interview/docs/04.Web/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="Web-篇"><a href="#Web-篇" class="headerlink" title="Web 篇"></a>Web 篇</h2><h3 id="SEO-有哪些需要注意的"><a href="#SEO-有哪些需要注意的" class="headerlink" title="SEO 有哪些需要注意的"></a>SEO 有哪些需要注意的</h3><p>合理的 title、description、keywords</p><p>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</p><p>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</p><p>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p><p>少用 iframe：搜索引擎不会抓取 iframe 中的内容</p><p>非装饰性图片必须加 alt</p><p>提高网站速度：网站速度是搜索引擎排序的一个重要指标</p><p>拓展阅读<a href="./01.%E5%88%9D%E6%8E%A2SEO.md">《初探 SEO》</a></p><h3 id="img-标签的-title-和-alt-有什么区别"><a href="#img-标签的-title-和-alt-有什么区别" class="headerlink" title="img 标签的 title 和 alt 有什么区别"></a>img 标签的 title 和 alt 有什么区别</h3><p>title 属性规定关于元素的额外信息，这些信息通常会在鼠标移到元素上时显示一段提示文本</p><p>alt 是<code>&lt;img&gt;</code>标签的特有属性，是图片内容的等价描述。图片无法加载时显示。搜索引擎会重点分析</p><h3 id="CSS-选择器的分类"><a href="#CSS-选择器的分类" class="headerlink" title="CSS 选择器的分类"></a>CSS 选择器的分类</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-CSS%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="CSS选择器"></p><p>拓展阅读<a href="./02.CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB.md">《CSS选择器的分类》</a></p><h3 id="CSS-sprite-是什么，有什么优缺点"><a href="#CSS-sprite-是什么，有什么优缺点" class="headerlink" title="CSS sprite 是什么，有什么优缺点"></a>CSS sprite 是什么，有什么优缺点</h3><p>概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。</p><ul><li>优点</li></ul><p>减少 HTTP 请求数，极大地提高页面加载速度</p><p>增加图片信息重复度，提高压缩比，减少图片大小</p><p>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p><ul><li>缺点</li></ul><p>图片合并麻烦</p><p>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</p><p>拓展阅读<a href="./03.CSS-Sprite%E7%9A%84%E5%BA%94%E7%94%A8.md">《雪碧图CSS Sprite的应用》</a></p><h3 id="display-none-与-visibility-hidden-的区别"><a href="#display-none-与-visibility-hidden-的区别" class="headerlink" title="display: none 与 visibility: hidden 的区别"></a>display: none 与 visibility: hidden 的区别</h3><ul><li>用途</li></ul><p>通过为属性设置一个值来影响用户代理显示的方式</p><ul><li>区别</li></ul><p>display:none 会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden 不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</p><p>display: none 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden 是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible 可以让子孙节点显式</p><p>修改常规流中元素的 display 通常会造成文档重排。修改 visibility 属性只会造成本元素的重绘</p><p>读屏器不会读取 display: none 元素内容；会读取 visibility: hidden 元素内容</p><h3 id="display-block-和-display-inline-的区别"><a href="#display-block-和-display-inline-的区别" class="headerlink" title="display: block 和 display: inline 的区别"></a>display: block 和 display: inline 的区别</h3><ul><li>block 元素特点</li></ul><p>处于常规流中时，如果 width 没有设置，会自动填充满父容器</p><p>可以应用 margin/padding</p><p>在没有设置高度的情况下会扩展高度以包含常规流中的子元素 </p><p>处于常规流中时布局时在前后元素位置之间（独占一个水平空间）</p><p>忽略 vertical-align</p><ul><li>inline 元素特点</li></ul><p>水平方向上根据 direction 依次布局</p><p>不会在元素前后进行换行</p><p>受 white-space 控制</p><p>margin/padding 在竖直方向上无效，水平方向上有效</p><p>width/height 属性对非替换行内元素无效，宽度由元素内容决定</p><p>非替换行内元素的行框高由 line-height 确定，替换行内元素的行框高由 height,margin,padding,border 决定</p><p>浮动或绝对定位时会转换为 block</p><p>vertical-align 属性生效</p><h3 id="CSS-文件、style-标签、行内-style-属性优先级"><a href="#CSS-文件、style-标签、行内-style-属性优先级" class="headerlink" title="CSS 文件、style 标签、行内 style 属性优先级"></a>CSS 文件、style 标签、行内 style 属性优先级</h3><p>最近的祖先样式比其他祖先样式优先级高</p><p>“直接样式”比”祖先样式”优先级高</p><h3 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h3><p>link 是 HTML 方式， @import 是 CSS 方式</p><p>link 最大限度支持并行下载，@import 过多嵌套导致串行下载，出现FOUC</p><p>link 可以通过 rel=”alternate stylesheet”指定候选样式</p><p>浏览器对 link 支持早于 @import，可以使用 @import 对老浏览器隐藏样式</p><p>@import 必须在样式规则之前，可以在 css 文件中引用其他文件</p><p>总体来说：link 优于 @import</p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-css-CSS%E6%A1%86%E6%A8%A1%E5%9E%8B.jpg" alt="CSS框模型"></p><p>具备属性：内容(content)、填充(padding)、边框(border)、边界(margin)</p><p>拓展阅读<a href="./04.CSS%E7%9B%92%E6%A8%A1%E5%9E%8B.md">《CSS盒模型》</a></p><h3 id="容器包含若干浮动元素时如何清理-包含-浮动"><a href="#容器包含若干浮动元素时如何清理-包含-浮动" class="headerlink" title="容器包含若干浮动元素时如何清理(包含)浮动"></a>容器包含若干浮动元素时如何清理(包含)浮动</h3><p>容器元素闭合标签前添加额外元素并设置clear: both</p><p>父元素触发块级格式化上下文(见块级可视化上下文部分)</p><p>设置容器元素伪元素进行清理推荐的清理浮动方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在标准浏览器下使用</span><br><span class="line">* 1 content内容为空格用于修复opera下文档中出现</span><br><span class="line">*   contenteditable属性时在清理浮动元素上下的空白</span><br><span class="line">* 2 使用display使用table而不是block：可以防止容器和</span><br><span class="line">*   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7</span><br><span class="line">*   zoom: 1;一致</span><br><span class="line">**/</span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: &quot; &quot;; /* 1 */</span><br><span class="line">    display: table; /* 2 */</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何水平居中一个元素"><a href="#如何水平居中一个元素" class="headerlink" title="如何水平居中一个元素"></a>如何水平居中一个元素</h3><p>被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的</p><p>定宽和块状可以通过设置 “左右margin” 值为 “auto” 实现居中</p><p>不定宽块状使用 float:left 实现居中</p><p>拓展阅读<a href="./05.CSS%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E8%AE%BE%E7%BD%AE.md">《CSS 水平居中设置》</a></p><h3 id="如何竖直居中一个元素"><a href="#如何竖直居中一个元素" class="headerlink" title="如何竖直居中一个元素"></a>如何竖直居中一个元素</h3><p>父元素高度确定的单行文本</p><p>父元素高度确定的多行文本</p><p>拓展阅读<a href="./06.CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E8%AE%BE%E7%BD%AE.md">《CSS 垂直居中设置》</a></p><h3 id="flex-与-CSS-盒子模型有什么区别"><a href="#flex-与-CSS-盒子模型有什么区别" class="headerlink" title="flex 与 CSS 盒子模型有什么区别"></a>flex 与 CSS 盒子模型有什么区别</h3><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现</p><p>Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能</p><p>拓展阅读 <a href="./07.flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.md">《flex 布局的基本概念》</a></p><h3 id="Position-属性"><a href="#Position-属性" class="headerlink" title="Position 属性"></a>Position 属性</h3><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素</td></tr><tr><td>static</td><td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 position 属性的值</td></tr></tbody></table><p>拓展阅读 <a href="./08.CSS-Position%E5%AD%A6%E4%B9%A0.md">《CSS Position学习》</a></p><h3 id="PNG-GIF-JPG-的区别及如何选"><a href="#PNG-GIF-JPG-的区别及如何选" class="headerlink" title="PNG,GIF,JPG 的区别及如何选"></a>PNG,GIF,JPG 的区别及如何选</h3><ul><li>GIF</li></ul><p>8位像素，256色；无损压缩；支持简单动画；支持boolean透明；适合简单动画</p><ul><li>JPEG</li></ul><p>颜色限于256；有损压缩；可控制压缩质量；不支持透明；适合照片</p><ul><li>PNG</li></ul><p>有PNG8和truecolor PNG；PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画；适合图标、背景、按钮</p><h3 id="为什么把-JavaScript-文件放在-Html-底部"><a href="#为什么把-JavaScript-文件放在-Html-底部" class="headerlink" title="为什么把 JavaScript 文件放在 Html 底部"></a>为什么把 JavaScript 文件放在 Html 底部</h3><p>脚本会阻塞页面其他资源的下载，因此推荐将所有<code>&lt;script&gt;</code>标签尽可能放到<code>&lt;body&gt;</code>标签的底部，以尽量减少对整个页面下载的影响</p><p>拓展阅读 <a href="./09.JavaScript%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C.md">《JavaScript 的性能优化：加载和执行》</a></p><h3 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="JavaScript 数据类型"></p><p>拓展阅读 <a href="./10.JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md">《JavaScript 数据类型和数据结构》</a></p><h3 id="JavaScript-操作-DOM-的方法有哪些"><a href="#JavaScript-操作-DOM-的方法有哪些" class="headerlink" title="JavaScript 操作 DOM 的方法有哪些"></a>JavaScript 操作 DOM 的方法有哪些</h3><p>获取节点的方法getElementById、getElementsByClassName、getElementsByTagName、 getElementsByName、querySelector、querySelectorAll,对元素属性进行操作的 getAttribute、 setAttribute、removeAttribute方法，对节点进行增删改的appendChild、insertBefore、replaceChild、removeChild、 createElement等</p><p>拓展阅读 <a href="./11.JavaScript%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8%E7%9A%84API.md">《JavaScript操作DOM常用的API》</a></p><h3 id="JavaScript-字符串方法有哪些"><a href="#JavaScript-字符串方法有哪些" class="headerlink" title="JavaScript 字符串方法有哪些"></a>JavaScript 字符串方法有哪些</h3><p>简单分为获取类方法，获取类方法有charAt方法用来获取指定位置的字符，获取指定位置字符的unicode编码的charCodeAt方法， 与之相反的fromCharCode方法，通过传入的unicode返回字符串。查找类方法有indexof()、lastIndexOf()、search()、match() 方法。截取类的方法有substring、slice、substr三个方法，其他的还有replace、split、toLowerCase、toUpperCase方法</p><h3 id="JavaScript-字符串截取方法有哪些？有什么区别"><a href="#JavaScript-字符串截取方法有哪些？有什么区别" class="headerlink" title="JavaScript 字符串截取方法有哪些？有什么区别"></a>JavaScript 字符串截取方法有哪些？有什么区别</h3><p>js字符串截取方法有substring、slice、substr三个方法，substring和slice都是指定截取的首尾索引值，不同的是传递负值的时候 substring会当做0来处理，而slice传入负值的规则是-1指最后一个字符，substr方法则是第一个参数是开始截取的字符串，第二个是截取的字符数量， 和slice类似，传入负值也是从尾部算起的</p><h3 id="setTimeout-和-setInterval-的区别"><a href="#setTimeout-和-setInterval-的区别" class="headerlink" title="setTimeout 和 setInterval 的区别"></a>setTimeout 和 setInterval 的区别</h3><p>setTimeout表示间隔一段时间之后执行一次调用，而setInterval则是每间隔一段时间循环调用，直至clearInterval结束。 内存方面，setTimeout只需要进入一次队列，不会造成内存溢出，setInterval因为不计算代码执行时间，有可能同时执行多次代码， 导致内存溢出</p><h3 id="使用-new-操作符实例化一个对象的具体步骤"><a href="#使用-new-操作符实例化一个对象的具体步骤" class="headerlink" title="使用 new 操作符实例化一个对象的具体步骤"></a>使用 new 操作符实例化一个对象的具体步骤</h3><ul><li><p>构造一个新的对象</p></li><li><p>将构造函数的作用域赋给新对象（也就是说this指向了新的对象）</p></li><li><p>执行构造函数中的代码</p></li><li><p>返回新对象</p></li></ul><h3 id="如何实现-ajax-请求"><a href="#如何实现-ajax-请求" class="headerlink" title="如何实现 ajax 请求"></a>如何实现 ajax 请求</h3><p>通过实例化一个XMLHttpRequest对象得到一个实例，调用实例的open方法为这次 ajax请求设定相应的http方法、相应的地址和以及是否异步，当然大多数情况下我们都是选异步， 以异步为例，之后调用send方法ajax请求，这个方法可以设定需要发送的报文主体，然后通过 监听readystatechange事件，通过这个实例的readyState属性来判断这个ajax请求的状态，其中分为0,1,2,3,4这四种 状态，当状态为4的时候也就是接收数据完成的时候，这时候可以通过实例的status属性判断这个请求是否成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;aabb.php&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.<span class="property">readyState</span>==<span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.<span class="property">status</span>==<span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同源策略是什么"><a href="#同源策略是什么" class="headerlink" title="同源策略是什么"></a>同源策略是什么</h3><p>同源策略是指只有具有相同源的页面才能够共享数据，比如cookie，同源是指页面具有相同的协议、域名、端口号，有一项不同就不是同源。 有同源策略能够保证web网页的安全性</p><p>拓展阅读 <a href="./12.%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5.md">《浏览器的同源策略》</a></p><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><ul><li>通过 JSONP 跨域</li><li>document.domain + iframe 跨域</li><li>location.hash + iframe</li><li>window.name + iframe 跨域</li><li>postMessage 跨域</li><li>跨域资源共享（CORS）</li><li>nginx 代理跨域</li><li>nodejs 中间件代理跨域</li><li>WebSocket 协议跨域</li></ul><p>拓展阅读 <a href="./13.%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md">《前端常见跨域解决方案》</a></p><h3 id="引起内存泄漏的操作有哪些"><a href="#引起内存泄漏的操作有哪些" class="headerlink" title="引起内存泄漏的操作有哪些"></a>引起内存泄漏的操作有哪些</h3><ul><li><p>全局变量引起</p></li><li><p>闭包引起</p></li><li><p>dom清空，事件未清除</p></li><li><p>子元素存在引用</p></li><li><p>被遗忘的计时器</p></li></ul><h3 id="闭包理解及应用"><a href="#闭包理解及应用" class="headerlink" title="闭包理解及应用"></a>闭包理解及应用</h3><p>闭包是函数和声明该函数的词法环境的组合</p><p>应用</p><ul><li><p>定义事件行为</p></li><li><p>模拟私有方法，用于定义公共函数</p></li></ul><p>拓展阅读 <a href="./14.JavaScript%E9%97%AD%E5%8C%85.md">《JavaScript闭包》</a></p><h3 id="对-JavaScript-原型的理解"><a href="#对-JavaScript-原型的理解" class="headerlink" title="对 JavaScript 原型的理解"></a>对 JavaScript 原型的理解</h3><p>我们知道在es6之前，js没有类和继承的概念，js是通过原型来实现继承的。在js中一个构造函数默认自带有一个prototype属性， 这个的属性值是一个对象，同时这个prototype对象自带有一个constructor属性，这个属性指向这个构造函数，同时每一个实例 都有一个__proto__属性指向这个prototype对象，我们可以将这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查 这个实例中是否有这个方法，没有则会继续向上查找这个prototype对象是否有这个方法，刚刚我们说到prototype是一个对象， 那么也即是说这个是一个对象的实例，那么这个对象同样也会有一个__proto__属性指向对象的prototype对象</p><h3 id="对-JavaScript-模块化的理解"><a href="#对-JavaScript-模块化的理解" class="headerlink" title="对 JavaScript 模块化的理解"></a>对 JavaScript 模块化的理解</h3><p>在ES6出现之前，js没有标准的模块化概念，这也就造成了js多人写作开发容易造成全局污染的情况，以前我们可能会采用立即执行 函数、对象等方式来尽量减少变量这种情况，后面社区为了解决这个问题陆续提出了AMD规范和CMD规范，这里不同于Node.js的 CommonJS的原因在于服务端所有的模块都是存在于硬盘中的，加载和读取几乎是不需要时间的，而浏览器端因为加载速度取决于网速， 因此需要采用异步加载，AMD规范中使用define来定义一个模块，使用require方法来加载一个模块，现在ES6也推出了标准的模块 加载方案，通过export和import来导出和导入模块。</p><h3 id="如何判断网页中图片加载成功或者失败"><a href="#如何判断网页中图片加载成功或者失败" class="headerlink" title="如何判断网页中图片加载成功或者失败"></a>如何判断网页中图片加载成功或者失败</h3><p>使用onload事件运行加载成功，使用onerror事件判断失败</p><h3 id="如何实现懒加载"><a href="#如何实现懒加载" class="headerlink" title="如何实现懒加载"></a>如何实现懒加载</h3><p>懒加载就是根据用户的浏览需要记载内容，也就是在用户即将浏览完当前的内容时进行继续加载内容，这种技术常常用来加载图片的时候使用。我们判断用户是否即将浏览到底部之后进行在家内容 这时候可能会需要加载大量的内容，可以使用fragment来优化一下，因为大部分是使用滑动和滚轮来触发的，因此很有可能会不断触发，可以使用函数节流做一个优化，防止用户不断触发</p><h3 id="JSONP-原理"><a href="#JSONP-原理" class="headerlink" title="JSONP 原理"></a>JSONP 原理</h3><p>创建一个回调函数，然后在远程服务上调用这个函数并且将 JSON 数据形式作为参数传递，完成回调</p><p>拓展阅读 <a href="./15.jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.md">《jsonp的原理与简单实现》</a></p><h3 id="Cookie-读写"><a href="#Cookie-读写" class="headerlink" title="Cookie 读写"></a>Cookie 读写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=oeschger&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;favorite_food=tripe&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="comment">// 显示: name=oeschger;favorite_food=tripe</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;test1=Hello&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;test2=World&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> myCookie = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">replace</span>(<span class="regexp">/(?:(?:^|.*;\s*)test2\s*\=\s*([^;]*).*$)|^.*$/</span>, <span class="string">&quot;$1&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(myCookie);</span><br><span class="line"><span class="comment">// 显示: World</span></span><br></pre></td></tr></table></figure><h3 id="渐进增强"><a href="#渐进增强" class="headerlink" title="渐进增强"></a>渐进增强</h3><p>渐进增强(英语：Progressive enhancement)是网页设计的一种策略，强调可访问性，语义 HTML 标记，外部样式表和脚本技术。渐进增强使用 Web 技术以分层的方式，允许所有人访问网页的基本内容和功能，使用任何浏览器或互联网连接，同时还给更先进的浏览器软件或更大的带宽提供了这些页面的一个增强版本</p><p>核心原则</p><ul><li><p>基本内容应该是被所有网络浏览器访问</p></li><li><p>基本功能应该是被所有网络浏览器访问</p></li><li><p>稀疏的，语义化的标记包含的所有内容</p></li><li><p>增强的布局是由外部链接的 CSS 提供</p></li><li><p>增强的行为是由外部链接的非侵入式 JavaScript 提供</p></li><li><p>最终用户的网络浏览器偏好被受到尊重</p></li></ul><h3 id="从浏览器地址栏输入-URL-到显示页面的步骤"><a href="#从浏览器地址栏输入-URL-到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入 URL 到显示页面的步骤"></a>从浏览器地址栏输入 URL 到显示页面的步骤</h3><h3 id="Vue-js-双向绑定原理"><a href="#Vue-js-双向绑定原理" class="headerlink" title="Vue.js 双向绑定原理"></a>Vue.js 双向绑定原理</h3><p>拓展阅读 <a href="./16.vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0.md">《vue的双向绑定原理及实现》</a></p><h3 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h3><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>浏览器单域名并发数限制、静态资源缓存 304 （If-Modified-Since 以及 Etag 原理）、多个小图标合并使用 position 定位技术 减少请求、静态资源合为单次请求 并压缩、CDN、静态资源延迟加载技术、预加载技术、keep-alive、CSS 在头部，JS 在尾部的优化（原理）</p><h3 id="新技术（了解）"><a href="#新技术（了解）" class="headerlink" title="新技术（了解）"></a>新技术（了解）</h3><p>ES6、模块化、打包、构建工具、vue、react、webpack、前端 MVVM</p><h3 id="简要介绍-ES6"><a href="#简要介绍-ES6" class="headerlink" title="简要介绍 ES6"></a>简要介绍 ES6</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jsonp的原理与简单实现</title>
      <link href="/interview/docs/04.Web/15.jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/interview/docs/04.Web/15.jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="jsonp的原理与简单实现"><a href="#jsonp的原理与简单实现" class="headerlink" title="jsonp的原理与简单实现"></a>jsonp的原理与简单实现</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p><p>其本质是利用了&lt; script src=”” &gt;&lt;/ script &gt;标签具有可跨域的特性，由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。<br>它只能以GET方式请求<br>一般将传递的 key 命名为 callback</p><h2 id="php服务器示例"><a href="#php服务器示例" class="headerlink" title="php服务器示例"></a>php服务器示例</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: text/javascript; charset=utf-8&#x27;</span>); </span><br><span class="line"><span class="comment">// 假设从数据库里取数据了</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">&quot;name&quot;</span>=&gt;<span class="string">&quot;js&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>=&gt;<span class="number">20</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 编码处理</span></span><br><span class="line"><span class="variable">$json</span> = <span class="title function_ invoke__">json_encode</span>(<span class="variable">$arr</span>);</span><br><span class="line"><span class="comment">//获取客户端的callback函数</span></span><br><span class="line"><span class="variable">$callback</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>];</span><br><span class="line"><span class="comment">//给接收到的函数传输入据$json作为参数, 输出到html页面运行该函数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$callback</span> . <span class="string">&#x27;(&#x27;</span> . <span class="variable">$json</span> . <span class="string">&#x27;)&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="客户端示例"><a href="#客户端示例" class="headerlink" title="客户端示例"></a>客户端示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonp = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">url, callback</span>) &#123;</span><br><span class="line"><span class="comment">//1. 创建一个script标签</span></span><br><span class="line"><span class="keyword">var</span> scriptElem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 把地址传进去</span></span><br><span class="line"><span class="keyword">var</span> callbackName = <span class="string">&quot;__callback__&quot;</span> + count++;</span><br><span class="line"><span class="keyword">var</span> jsonpUrl = url + <span class="string">&quot;?callback=&quot;</span> + callbackName;</span><br><span class="line">scriptElem.<span class="property">src</span> = jsonpUrl;</span><br><span class="line"><span class="comment">//3. 创建一个fn函数，用于接收返回的数据</span></span><br><span class="line"><span class="variable language_">window</span>[callbackName] = <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line"><span class="comment">//把数据传给想要用的人</span></span><br><span class="line"><span class="title function_">callback</span>(data);</span><br><span class="line"><span class="comment">//把我们创建的script标签删掉</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(scriptElem);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//4.把标签放到body，把请求发出去</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptElem);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="title function_">jsonp</span>(<span class="string">&#x27;./js.php&#x27;</span>,<span class="keyword">function</span> <span class="title function_">cs</span>(<span class="params">data</span>)&#123;</span><br><span class="line">data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出:{“name”:”js”,”age”:20}<br>注: 请在php服务器下运行</p><p><strong>本文转载自 HeartWalker’s Blog，<a href="http://heartwalker.cc/2016/07/06/jsonp的原理与简单实现/" rel="nofollow">《jsonp的原理与简单实现》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 连接的使用</title>
      <link href="/interview/docs/05.MySQL/01.MySQL%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/interview/docs/05.MySQL/01.MySQL%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-连接的使用"><a href="#MySQL-连接的使用" class="headerlink" title="MySQL 连接的使用"></a>MySQL 连接的使用</h1><p>在前几章节中，我们已经学会了如何在一张表中读取数据，这是相对简单的，但是在真正的应用中经常需要从多个数据表中读取数据。</p><p>本章节我们将向大家介绍如何使用 MySQL 的 JOIN 在两个或多个表中查询数据。</p><p>你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。</p><p>JOIN 按照功能大致分为如下三类：</p><ul><li>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</li><li>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</li><li>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。<br>本章节使用的数据库结构及数据下载：<a href="http://static.runoob.com/download/runoob-mysql-join-test.sql">runoob-mysql-join-test.sql</a>。</li></ul><h2 id="在命令提示符中使用-INNER-JOIN"><a href="#在命令提示符中使用-INNER-JOIN" class="headerlink" title="在命令提示符中使用 INNER JOIN"></a>在命令提示符中使用 INNER JOIN</h2><p>我们在RUNOOB数据库中有两张表 tcount_tbl 和 runoob_tbl。两张数据表数据如下：</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>尝试以下实例：</p><ul><li>测试实例数据</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; SELECT * FROM tcount_tbl;</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| runoob_author | runoob_count |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| 菜鸟教程  | 10           |</span><br><span class="line">| RUNOOB.COM    | 20           |</span><br><span class="line">| Google        | 22           |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; SELECT * from runoob_tbl;</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| runoob_id | runoob_title  | runoob_author | submission_date |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">| 1         | 学习 PHP    | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 2         | 学习 MySQL  | 菜鸟教程  | 2017-04-12      |</span><br><span class="line">| 3         | 学习 Java   | RUNOOB.COM    | 2015-05-01      |</span><br><span class="line">| 4         | 学习 Python | RUNOOB.COM    | 2016-03-06      |</span><br><span class="line">| 5         | 学习 C      | FK            | 2017-04-05      |</span><br><span class="line">+-----------+---------------+---------------+-----------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>接下来我们就使用MySQL的INNER JOIN(也可以省略 INNER 使用 JOIN，效果一样)来连接以上两张表来读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值：</p><ul><li>INNER JOIN</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>以上 SQL 语句等价于：</p><ul><li>WHERE 子句</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-join-01.gif" alt="mysql-join-图1"></p><h2 id="MySQL-LEFT-JOIN"><a href="#MySQL-LEFT-JOIN" class="headerlink" title="MySQL LEFT JOIN"></a>MySQL LEFT JOIN</h2><p>MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>尝试以下实例，以 runoob_tbl 为左表，tcount_tbl 为右表，理解 MySQL LEFT JOIN 的应用：</p><ul><li>LEFT JOIN</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| 5           | FK              | NULL           |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>以上实例中使用了 LEFT JOIN，该语句会读取左边的数据表 runoob_tbl 的所有选取的字段数据，即便在右侧表 tcount_tbl中 没有对应的 runoob_author 字段值。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-join-02.gif" alt="mysql-join-图2"></p><h2 id="MySQL-RIGHT-JOIN"><a href="#MySQL-RIGHT-JOIN" class="headerlink" title="MySQL RIGHT JOIN"></a>MySQL RIGHT JOIN</h2><p>MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>尝试以下实例，以 runoob_tbl 为左表，tcount_tbl 为右表，理解MySQL RIGHT JOIN的应用：</p><ul><li>RIGHT JOIN</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| a.runoob_id | a.runoob_author | b.runoob_count |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">| 1           | 菜鸟教程    | 10             |</span><br><span class="line">| 2           | 菜鸟教程    | 10             |</span><br><span class="line">| 3           | RUNOOB.COM      | 20             |</span><br><span class="line">| 4           | RUNOOB.COM      | 20             |</span><br><span class="line">| NULL        | NULL            | 22             |</span><br><span class="line">+-------------+-----------------+----------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line">以上实例中使用了 RIGHT JOIN，该语句会读取右边的数据表 tcount_tbl 的所有选取的字段数据，即便在左侧表 runoob_tbl 中没有对应的runoob_author 字段值。</span><br></pre></td></tr></table></figure><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-join-03.gif" alt="mysql-join-图3"></p><p><strong>本文转载自 菜鸟教程，<a href="http://www.runoob.com/mysql/mysql-join.html" rel="nofollow">《MySQL 连接的使用》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript操作DOM常用的API</title>
      <link href="/interview/docs/04.Web/11.JavaScript%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8%E7%9A%84API/"/>
      <url>/interview/docs/04.Web/11.JavaScript%E6%93%8D%E4%BD%9CDOM%E5%B8%B8%E7%94%A8%E7%9A%84API/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript操作DOM常用的API"><a href="#JavaScript操作DOM常用的API" class="headerlink" title="JavaScript操作DOM常用的API"></a>JavaScript操作DOM常用的API</h1><h2 id="1-什么是DOM"><a href="#1-什么是DOM" class="headerlink" title="1 什么是DOM"></a>1 什么是DOM</h2><p>文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。<br>文档对象模型 (DOM) 是对HTML文件的另一种展示，通俗地说，一个HTML 文件，我们可以用编辑器以代码的形式展示它，也可以用浏览器以页面的形式展示它，同一份文件通过不同的展示方式，就有了不一样的表现形式。而DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来，我们可以使用脚本或者程序语言通过DOM 来改变或者控制web页面。</p><h2 id="2-如何访问DOM"><a href="#2-如何访问DOM" class="headerlink" title="2 如何访问DOM"></a>2 如何访问DOM</h2><p>我们可以通过JavaScript 来调用document和window元素的API来操作文档或者获取文档的信息。</p><h2 id="3-Node"><a href="#3-Node" class="headerlink" title="3 Node"></a>3 Node</h2><p>Node 是一个接口，有许多接口都从Node 继承方法和属性：<br>Document, Element, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReference。<br>Node 有一个nodeType的属性表示Node 的类型，是一个整数，不同的值代表不同的节点类型。具体如下表所示：</p><ul><li>节点类型常量</li></ul><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Node.ELEMENT_NODE</td><td>1</td><td>一个元素节点，例如 <code>&lt;p&gt;</code> 和 <code>&lt;div&gt;</code></td></tr><tr><td>Node.TEXT_NODE</td><td>3</td><td>Element 或者 Attr 中实际的文字</td></tr><tr><td>Node.PROCESSING_INSTRUCTION_NODE</td><td>7</td><td>一个用于XML文档的 ProcessingInstruction ，例如 <code>&lt;?xml-stylesheet ... ?&gt;</code> 声明</td></tr><tr><td>Node.COMMENT_NODE</td><td>8</td><td>一个 Comment 节点</td></tr><tr><td>Node.DOCUMENT_NODE</td><td>9</td><td>一个 Document 节点</td></tr><tr><td>Node.DOCUMENT_TYPE_NODE</td><td>10</td><td>描述文档类型的 DocumentType 节点。例如 <code>&lt;!DOCTYPE html&gt; </code>就是用于 HTML5 的</td></tr><tr><td>Node.DOCUMENT_FRAGMENT_NODE</td><td>11</td><td>一个 DocumentFragment 节点</td></tr></tbody></table><ul><li>已弃用的节点类型常量</li></ul><table><thead><tr><th>常量</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Node.ATTRIBUTE_NODE</td><td>2</td><td>元素的耦合属性。在DOM4 规范里Node 接口将不再实现这个元素属性</td></tr><tr><td>Node.CDATA_SECTION_NODE</td><td>4</td><td>一个CDATASection。在DOM4 规范里被移除</td></tr><tr><td>Node.ENTITY_REFERENCE_NODE</td><td>5</td><td>一个XML 实体引用节点。在DOM4 规范里被移除</td></tr><tr><td>Node.ENTITY_NODE</td><td>6</td><td>一个XML <code>&lt;!ENTITY ...&gt;</code>节点。在DOM4 规范中被移除</td></tr><tr><td>Node.NOTATION_NODE</td><td>12</td><td>一个XML <code>&lt;!NOTATION ...&gt;</code>节点。在DOM4 规范里被移除</td></tr></tbody></table><p>假设我们要判断一个Node 是不是一个元素，通过查表可知元素的nodeType属性值为1，代码可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(X.<span class="property">nodeType</span> === <span class="number">1</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;X 是一个元素&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Node 类型中，比较常用的就是element，text，comment，document，document_fragment这几种类型。</p><h3 id="3-1-Element"><a href="#3-1-Element" class="headerlink" title="3.1 Element"></a>3.1 Element</h3><p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。Element有下面几条特性：<br>（1）nodeType为1<br>（2）nodeName为元素标签名，tagName也是返回标签名<br>（3）nodeValue为null<br>（4）parentNode可能是Document或Element<br>（5）子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</p><h3 id="3-2-Text"><a href="#3-2-Text" class="headerlink" title="3.2 Text"></a>3.2 Text</h3><p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性：<br>（1）nodeType为3<br>（2）nodeName为#text<br>（3）nodeValue为文本内容<br>（4）parentNode是一个Element<br>（5）没有子节点</p><h3 id="3-3-Comment"><a href="#3-3-Comment" class="headerlink" title="3.3 Comment"></a>3.3 Comment</h3><p>Comment表示HTML文档中的注释，它有下面的几种特征：<br>（1）nodeType为8<br>（2）nodeName为#comment<br>（3）nodeValue为注释的内容<br>（4）parentNode可能是Document或Element<br>（5）没有子节点</p><h3 id="3-4-Document"><a href="#3-4-Document" class="headerlink" title="3.4 Document"></a>3.4 Document</h3><p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性：<br>（1）nodeType为9<br>（2）nodeName为#document<br>（3）nodeValue为null<br>（4）parentNode为null<br>（5）子节点可能是一个DocumentType或Element</p><h3 id="3-5-DocumentFragment"><a href="#3-5-DocumentFragment" class="headerlink" title="3.5 DocumentFragment"></a>3.5 DocumentFragment</h3><p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性：<br>（1）nodeType为11<br>（2）nodeName为#document-fragment<br>（3）nodeValue为null<br>（4）parentNode为null</p><h2 id="4-节点创建型API"><a href="#4-节点创建型API" class="headerlink" title="4 节点创建型API"></a>4 节点创建型API</h2><p>用如其名，这类API是用来创建节点的</p><h3 id="4-1-createElement"><a href="#4-1-createElement" class="headerlink" title="4.1 createElement"></a>4.1 createElement</h3><p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tagName);</span><br></pre></td></tr></table></figure><p>使用createElement要注意：通过createElement创建的元素并不属于HTML文档，它只是创建出来，并未添加到HTML文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> elem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">elem.<span class="property">id</span> = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">elem.<span class="property">style</span> = <span class="string">&#x27;color: red&#x27;</span>;</span><br><span class="line">elem.<span class="property">innerHTML</span> = <span class="string">&#x27;我是新创建的节点&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(elem);</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-01.png" alt="JavaScript DOM 图1"></p><h3 id="4-2-createTextNode"><a href="#4-2-createTextNode" class="headerlink" title="4.2 createTextNode"></a>4.2 createTextNode</h3><p>createTextNode用来创建一个文本节点</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(data);</span><br></pre></td></tr></table></figure><p>createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;我是文本节点&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(node);</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-02.png" alt="JavaScript DOM 图2"></p><h3 id="4-3-cloneNode"><a href="#4-3-cloneNode" class="headerlink" title="4.3 cloneNode"></a>4.3 cloneNode</h3><p>cloneNode返回调用该方法的节点的一个副本</p><ul><li>语法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dupNode = node.<span class="title function_">cloneNode</span>(deep);</span><br></pre></td></tr></table></figure><p>node 将要被克隆的节点<br>dupNode 克隆生成的副本节点<br>deep（可选）是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身.</p><p>这里有几点要注意：<br>（1）和createElement一样，cloneNode创建的节点只是游离有HTML文档外的节点，要调用appendChild方法才能添加到文档树中<br>（2）如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id<br>（3）调用接收的deep参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同</p><ul><li>注意</li></ul><p>如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：<br>（1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件<br>（2）如果是内联方式绑定比如：<code>&lt;div onclick=&quot;showParent()&quot;&gt;&lt;/div&gt;</code>，这样的话，副本节点同样会触发事件。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    我是父元素的文本</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        我是子元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnCopy&quot;</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnCopy&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> parent2 = parent.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">  parent2.<span class="property">id</span> = <span class="string">&quot;parent2&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(parent2);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-03.png" alt="JavaScript DOM 图3"></p><h3 id="4-4-createDocumentFragment"><a href="#4-4-createDocumentFragment" class="headerlink" title="4.4 createDocumentFragment"></a>4.4 createDocumentFragment</h3><p>DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。<br>因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流(reflow)(对元素位置和几何上的计算)。因此，使用文档片段document fragments 通常会起到优化性能的作用。</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  (<span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">  &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>, li;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        li.<span class="property">textContent</span> = <span class="string">&#x27;第&#x27;</span>+(i+<span class="number">1</span>)+<span class="string">&#x27;个子节点&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        fragment.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    ul.<span class="title function_">appendChild</span>(fragment);</span></span><br><span class="line"><span class="language-javascript">  &#125;)();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果为：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-04.png" alt="JavaScript DOM 图4"></p><h3 id="4-5-节点创建型API总结"><a href="#4-5-节点创建型API总结" class="headerlink" title="4.5 节点创建型API总结"></a>4.5 节点创建型API总结</h3><p>节点创建型API主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：<br>（1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中<br>（2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题<br>（3）使用createDocumentFragment来解决添加大量节点时的性能问题</p><h2 id="5-页面修改型API"><a href="#5-页面修改型API" class="headerlink" title="5 页面修改型API"></a>5 页面修改型API</h2><p>前面我们提到节点创建型API，它们只是创建节点，并没有真正修改到页面内容，而是要调用·appendChild·来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。<br>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p><h3 id="5-1-appendChild"><a href="#5-1-appendChild" class="headerlink" title="5.1 appendChild"></a>5.1 appendChild</h3><p>appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.<span class="title function_">appendChild</span>(child);</span><br></pre></td></tr></table></figure><p>child节点将会作为parent节点的最后一个子节点。<br>appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。<br>如果child绑定了事件，被移动时，它依然绑定着该事件。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">    要被添加的节点</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    要移动的位置</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;btnMove&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;移动节点&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnMove&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> child = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;child&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent&quot;</span>).<span class="title function_">appendChild</span>(child);</span></span><br><span class="line"><span class="language-javascript">  &#125; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-05.gif" alt="JavaScript DOM 图5"></p><h3 id="5-2-insertBefore"><a href="#5-2-insertBefore" class="headerlink" title="5.2 insertBefore"></a>5.2 insertBefore</h3><p>insertBefore用来添加一个节点到一个参照节点之前</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.<span class="title function_">insertBefore</span>(newNode,refNode);</span><br></pre></td></tr></table></figure><p>parentNode表示新节点被添加后的父节点<br>newNode表示要添加的节点<br>refNode表示参照节点，新节点会添加到这个节点之前</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    父节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        子元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;insertNode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;插入节点&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> child = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;child&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;insertNode&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> newNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  newNode.<span class="property">textContent</span> = <span class="string">&quot;新节点&quot;</span></span></span><br><span class="line"><span class="language-javascript">  parent.<span class="title function_">insertBefore</span>(newNode,child);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-06.gif" alt="JavaScript DOM 图6"></p><p>关于第二个参数参照节点还有几个注意的地方：<br>（1）refNode是必传的，如果不传该参数会报错<br>（2）如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾</p><h3 id="5-3-removeChild"><a href="#5-3-removeChild" class="headerlink" title="5.3 removeChild"></a>5.3 removeChild</h3><p>删除指定的子节点并返回</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deletedChild = parent.<span class="title function_">removeChild</span>(node);</span><br></pre></td></tr></table></figure><p>deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。<br>注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node.<span class="property">parentNode</span>)&#123;</span><br><span class="line">​    node.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-07.gif" alt="JavaScript DOM 图7"></p><p>通过节点自己获取节点的父节点，然后将自身删除</p><h3 id="5-4-replaceChild"><a href="#5-4-replaceChild" class="headerlink" title="5.4 replaceChild"></a>5.4 replaceChild</h3><p>replaceChild用于使用一个节点替换另一个节点</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.replaceChild(newChild,oldChild);</span><br></pre></td></tr></table></figure><p>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置<br>oldChild是被替换的节点</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    父节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        子元素</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;insertNode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;替换节点&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> parent = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> child = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;child&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;insertNode&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> newNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  newNode.<span class="property">textContent</span> = <span class="string">&quot;新节点&quot;</span></span></span><br><span class="line"><span class="language-javascript">  parent.<span class="title function_">replaceChild</span>(newNode,child)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-08.gif" alt="JavaScript DOM 图8"></p><h3 id="5-5-页面修改型API总结"><a href="#5-5-页面修改型API总结" class="headerlink" title="5.5 页面修改型API总结"></a>5.5 页面修改型API总结</h3><p>页面修改型API主要是这四个接口，要注意几个特点：<br>（1）不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置<br>（2）节点本身绑定的事件会不会消失，会一直保留着。</p><h2 id="6-节点查询型API"><a href="#6-节点查询型API" class="headerlink" title="6 节点查询型API"></a>6 节点查询型API</h2><h3 id="6-1-document-getElementById"><a href="#6-1-document-getElementById" class="headerlink" title="6.1 document.getElementById"></a>6.1 document.getElementById</h3><p>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br></pre></td></tr></table></figure><p>使用这个接口有几点要注意：<br>（1）元素的Id是大小写敏感的，一定要写对元素的id<br>（2）HTML文档中可能存在多个id相同的元素，则返回第一个元素<br>（3）只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para1&quot;</span>&gt;</span>Some text here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeColor(&#x27;blue&#x27;);&quot;</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeColor(&#x27;red&#x27;);&quot;</span>&gt;</span>red<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params">newColor</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;para1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    elem.<span class="property">style</span>.<span class="property">color</span> = newColor;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-09.gif" alt="JavaScript DOM 图9"></p><h3 id="6-2-document-getElementsByTagName"><a href="#6-2-document-getElementsByTagName" class="headerlink" title="6.2 document.getElementsByTagName"></a>6.2 document.getElementsByTagName</h3><p>返回一个包括所有给定标签名称的元素的HTML集合HTMLCollection。 整个文件结构都会被搜索，包括根节点。返回的 HTML集合是动态的, 意味着它可以自动更新自己来保持和 DOM 树的同步而不用再次调用document.getElementsByTagName()</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(name);</span><br></pre></td></tr></table></figure><p>（1）如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率<br>（2）如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection<br>（3）name是一个代表元素的名称的字符串。特殊字符 <code>&quot;*&quot;</code> 代表了所有元素。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;显示数量&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnShowCount&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;新增div&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnAddDiv&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> divList = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnAddDiv&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  div.<span class="property">textContent</span> =<span class="string">&quot;div&quot;</span> + (divList.<span class="property">length</span>+<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnShowCount&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(divList.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。<br>运行结果：</p><h3 id="6-3-document-getElementsByName"><a href="#6-3-document-getElementsByName" class="headerlink" title="6.3 document.getElementsByName"></a>6.3 document.getElementsByName</h3><p>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(name) </span><br></pre></td></tr></table></figure><p>使用这个接口主要要注意几点：<br>（1）返回对象是一个即时的NodeList，它是随时变化的<br>（2）在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的<br>（3）在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">getElements</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">   &#123;</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">var</span> x=<span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;myInput&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">alert</span>(x.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;myInput&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">size</span>=<span class="string">&quot;20&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;myInput&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">size</span>=<span class="string">&quot;20&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;myInput&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">size</span>=<span class="string">&quot;20&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;getElements()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;How many elements named &#x27;myInput&#x27;?&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-10.gif" alt="JavaScript DOM 图10"></p><h3 id="6-4-document-getElementsByClassName"><a href="#6-4-document-getElementsByClassName" class="headerlink" title="6.4 document.getElementsByClassName"></a>6.4 document.getElementsByClassName</h3><p>这个API是根据元素的class返回一个即时的HTMLCollection</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(names); <span class="comment">// or:</span></span><br><span class="line"><span class="keyword">var</span> elements = rootElement.<span class="title function_">getElementsByClassName</span>(names);</span><br></pre></td></tr></table></figure><p>elements是一个实时集合，包含了找到的所有元素<br>names是一个字符串，表示要匹配的类名列表；类名通过空格分隔<br>getElementsByClassName可以在任何元素上调用，不仅仅是document。调用这个方法的元素将作为本次查找的根元素<br>这个接口有下面几点要注意：<br>（1）返回结果是一个即时的HTMLCollection，会随时根据文档结构变化<br>（2）IE9以下浏览器不支持<br>（3）如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;test1 test2&quot;</span>);</span><br></pre></td></tr></table></figure><p>例子：</p><p>获取所有class为 ‘test’ 的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure><p>获取所有class同时包括 ‘red’ 和 ‘test’ 的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;red test&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在id为’main’的元素的子节点中，获取所有class为’test’的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;main&#x27;</span>).<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure><p>我们还可以对任意的HTMLCollection 使用Array.prototype的方法，调用时传递HTMLCollection 作为方法的参数。这里我们将查找到所有class为’test’的div元素:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testElements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> testDivs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>.<span class="title function_">call</span>(testElements, <span class="keyword">function</span>(<span class="params">testElement</span>)&#123;</span><br><span class="line">​ <span class="keyword">return</span> testElement.<span class="property">nodeName</span> === <span class="string">&#x27;DIV&#x27;</span>;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-5-document-querySelector和document-querySelectorAll"><a href="#6-5-document-querySelector和document-querySelectorAll" class="headerlink" title="6.5 document.querySelector和document.querySelectorAll"></a>6.5 document.querySelector和document.querySelectorAll</h3><p>这两个API很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则</p><h4 id="6-5-1-document-querySelector"><a href="#6-5-1-document-querySelector" class="headerlink" title="6.5.1 document.querySelector"></a>6.5.1 document.querySelector</h4><p>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selectors);</span><br></pre></td></tr></table></figure><p>注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>第三级的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    同级的第二个div</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnGet&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取test元素&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnGet&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.test&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(element.<span class="property">textContent</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。<br>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-11.gif" alt="JavaScript DOM 图11"></p><h4 id="6-5-2-document-querySelectorAll"><a href="#6-5-2-document-querySelectorAll" class="headerlink" title="6.5.2 document.querySelectorAll"></a>6.5.2 document.querySelectorAll</h4><p>返回的是所有匹配的元素，而且可以匹配多个选择符<br>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elementList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(selectors);</span><br></pre></td></tr></table></figure><p>elementList是一个静态的NodeList类型的对象<br>selectors是一个由逗号连接的包含一个或多个CSS选择器的字符串<br>如果selectors参数中包含CSS伪元素,则返回一个空的elementList<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div.note, div.alert&quot;</span>);</span><br></pre></td></tr></table></figure><p>返回一个文档中所有的class为”note”或者”alert”的div元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    class为test</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    id为test</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;btnShow&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;显示内容&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btnShow&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;#test,.test&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,length = elements.<span class="property">length</span>;i&lt;length;i++)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(elements[i].<span class="property">textContent</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：<br>（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关<br>（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化<br>兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。</p><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-12.gif" alt="JavaScript DOM 图12"></p><h2 id="7-节点关系型API"><a href="#7-节点关系型API" class="headerlink" title="7 节点关系型API"></a>7 节点关系型API</h2><p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等</p><h3 id="7-1-父关系型API"><a href="#7-1-父关系型API" class="headerlink" title="7.1 父关系型API"></a>7.1 父关系型API</h3><h4 id="7-1-1-parentNode"><a href="#7-1-1-parentNode" class="headerlink" title="7.1.1 parentNode"></a>7.1.1 parentNode</h4><p>每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment</p><h4 id="7-1-2-parentElement"><a href="#7-1-2-parentElement" class="headerlink" title="7.1.2 parentElement"></a>7.1.2 parentElement</h4><p>返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p><h3 id="7-2-子关系型APPI"><a href="#7-2-子关系型APPI" class="headerlink" title="7.2 子关系型APPI"></a>7.2 子关系型APPI</h3><h4 id="7-2-1-childNodes"><a href="#7-2-1-childNodes" class="headerlink" title="7.2.1 childNodes"></a>7.2.1 childNodes</h4><p>返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等</p><h4 id="7-2-2-children："><a href="#7-2-2-children：" class="headerlink" title="7.2.2 children："></a>7.2.2 children：</h4><p>一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持<br>children属性为只读属性，对象类型为HTMLCollection，你可以使用elementNodeReference.children[1].nodeName来获取某个子元素的标签名称</p><h4 id="7-2-3-firstChild"><a href="#7-2-3-firstChild" class="headerlink" title="7.2.3 firstChild"></a>7.2.3 firstChild</h4><p>只读属性返回树中节点的第一个子节点，如果节点是无子节点，则返回 null</p><h4 id="7-2-4-lastChild"><a href="#7-2-4-lastChild" class="headerlink" title="7.2.4 lastChild"></a>7.2.4 lastChild</h4><p>返回当前节点的最后一个子节点。如果父节点为一个元素节点，则子节点通常为一个元素节点，或一个文本节点，或一个注释节点。如果没有子节点，则返回null</p><h4 id="7-2-5-hasChildNodes"><a href="#7-2-5-hasChildNodes" class="headerlink" title="7.2.5 hasChildNodes"></a>7.2.5 hasChildNodes</h4><p>返回一个布尔值,表明当前节点是否包含有子节点.</p><h3 id="7-3-兄弟关系型API"><a href="#7-3-兄弟关系型API" class="headerlink" title="7.3 兄弟关系型API"></a>7.3 兄弟关系型API</h3><h4 id="7-3-1-previousSibling"><a href="#7-3-1-previousSibling" class="headerlink" title="7.3.1 previousSibling"></a>7.3.1 previousSibling</h4><p>返回当前节点的前一个兄弟节点,没有则返回null<br>Gecko内核的浏览器会在源代码中标签内部有空白符的地方插入一个文本结点到文档中.因此,使用诸如Node.firstChild和Node.previousSibling之类的方法可能会引用到一个空白符文本节点, 而不是使用者所预期得到的节点</p><h4 id="7-3-2-previousElementSibling"><a href="#7-3-2-previousElementSibling" class="headerlink" title="7.3.2 previousElementSibling"></a>7.3.2 previousElementSibling</h4><p>previousElementSibling返回当前元素在其父元素的子元素节点中的前一个元素节点,如果该元素已经是第一个元素节点,则返回null,该属性是只读的。注意IE9以下浏览器不支持</p><h4 id="7-3-3-nextSibling"><a href="#7-3-3-nextSibling" class="headerlink" title="7.3.3 nextSibling"></a>7.3.3 nextSibling</h4><p>Node.nextSibling是一个只读属性，返回其父节点的childNodes列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回null<br>Gecko内核的浏览器会在源代码中标签内部有空白符的地方插入一个文本结点到文档中.因此,使用诸如Node.firstChild和Node.previousSibling之类的方法可能会引用到一个空白符文本节点, 而不是使用者所预期得到的节点</p><h4 id="7-3-4-nextElementSibling"><a href="#7-3-4-nextElementSibling" class="headerlink" title="7.3.4 nextElementSibling"></a>7.3.4 nextElementSibling</h4><p>nextElementSibling返回当前元素在其父元素的子元素节点中的后一个元素节点,如果该元素已经是最后一个元素节点,则返回null,该属性是只读的。注意IE9以下浏览器不支持</p><h2 id="8-元素属性型API"><a href="#8-元素属性型API" class="headerlink" title="8 元素属性型API"></a>8 元素属性型API</h2><h3 id="8-1-setAttribute"><a href="#8-1-setAttribute" class="headerlink" title="8.1 setAttribute"></a>8.1 setAttribute</h3><p>设置指定元素上的一个属性值。如果属性已经存在，则更新该值; 否则将添加一个新的属性用指定的名称和值</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(name, value);</span><br></pre></td></tr></table></figure><p>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span></span><br><span class="line"><span class="language-javascript">  div1.<span class="title function_">setAttribute</span>(<span class="string">&quot;align&quot;</span>, <span class="string">&quot;center&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-13.png" alt="JavaScript DOM 图13"></p><p>如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">element.<span class="property">id</span> = <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="8-2-getAttribute"><a href="#8-2-getAttribute" class="headerlink" title="8.2 getAttribute"></a>8.2 getAttribute</h3><p>getAttribute()返回元素上一个指定的属性值。如果指定的属性不存在，则返回null或””（空字符串）</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attribute = element.<span class="title function_">getAttribute</span>(attributeName);</span><br></pre></td></tr></table></figure><p>attribute是一个包含attributeName属性值的字符串。attributeName是你想要获取的属性值的属性名称</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> align = div1.<span class="title function_">getAttribute</span>(<span class="string">&quot;align&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(align);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-14.png" alt="JavaScript DOM 图14"></p><h3 id="8-3-removeAttribute"><a href="#8-3-removeAttribute" class="headerlink" title="8.3 removeAttribute"></a>8.3 removeAttribute</h3><p>removeAttribute()从指定的元素中删除一个属性</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">removeAttribute</span>(attrName)</span><br></pre></td></tr></table></figure><p>attrName是一个字符串，将要从元素中删除的属性名</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200px&quot;</span>&gt;</span>ABC</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  div.<span class="title function_">removeAttribute</span>(<span class="string">&quot;style&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在运行之前div有个style=”color:red”的属性，在运行之后这个属性就被删除了</p><p>运行结果：<br><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//web-javascript-dom-15.png" alt="JavaScript DOM 图15"></p><h2 id="9-元素样式型API"><a href="#9-元素样式型API" class="headerlink" title="9 元素样式型API"></a>9 元素样式型API</h2><h3 id="9-1-window-getComputedStyle"><a href="#9-1-window-getComputedStyle" class="headerlink" title="9.1 window.getComputedStyle"></a>9.1 window.getComputedStyle</h3><p>Window.getComputedStyle()方法给出应用活动样式表后的元素的所有CSS属性的值，并解析这些值可能包含的任何基本计算<br>假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(element[, pseudoElt]);</span><br></pre></td></tr></table></figure><p>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。<br>返回的style是一个CSSStyleDeclaration对象。<br>通过style可以访问到元素计算后的样式</p><h3 id="9-2-getBoundingClientRect"><a href="#9-2-getBoundingClientRect" class="headerlink" title="9.2 getBoundingClientRect"></a>9.2 getBoundingClientRect</h3><p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置</p><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clientRect = element.<span class="title function_">getBoundingClientRect</span>();</span><br></pre></td></tr></table></figure><p>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据</p><h3 id="9-3-直接修改元素的样式"><a href="#9-3-直接修改元素的样式" class="headerlink" title="9.3 直接修改元素的样式"></a>9.3 直接修改元素的样式</h3><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elem.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">elem.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;font-size&#x27;</span>, <span class="string">&#x27;16px&#x27;</span>);</span><br><span class="line">elem.<span class="property">style</span>.<span class="title function_">removeProperty</span>(<span class="string">&#x27;color&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="9-4-动态添加样式规则"><a href="#9-4-动态添加样式规则" class="headerlink" title="9.4 动态添加样式规则"></a>9.4 动态添加样式规则</h3><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">style.<span class="property">innerHTML</span> = <span class="string">&#x27;body&#123;color:red&#125; #top:hover&#123;background-color: red;color: white;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style););</span><br></pre></td></tr></table></figure><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10 总结"></a>10 总结</h2><p>JavaScript中的API太多了，将这些API记住并熟练使用对JavaScript的学习是有很大的提高</p><p><strong>本文转载自 YyzclYang/notes，<a href="https://github.com/YyzclYang/notes/issues/1" rel="nofollow">《JavaScript操作DOM常用的API》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL体系结构</title>
      <link href="/interview/docs/05.MySQL/02.MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/interview/docs/05.MySQL/02.MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><h2 id="第1章-MySQL服务器构成"><a href="#第1章-MySQL服务器构成" class="headerlink" title="第1章 MySQL服务器构成"></a>第1章 MySQL服务器构成</h2><h3 id="1-1-客户端与服务器端模型"><a href="#1-1-客户端与服务器端模型" class="headerlink" title="1.1 客户端与服务器端模型"></a>1.1 客户端与服务器端模型</h3><p>MySQL是一个典型的C/S模式，单进程多线程的服务结构。MySQL自带的客户端程序在/usr/local/mysql/bin下，如：mysql、 mysqladmin、mysqldump等；服务端程序是mysqld（即守护进程，二进制的程序）</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-01.png" alt="体系结构-图1"></p><h3 id="1-2-应用程序连接MySQL的方式"><a href="#1-2-应用程序连接MySQL的方式" class="headerlink" title="1.2 应用程序连接MySQL的方式"></a>1.2 应用程序连接MySQL的方式</h3><h4 id="1-2-1-TCP-IP方式"><a href="#1-2-1-TCP-IP方式" class="headerlink" title="1.2.1 TCP/IP方式"></a>1.2.1 TCP/IP方式</h4><ul><li>通过网络连接串：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@db02 ~]# mysql -uroot -p12345678 -h 127.0.0.1</span><br></pre></td></tr></table></figure><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-02.png" alt="体系结构-图2"></p><h4 id="1-2-2-Socket方式"><a href="#1-2-2-Socket方式" class="headerlink" title="1.2.2 Socket方式"></a>1.2.2 Socket方式</h4><ul><li>通过套接字文件：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@db02 ~]# mysql -uroot -p12345678 -S /usr/local/mysql/tmp/mysql.sock</span><br></pre></td></tr></table></figure><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-03.png" alt="体系结构-图3"></p><blockquote><p>提示：服务器默认使用Socket方式连接数据库。</p></blockquote><h3 id="1-3-实例介绍"><a href="#1-3-实例介绍" class="headerlink" title="1.3 实例介绍"></a>1.3 实例介绍</h3><h4 id="1-3-1-什么是实例"><a href="#1-3-1-什么是实例" class="headerlink" title="1.3.1 什么是实例"></a>1.3.1 什么是实例</h4><p>MySQL在启动过程中会启动后台守护进程，并生成工作线程，预分配内存结构供MySQL处理数据使用，这些MySQL的后台进程+线程+预分配的内存结构就是实例。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-04.png" alt="体系结构-图4"></p><h2 id="第2章-MySQL的逻辑结构"><a href="#第2章-MySQL的逻辑结构" class="headerlink" title="第2章 MySQL的逻辑结构"></a>第2章 MySQL的逻辑结构</h2><h3 id="2-1-mysqld服务器程序构成"><a href="#2-1-mysqld服务器程序构成" class="headerlink" title="2.1 mysqld服务器程序构成"></a>2.1 mysqld服务器程序构成</h3><p>msyqld服务程序分为三层，分别为连接层、SQL层、存储引擎层：</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-05.png" alt="体系结构-图5"></p><h4 id="2-1-1-连接层"><a href="#2-1-1-连接层" class="headerlink" title="2.1.1 连接层"></a>2.1.1 连接层</h4><p>所包含的服务并不是MySQL所独有的技术。它们都是服务于C/S程序或者是这些程序所需要的 ：连接处理，身份验证，安全性等等：</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-06.png" alt="体系结构-图6"></p><h4 id="2-1-2-SQL层"><a href="#2-1-2-SQL层" class="headerlink" title="2.1.2 SQL层"></a>2.1.2 SQL层</h4><p>这是MySQL的核心部分，通常叫做 SQL Layer。在 MySQL据库系统处理底层数据之前的所有工作都是在这一层完成的，包括权限判断，sql解析，行计划优化，query cache的处理以及所有内置的函数(如日期、时间、数学运算、加密)等等。各个存储引擎提供的功能都集中在这一层，如存储过程，触发器，视图等：</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-07.png" alt="体系结构-图7"></p><ul><li>SQL处理流程图：</li></ul><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-08.png" alt="体系结构-图8"></p><h4 id="2-1-3-存储引擎层"><a href="#2-1-3-存储引擎层" class="headerlink" title="2.1.3 存储引擎层"></a>2.1.3 存储引擎层</h4><p>通常叫做StorEngine Layer，也就是底层数据存取操作实现部分，由多种存储引擎共同组成。它们负责存储和获取所有存储在MySQL中的数据。就像Linux众多的文件系统一样。每个存储引擎都有自己的优点和缺陷。服务器是通过存储引擎API来与它们交互的。这个接口隐藏了各个存储引擎不同的地方，对于查询层尽可能的透明。这个API包含了很多底层的操作，如开始一个事务，或者取出有特定主键的行。存储引擎不能解析SQL，互相之间也不能通信，仅仅是简单的响应服务器 的请求：</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-09.png" alt="体系结构-图9"></p><h3 id="2-2-SQL的整个处理过程"><a href="#2-2-SQL的整个处理过程" class="headerlink" title="2.2 SQL的整个处理过程"></a>2.2 SQL的整个处理过程</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-10.png" alt="体系结构-图10"></p><h4 id="2-2-1-Connectors"><a href="#2-2-1-Connectors" class="headerlink" title="2.2.1 Connectors"></a>2.2.1 Connectors</h4><p>指的是不同语言中与SQL的交互。</p><h4 id="2-2-2-Management-Serveices-amp-Utilities："><a href="#2-2-2-Management-Serveices-amp-Utilities：" class="headerlink" title="2.2.2 Management Serveices &amp; Utilities："></a>2.2.2 Management Serveices &amp; Utilities：</h4><p>系统管理和控制工具。</p><h4 id="2-2-3-Connection-Pool-连接池"><a href="#2-2-3-Connection-Pool-连接池" class="headerlink" title="2.2.3 Connection Pool: 连接池"></a>2.2.3 Connection Pool: 连接池</h4><p>管理缓冲用户连接，线程处理等需要缓存的需求。负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。</p><h4 id="2-2-4-SQL-Interface-SQL接口"><a href="#2-2-4-SQL-Interface-SQL接口" class="headerlink" title="2.2.4 SQL Interface: SQL接口"></a>2.2.4 SQL Interface: SQL接口</h4><p>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface。</p><h4 id="2-2-5-Parser-解析器"><a href="#2-2-5-Parser-解析器" class="headerlink" title="2.2.5 Parser: 解析器"></a>2.2.5 Parser: 解析器</h4><p>SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。</p><p>在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。</p><ul><li>主要功能：</li></ul><p>将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。<br>如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</p><h4 id="2-2-6-Optimizer-查询优化器"><a href="#2-2-6-Optimizer-查询优化器" class="headerlink" title="2.2.6 Optimizer: 查询优化器"></a>2.2.6 Optimizer: 查询优化器</h4><p>SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果，他使用的是“选取-投影-联接”策略进行查询，用一个例子就可以理解：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> uid,name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>解析方式：</li></ul><p>这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤<br>这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤<br>将这两个查询条件联接起来生成最终查询结果</p><h4 id="2-2-7-Cache和Buffer：查询缓存"><a href="#2-2-7-Cache和Buffer：查询缓存" class="headerlink" title="2.2.7 Cache和Buffer：查询缓存"></a>2.2.7 Cache和Buffer：查询缓存</h4><p>他的主要功能是将客户端提交 给MySQL 的Select类query请求的返回结果集cache到内存中，与该query的一个hash值做一个对应。该Query所取数据的基表发生任何数据的变化之后，MySQL会自动使该query的Cache失效。在读写比例非常高的应用系统中，Query Cache对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。</p><p>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的：比如表缓存、记录缓存、key缓存、权限缓存等</p><h4 id="2-2-8-存储引擎接口"><a href="#2-2-8-存储引擎接口" class="headerlink" title="2.2.8 存储引擎接口"></a>2.2.8 存储引擎接口</h4><p>存储引擎接口模块可以说是MySQL数据库中最有特色的一点了。目前各种数据库产品中，基本上只有MySQL可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天MySQL可插拔存储引擎的特色。</p><p>从图上还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。</p><p>注意：存储引擎是基于表的，而不是数据库。</p><h3 id="2-3-存储引擎概览"><a href="#2-3-存储引擎概览" class="headerlink" title="2.3 存储引擎概览"></a>2.3 存储引擎概览</h3><p>存储引擎是充当不同表类型的处理程序的服务器组件。依赖于存储引擎的功能</p><h4 id="2-3-1-存储引擎用于"><a href="#2-3-1-存储引擎用于" class="headerlink" title="2.3.1 存储引擎用于"></a>2.3.1 存储引擎用于</h4><ul><li>存储数据</li><li>检索数据</li><li>通过索引查找数据</li></ul><h4 id="2-3-2-双层处理"><a href="#2-3-2-双层处理" class="headerlink" title="2.3.2 双层处理"></a>2.3.2 双层处理</h4><ul><li>上层包括SQL解析器和优化器</li><li>下层包含一组存储引擎</li></ul><h4 id="2-3-3-SQL层不依赖于存储引擎"><a href="#2-3-3-SQL层不依赖于存储引擎" class="headerlink" title="2.3.3 SQL层不依赖于存储引擎"></a>2.3.3 SQL层不依赖于存储引擎</h4><ul><li>引擎不影响SQL处理</li><li>有一些例外</li></ul><h4 id="2-3-4-依赖于存储引擎的功能"><a href="#2-3-4-依赖于存储引擎的功能" class="headerlink" title="2.3.4 依赖于存储引擎的功能"></a>2.3.4 依赖于存储引擎的功能</h4><ul><li>存储介质</li><li>事务功能</li><li>锁定</li><li>备份和恢复</li><li>优化</li><li>特殊功能：如全文搜索、引用完整性、空间数据处理等</li></ul><h2 id="第3章-MySQL“库”的构成"><a href="#第3章-MySQL“库”的构成" class="headerlink" title="第3章 MySQL“库”的构成"></a>第3章 MySQL“库”的构成</h2><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-11.png" alt="体系结构-图11"></p><h3 id="3-1-数据库的逻辑结构"><a href="#3-1-数据库的逻辑结构" class="headerlink" title="3.1 数据库的逻辑结构"></a>3.1 数据库的逻辑结构</h3><h4 id="3-1-1-库"><a href="#3-1-1-库" class="headerlink" title="3.1.1 库"></a>3.1.1 库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases</span><br><span class="line">use mysql</span><br></pre></td></tr></table></figure><h4 id="3-1-2-表"><a href="#3-1-2-表" class="headerlink" title="3.1.2 表"></a>3.1.2 表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><h4 id="3-1-3-记录（行、列）"><a href="#3-1-3-记录（行、列）" class="headerlink" title="3.1.3 记录（行、列）"></a>3.1.3 记录（行、列）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host,password <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h3 id="3-2-数据库的物理结构"><a href="#3-2-数据库的物理结构" class="headerlink" title="3.2 数据库的物理结构"></a>3.2 数据库的物理结构</h3><p>对象存储中的库相当于目录。表分为MyIASM和InnoDB方式：</p><ul><li>MyIASM方式：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@db02 ~]# ll -h /usr/local/mysql/data/mysql/user*</span><br><span class="line">-rw-rw---- 1 mysql mysql  11K Nov 13 11:54 /usr/local/mysql/data/mysql/user.frm     # 存放索引</span><br><span class="line">-rw-rw---- 1 mysql mysql  488 Nov 13 12:33 /usr/local/mysql/data/mysql/user.MYD     # 存放列结构</span><br><span class="line">-rw-rw---- 1 mysql mysql 2.0K Nov 13 12:33 /usr/local/mysql/data/mysql/user.MYI     # 存放行结构</span><br></pre></td></tr></table></figure><p>InnoDB方式：</p><p>共享表空间：ibdata1:ibdata2</p><p>独立表空间：t1.frm t1.ibd</p><ul><li>创建一个数据库和表，查看一下独立表空间存储的不同</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database leon;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use leon;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table t1 (id int);</span><br><span class="line">Query OK, 0 rows affected (0.63 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id from t1;</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">+------+</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t1;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| id    | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line"></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">[root@db02 leon]# ll -h t1*</span><br><span class="line">-rw-rw---- 1 mysql mysql 8.4K Nov 14 10:21 t1.frm       # 存储表结构定义</span><br><span class="line">-rw-rw---- 1 mysql mysql  96K Nov 14 10:21 t1.ibd       # 存储行、列结构</span><br></pre></td></tr></table></figure><h3 id="3-3-MySQL使用磁盘方式"><a href="#3-3-MySQL使用磁盘方式" class="headerlink" title="3.3 MySQL使用磁盘方式"></a>3.3 MySQL使用磁盘方式</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-12.png" alt="体系结构-图12"></p><p>程序文件随数据目录一起存储在服务器安装目录下。执行各种客户机程序、管理程序和实用程序时将创建程序可执行文件和日志文件。首要使用磁盘空间的是数据目录。</p><ul><li><p>服务器日志文件和状态文件：包含有关服务器处理的语句的信息。日志可用于进行故障排除、监视、复制和恢复。</p></li><li><p>InnoDB 日志文件：（适用于所有数据库）驻留在数据目录级别。</p></li><li><p>nnoDB 系统表空间：包含数据字典、撤消日志和缓冲区。<br>每个数据库在数据目录下均具有单一目录（无论在数据库中创建何种类型的表）。数据库目录存储以下内容：</p></li><li><p>数据文件：特定于存储引擎的数据文件。这些文件也可能包含元数据或索引信息，具体取决于所使用的存储引擎。</p></li><li><p>格式文件 (.frm)：包含每个表和/或视图结构的说明，位于相应的数据库目录中。</p></li><li><p>触发器：某个表关联并在该表发生特定事件时激活的命名数据库对象。<br>数据目录的位置取决于配置、操作系统、安装包和分发。典型位置是 /var/lib/mysql。MySQL在磁盘上存储系统数据库 (mysql)。mysql 包含诸如用户、特权、插件、帮助列表、事件、时区实现和存储例程之类的信息。</p></li></ul><p><strong>本文转载自 leon 的博客，<a href="https://blog.leonshadow.com/763482/527.html" rel="nofollow">《MySQL体系结构》</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL QA</title>
      <link href="/interview/docs/05.MySQL/QA/"/>
      <url>/interview/docs/05.MySQL/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="MySQL-篇"><a href="#MySQL-篇" class="headerlink" title="MySQL 篇"></a>MySQL 篇</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>组成部分：SQL 接口，解析器，优化器，缓存，存储引擎</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mysql-system-10.png" alt="体系结构图"></p><ul><li>Connectors：不同语言中与 SQL 的交互</li><li>Management Serveices &amp; Utilities： 系统管理和控制工具</li><li>Connection Pool: 连接池</li><li>SQL Interface: SQL 接口</li><li>Parser: 解析器</li><li>Optimizer: 查询优化器</li><li>Cache 和 Buffer：查询缓存</li><li>Engine：存储引擎</li></ul><p>拓展阅读 <a href="./02.MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">《MySQL体系结构》</a></p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><p>连接数据库、查看所有库、选择库、创建库、删除库</p><p>查看所有表、查看表结构、创建表、删除表</p><p>添加字段、删除字段、修改字段</p><h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p>INSERT、SELECT、UPDATE、DELETE</p><h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><p>所有字段、指定字段、WHERE、IN、BETWEEN AND、LIKE、AND、OR、DISTINCT、ORDER BY、GROUP BY、LIMIT</p><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p>连接查询、子查询、合并结果</p><h3 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h3><ul><li>第一范式：属性具有原子性，不可再分解，即不能表中有表</li><li>第二范式：唯一性约束，每条记录有唯一标示，所有的非主键字段均需依赖于主键字段</li><li>第三范式：冗余性约束，非主键字段间不能相互依赖</li></ul><h3 id="数据库设计原则"><a href="#数据库设计原则" class="headerlink" title="数据库设计原则"></a>数据库设计原则</h3><ul><li>避免冗余属性，冗余属性会带来数据不一致性</li><li>一个表只存储它应该存储的信息，和此表无关的信息放到另一个表去存储，表之间尽量解耦</li><li>一个字段中不要出现分隔符，或者在一个字段中存储多个信息</li></ul><h3 id="char-和-varchar-数据类型区别"><a href="#char-和-varchar-数据类型区别" class="headerlink" title="char 和 varchar 数据类型区别"></a>char 和 varchar 数据类型区别</h3><ul><li>char：擅于存储经常改变的值，或者长度相对固定的值。比如 type、ip 地址或 md5 之类的数据，不容易产生碎片</li><li>varchar：善于存储值的长短不一的列，也是用的最多的一种类型，节省磁盘空间，保存可变长度字符串。这也是 innodb 官方推荐的类型</li></ul><h3 id="LEFT-JOIN-、RIGHT-JOIN、INNER-JOIN"><a href="#LEFT-JOIN-、RIGHT-JOIN、INNER-JOIN" class="headerlink" title="LEFT JOIN 、RIGHT JOIN、INNER JOIN"></a>LEFT JOIN 、RIGHT JOIN、INNER JOIN</h3><ul><li>LEFT JOIN(左连接)：获取左表所有记录，即使右表没有对应匹配的记录</li><li>RIGHT JOIN(右连接)： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录</li><li>INNER JOIN(内连接)：获取两个表中字段匹配关系的记录</li></ul><p>拓展阅读 <a href="./01.MySQL%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BD%BF%E7%94%A8.md">《MySQL 连接的使用》</a></p><h3 id="UNION、UNION-ALL"><a href="#UNION、UNION-ALL" class="headerlink" title="UNION、UNION ALL"></a>UNION、UNION ALL</h3><ul><li>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据</li><li>UNION ALL 操作符重复数据全部显示，不去重</li></ul><h3 id="常用-MySQL-函数"><a href="#常用-MySQL-函数" class="headerlink" title="常用 MySQL 函数"></a>常用 MySQL 函数</h3><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><ul><li>floor(x) 返回不大于 x 的最大整数值</li><li>ceil/ceiling(x) 返回不小于 x 的最小整数</li><li>round(x) 四舍五入</li><li>rand() 随机函数[0, 1)</li><li>abs(x) 返回 x 的绝对值</li></ul><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><ul><li>concat(str1, str2, …) 将参数连接成字符串返回</li><li>length(str) 返回字符串长度</li></ul><h4 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h4><ul><li>now() 当前时间</li><li>curdate() 当前日期</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT UNIX_TIMESTAMP(&#x27;2019-05-07 22:55:00&#x27;); #1557240900</span><br><span class="line">SELECT FROM_UNIXTIME(1557240900); #2019-05-07 22:55:00</span><br></pre></td></tr></table></figure><h4 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h4><ul><li>VERSION() 返回数据库的版本号</li><li>LAST_INSERT_ID() 返回最后生成的 AUTO_INCREMENT 值</li></ul><h4 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h4><ul><li>PASSWORD(str) 对字符串 str 进行加密</li><li>MD5(str) 对字符串 str 进行加密</li></ul><h4 id="格式化函数"><a href="#格式化函数" class="headerlink" title="格式化函数"></a>格式化函数</h4><ul><li>FORMAT(x, n) 可以将数字 x 进行格式化，保留到小数点后 n 位，四舍五入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT FORMAT(2.7895, 2); #2.79</span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>多个查询需要在同一时刻修改数据，会产生并发控制的问题。使用锁可以有效解决这个问题</p><h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><p>我们都知道锁的种类一般分为乐观锁和悲观锁两种，InnoDB 存储引擎中使用的就是悲观锁，而按照锁的粒度划分，也可以分成行锁和表锁。  </p><ul><li>乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁；</li><li>悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；</li></ul><p>虽然乐观锁和悲观锁在本质上并不是同一种东西，一个是一种思想，另一个是一种真正的锁，但是它们都是一种并发控制机制。</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//Optimistic-Pessimistic-Locks.jpg" alt="体系结构图"></p><p>乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候使用乐观锁就能较好的解决问题，在这时使用悲观锁就可能出现严重的性能问题；在选择并发控制机制时，需要综合考虑上面的四个方面（冲突频率、重试成本、响应速度和并发量）进行选择。</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>共享锁（读锁）：允许事务对一条行数据进行读取；</li><li>互斥锁（写锁,也叫排他锁）：允许事务对一条行数据进行删除或更新；</li></ul><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><ul><li>表锁：开销最小，对表进行写操作，需要获得写锁，会阻塞该表的所有读写操作</li><li>行级锁：最大锁开销，可以最大程度地支持并发处理</li></ul><p>拓展阅读 <a href="https://draveness.me/mysql-innodb/">《『浅入浅出』MySQL 和 InnoDB》</a></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败</p><p>ACID 特性：原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)</p><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li>未提交读(READ UNCOMMITTED)：事务中的修改，未提交，其他事务也是可见</li></ul><blockquote><p><code>脏读</code>(Dirty Read)：事务读取未提交的数据</p></blockquote><ul><li><p>提交读(READ COMMITTED)：事务未提交，对自己可见，两次同样查询，可能得到不同结果</p></li><li><p>可重复读(REPEATABLE READ)：同一个事务多次读取结果一致。解决脏读问题</p></li></ul><blockquote><p>MySQL 默认事务隔离级别</p></blockquote><ul><li>可串行化(SERIALIZABLE)：强制事务串行执行</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>多个事务在同一资源上相互占用，并请求锁定对方占用资源，从而导致恶性循环的现象</p><p>InnoDB 目前处理方法：将持有最少行级排他锁的事务进行回滚</p><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p>事务日志可以帮助提高事务的效率</p><h4 id="MySQL-中的事务"><a href="#MySQL-中的事务" class="headerlink" title="MySQL 中的事务"></a>MySQL 中的事务</h4><p>MySQL 默认采用自动提交(AUTOCOMMIT)模式，每个查询都当作一个事务执行提交操作</p><h3 id="常见存储引擎"><a href="#常见存储引擎" class="headerlink" title="常见存储引擎"></a>常见存储引擎</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li>很重要的存储引擎，很多个人和公司都对其贡献代码，而不仅仅是 Oracle 公司的开发团队</li><li>支持事务，行级锁，删除或者增加索引时不需要复制全表数据</li><li>InnoDB 采用 MVCC 来支持高并发，实现了四个标准的隔离级别</li><li>InnoDB 表是基于聚族索引建立的，聚族索引对主键查询有很高的性能</li><li>InnoDB 内部做了很多优化，包括可预测性预读，加速读操作的自适应哈希索引，加速插入操作的插入缓冲区</li><li>作为事务性的存储引擎，InnoDB 通过一些机制和工具支持真正的热备份</li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul><li>不支持事务和行级锁，崩溃后无法安全恢复，表锁非常影响性能</li><li>MyISAM 对整张表加锁，而不是针对行。读取时对需要读到的表加共享锁，写入则加排它锁。在表有读取查询的同时，也可以插入新记录(支持并发插入)</li><li>支持延迟更新索引健，极大的提升写入性能</li><li>支持全文索引，可以支持复杂的查询</li><li>MyISAM 将表存储在两个文件中，数据文件和索引文件</li></ul><h3 id="常见索引"><a href="#常见索引" class="headerlink" title="常见索引"></a>常见索引</h3><h4 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h4><p>索引是存储引擎用于快速找到记录的一种数据结构</p><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//index.png" alt="索引分类"></p><h4 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD INDEX index_name (`column`); #普通索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD UNIQUE (`column`); #唯一索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD PRIMARY KEY (`column`); #主键索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD FULLTEXT (`column`); #全文索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`); #组合索引</span><br></pre></td></tr></table></figure><h4 id="索引区别"><a href="#索引区别" class="headerlink" title="索引区别"></a>索引区别</h4><ul><li>普通索引：最基本的索引，没有任何限制</li><li>唯一索引：与”普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值</li><li>主键索引：它是一种特殊的唯一索引，不允许有空值</li><li>全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间</li><li>组合索引：为了更多的提高 MySQL 效率可建立组合索引，遵循”最左前缀”原则</li></ul><h3 id="聚族索引与非聚族索引的区别"><a href="#聚族索引与非聚族索引的区别" class="headerlink" title="聚族索引与非聚族索引的区别"></a>聚族索引与非聚族索引的区别</h3><ul><li>按物理存储分类：聚簇索引(clustered index)、非聚簇索引(non-clustered index)</li><li>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针</li></ul><h3 id="BTree-与-BTree-BTree-索引原理"><a href="#BTree-与-BTree-BTree-索引原理" class="headerlink" title="BTree 与 BTree-/BTree+ 索引原理"></a>BTree 与 BTree-/BTree+ 索引原理</h3><ul><li>BTree</li></ul><p>二叉树导致树高度非常高，逻辑上很近的节点，物理上非常远，无法利用局部性，IO 次数多，查找效率低</p><ul><li>BTree-</li></ul><p>每个节点都是二元数组[key,data]，所有节点都可以存储数据，key 为索引，data 为索引外的数据。插入删除数据会破坏 BTree 性质，插入数据时候，需要对数据进行分裂、合并、转移等操作保持 BTree 性质，造成 IO 操作频繁</p><ul><li>BTree+</li></ul><p>非叶子节点不存储 data，只存储索引 key，只有叶子节点才存储 data</p><ul><li>MySQL中的 BTree+</li></ul><p>在经典 BTree+ 的基础上进行了优化，增加了顺序访问指针。在 BTree+ 的每个叶子节点增加了一个指向相邻叶子节点的指针，形成了带顺序访问指针的 BTree+，提高了区间访问性能</p><h3 id="分表数量级"><a href="#分表数量级" class="headerlink" title="分表数量级"></a>分表数量级</h3><p>MySQL 单表容量在<code>500万</code>左右，性能处于最佳状态，此时，MySQL 的 BTREE 索引树高在3～5之间</p><h3 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h3><table><thead><tr><th>Column</th><th>JSON Name</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select_id</td><td>SELECT 标识符</td></tr><tr><td>select_type</td><td>None</td><td>SELECT 类型</td></tr><tr><td>table</td><td>table_name</td><td>输出行描述的表的表名</td></tr><tr><td>partitions</td><td>partitions</td><td>匹配的分区</td></tr><tr><td>type</td><td>access_type</td><td>连接类型</td></tr><tr><td>possible_keys</td><td>possible_keys</td><td>可供选择使用的索引</td></tr><tr><td>key</td><td>key</td><td>实际使用的索引</td></tr><tr><td>key_len</td><td>key_length</td><td>实际使用的索引的长度</td></tr><tr><td>ref</td><td>ref</td><td>与索引进行比较的列，也就是关联表使用的列</td></tr><tr><td>rows</td><td>rows</td><td>将要被检查的估算的行数</td></tr><tr><td>filtered</td><td>filtered</td><td>被表条件过滤的行数的百分比</td></tr><tr><td>Extra</td><td>None</td><td>附件信息</td></tr></tbody></table><h3 id="my-cnf-配置"><a href="#my-cnf-配置" class="headerlink" title="my.cnf 配置"></a>my.cnf 配置</h3><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><h3 id="优化-MYSQL-的方法"><a href="#优化-MYSQL-的方法" class="headerlink" title="优化 MYSQL 的方法"></a>优化 MYSQL 的方法</h3><ul><li>数据超过一定数量或者体积，请拆分表，垂直或者水平分</li><li>务必有自增主键。通过自增主键来查数据是最快的。</li><li>常用的查询字段建立联合索引，写 SQL 一定要尊从最左原则，用到这个索引。</li><li>不要把逻辑运算放到 sql 里</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常用函数</title>
      <link href="/interview/docs/05.MySQL/03.MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/interview/docs/05.MySQL/03.MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis QA</title>
      <link href="/interview/docs/06.Redis/QA/"/>
      <url>/interview/docs/06.Redis/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="Redis-篇"><a href="#Redis-篇" class="headerlink" title="Redis 篇"></a>Redis 篇</h2><h3 id="Redis-介绍"><a href="#Redis-介绍" class="headerlink" title="Redis 介绍"></a>Redis 介绍</h3><p>Redis 是一个高性能的 key-value 数据库。每秒可执行操作高达 10万+ QPS</p><h3 id="Redis-特点"><a href="#Redis-特点" class="headerlink" title="Redis 特点"></a>Redis 特点</h3><ul><li>支持数据持久化，可将内存中的数据保存在磁盘，重启时再次加载</li><li>支持 KV 类型数据，也支持其他丰富的数据结构存储</li><li>支持数据备份，即 master-slave 模式的数据备份</li></ul><h3 id="Redis-支持哪些数据结构"><a href="#Redis-支持哪些数据结构" class="headerlink" title="Redis 支持哪些数据结构"></a>Redis 支持哪些数据结构</h3><ul><li><p>STRING：字符串、整数或浮点数</p></li><li><p>LIST：列表，可存储多个相同的字符串</p></li><li><p>SET：集合，存储不同元素，无序排列</p></li><li><p>HASH：散列表，存储键值对之间的映射，无序排列</p></li><li><p>ZSET：有序集合，存储键值对，有序排列</p></li></ul><h3 id="Redis-与-Memcache-区别"><a href="#Redis-与-Memcache-区别" class="headerlink" title="Redis 与 Memcache 区别"></a>Redis 与 Memcache 区别</h3><table><thead><tr><th>对比项</th><th>Redis</th><th>Memcache</th></tr></thead><tbody><tr><td>数据结构</td><td>丰富数据类型</td><td>只支持简单 KV 数据类型</td></tr><tr><td>数据一致性</td><td>事务</td><td>cas</td></tr><tr><td>持久性</td><td>快照/AOF</td><td>不支持</td></tr><tr><td>网络IO</td><td>单线程 IO 复用</td><td>多线程、非阻塞 IO 复用</td></tr><tr><td>内存管理机制</td><td>现场申请内存</td><td>预分配内存</td></tr></tbody></table><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</p><h3 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h3><h4 id="快照持久化-RDB"><a href="#快照持久化-RDB" class="headerlink" title="快照持久化 RDB"></a>快照持久化 RDB</h4><p>将某一时刻的所有数据写入硬盘。使用<code>BGSAVE</code>命令，随着内存使用量的增加，执行 BGSAVE 可能会导致系统长时间地停顿</p><h4 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h4><p>只追加文件，在执行写命令时，将被执行的写命令复制到硬盘里面。使用 AOF 策略需要对硬盘进行大量写入，Redis 处理速度会受到硬盘性能的限制</p><h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI  <span class="comment">#标记事务开始</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">INCR user_id  <span class="comment">#多条命令按顺序入队</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">INCR user_id</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">INCR user_id</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">PING</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXEC  <span class="comment">#执行</span></span></span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) PONG</span><br></pre></td></tr></table></figure><blockquote><p>在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</p></blockquote><blockquote><p>使用 DISCARD 可以取消事务，放弃执行事务块内的所有命令</p></blockquote><h3 id="如何实现分布式锁"><a href="#如何实现分布式锁" class="headerlink" title="如何实现分布式锁"></a>如何实现分布式锁</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tryLock() &#123;</span><br><span class="line">    SETNX Key 1 Seconds</span><br><span class="line">&#125;</span><br><span class="line">release() &#123;</span><br><span class="line">    DELETE Key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺陷：C<sub>1</sub> 执行时间过长未主动释放锁，C<sub>2</sub> 在 C<sub>1</sub> 的锁超时后获取到锁，C<sub>1</sub> 和 C<sub>2</sub> 都同时在执行，可能造成数据不一致等未知情况。如果 C<sub>1</sub> 先执行完毕，则会释放 C<sub>2</sub> 的锁，此时可能导致另外一个 C<sub>3</sub> 获取到锁</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tryLock() &#123;</span><br><span class="line">    SETNX Key UnixTimestamp Seconds</span><br><span class="line">&#125;</span><br><span class="line">release() &#123;</span><br><span class="line">    EVAL (</span><br><span class="line">        //LuaScript</span><br><span class="line">        if redis.call(&quot;get&quot;, KEYS[1] == ARGV[1]) then</span><br><span class="line">            return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">        else</span><br><span class="line">            return 0</span><br><span class="line">        end</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺陷：极高并发场景下(如抢红包场景)，可能存在 UnixTimestamp 重复问题。分布式环境下物理时钟一致性，也无法保证，也可能存在 UnixTimestamp 重复问题</p><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tryLock() &#123;</span><br><span class="line">    SET Key UniqId Seconds</span><br><span class="line">&#125;</span><br><span class="line">release() &#123;</span><br><span class="line">    EVAL (</span><br><span class="line">        //LuaScript</span><br><span class="line">        if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">            return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">        else</span><br><span class="line">            return 0</span><br><span class="line">        end</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code></p></blockquote><p>目前最优的分布式锁方案，但是如果在集群下依然存在问题。由于 Redis 集群数据同步为异步，假设在 Master 节点获取到锁后未完成数据同步情况下 Master 节点 crash，在新的 Master 节点依然可以获取锁，所以多个 Client 同时获取到了锁</p><h3 id="Redis-过期策略及内存淘汰机制"><a href="#Redis-过期策略及内存淘汰机制" class="headerlink" title="Redis 过期策略及内存淘汰机制"></a>Redis 过期策略及内存淘汰机制</h3><h4 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h4><p>Redis 的过期策略就是指当 Redis 中缓存的 Key 过期了，Redis 如何处理</p><ul><li><p>定时过期：每个设置过期时间的 Key 创建定时器，到过期时间立即清除。内存友好，CPU 不友好</p></li><li><p>惰性过期：访问 Key 时判断是否过期，过期则清除。CPU 友好，内存不友好</p></li><li><p>定期过期：隔一定时间，expires 字典中扫描一定数量的 Key，清除其中已过期的 Key。内存和 CPU 资源达到最优的平衡效果</p></li></ul><h4 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root]# </span><span class="language-bash">redis-cli config get maxmemory-policy</span></span><br><span class="line">1) &quot;maxmemory-policy&quot;</span><br><span class="line">2) &quot;noeviction&quot;</span><br></pre></td></tr></table></figure><ul><li>noeviction：新写入操作会报错</li><li>allkeys-lru：移除最近最少使用的 key</li><li>allkeys-random：随机移除某些 key</li><li>volatile-lru：在设置了过期时间的键中，移除最近最少使用的 key</li><li>volatile-random：在设置了过期时间的键中，随机移除某些 key</li><li>volatile-ttl：在设置了过期时间的键中，有更早过期时间的 key 优先移除</li></ul><h3 id="为什么-Redis-是单线程的"><a href="#为什么-Redis-是单线程的" class="headerlink" title="为什么 Redis 是单线程的"></a>为什么 Redis 是单线程的</h3><p>Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 瓶颈最有可能是内存或网络。而且单线程容易实现，避免了不必要的上下文切换和竞争条件，不存在多线程切换消耗 CPU</p><h3 id="如何利用-CPU-多核心"><a href="#如何利用-CPU-多核心" class="headerlink" title="如何利用 CPU 多核心"></a>如何利用 CPU 多核心</h3><p>在单机单实例下，如果操作都是 O(N)、O(log(N)) 复杂度，对 CPU 消耗不会太高。为了最大利用 CPU，单机可以部署多个实例</p><h3 id="集合命令的实现方法"><a href="#集合命令的实现方法" class="headerlink" title="集合命令的实现方法"></a>集合命令的实现方法</h3><table><thead><tr><th>命令</th><th>intset 编码的实现方法</th><th>hashtable 编码的实现方法</th></tr></thead><tbody><tr><td>SADD</td><td>调用 intsetAdd 函数，将所有新元素添加到整数集合里面</td><td>调用 dictAdd，以新元素为键，NULL 为值，将键值对添加到字典里面</td></tr><tr><td>SCARD</td><td>调用 intsetLen 函数，返回整数集合所包含的元素数量，这个数量就是集合对象所包含的元素数量</td><td>调用 dictSize 函数，返回字典所包含的键值对数量，这个数量就是集合对象所包含的元素数量</td></tr><tr><td>SISMEMBER</td><td>调用 intsetFind 函数，在整数集合中查找给定的元素，如果找到了元素存在于集合，没找到则说明元素不存在集合</td><td>调用 dictFind 函数，在字典的键中查找给定的元素，如果找到了说明元素存在于集合，没找到则说明元素不存在于集合</td></tr><tr><td>SMEMBERS</td><td>遍历整个整数集合，调用 inisetGet 函数返回集合元素</td><td>遍历整个字典，使用 dictGetKey 函数返回字典的键作为集合元素</td></tr><tr><td>SRANDMEMBER</td><td>调用 intsetRandom 函数，从整数集合中随机返回一个元素</td><td>调用 dictGetRandomKey 函数，从字典中随机返回一个字典键</td></tr><tr><td>SPOP</td><td>调用 intsetRandom 函数，从整数集合中随机取出一个元素，再将这个随机元素返回给客户端之后，调用 intsetRemove 函数，将随机元素从整数集合中删除掉</td><td>调用 dictGetRandomKey 函数，从字典中随机取出一个字典键，在将这个随机字典键的值返回给客户端之后，调用 dictDelete 函数，从字典中删除随机字典键所对应的键值对</td></tr><tr><td>SREM</td><td>调用 intsetRemove 函数，从整数集合中删除所有给定的元素</td><td>调用 dictDelete 函数，从字典中删除所有键为给定元素的键值对</td></tr></tbody></table><h3 id="有序集合命令的实现方法"><a href="#有序集合命令的实现方法" class="headerlink" title="有序集合命令的实现方法"></a>有序集合命令的实现方法</h3><table><thead><tr><th>命令</th><th>ziplist 编码的实现方法</th><th>zset 编码的实现方法</th></tr></thead><tbody><tr><td>ZADD</td><td>调用 ziplistInsert 函数，将成员和分值作为两个节点分别插入到压缩列表</td><td>先调用 zslInsert 函数，将新元素添加到跳跃表，然后调用 dictAdd 函数，将新元素关联到字典</td></tr><tr><td>ZCARD</td><td>调用 ziplistLen 函数，获得压缩列表包含节点的数量，将这个数量除以2得出集合元素的数量</td><td>访问跳跃表数据结构的 length 属性，直接访问集合元素的数量</td></tr><tr><td>ZCOUND</td><td>遍历压缩列表，统计分值在给定范围内的节点的数量</td><td>遍历跳跃表，统计分值在给定范围内的节点的数量</td></tr><tr><td>ZRANGE</td><td>从表头向表尾遍历压缩列表，返回给定索引范围内的所有元素</td><td>从表头向表尾遍历跳跃表，返回给定索引范围内的所有元素</td></tr><tr><td>ZREVRANGE</td><td>表尾向表头遍历压缩列表，返回给定索引范围内的所有元素</td><td>从表尾向表头遍历跳跃表，返回给定索引范围的所有元素</td></tr><tr><td>ZRANK</td><td>从表头向表尾遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td><td>从表头向表尾遍历跳跃表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td></tr><tr><td>ZREVRANK</td><td>从表尾向表头遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td><td>从表尾向表头遍历跳跃表，查找给定的成员，沿途纪录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td></tr><tr><td>ZREM</td><td>遍历压缩列表，删除所有包含给定成员的节点，以及被删除成员节点旁边的分值节点</td><td>遍历跳跃表，删除所有包含了给定成员的跳跃表节点。并在字典中解除被删除元素的成员和分值关联</td></tr><tr><td>ZSCORE</td><td>遍历压缩列表，查找包含了给定成员的节点，然后取出成员节点旁边的分值节点保存的元素分值</td><td>直接从字典中取出给定成员的分值</td></tr></tbody></table><h3 id="redis-跳跃表"><a href="#redis-跳跃表" class="headerlink" title="redis 跳跃表"></a>redis 跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p><h3 id="redis-conf-配置"><a href="#redis-conf-配置" class="headerlink" title="redis.conf 配置"></a>redis.conf 配置</h3><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GNU/Linux 分支图</title>
      <link href="/interview/docs/07.Linux/01.GNU-Linux%E5%88%86%E6%94%AF%E5%9B%BE/"/>
      <url>/interview/docs/07.Linux/01.GNU-Linux%E5%88%86%E6%94%AF%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="GNU-Linux-分支图"><a href="#GNU-Linux-分支图" class="headerlink" title="GNU/Linux 分支图"></a>GNU/Linux 分支图</h1><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//linux-branches-1.png" alt="分支图1"></p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//linux-branches-2.png" alt="分支图2"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础</title>
      <link href="/interview/docs/07.Linux/02.Linux%E5%9F%BA%E7%A1%80/"/>
      <url>/interview/docs/07.Linux/02.Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h1><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>uname –help</td><td>内核名称、内核版本、硬件名称、硬件平台、操作系统</td></tr><tr><td>cat /proc/cpuinfo</td><td>CPU 详细信息</td></tr><tr><td>env</td><td>环境变量</td></tr><tr><td>free –help</td><td>查看内存使用量和交换区使用量</td></tr><tr><td>df –help</td><td>查看文件系统信息</td></tr><tr><td>du –help</td><td>汇总目录文件使用情况</td></tr><tr><td>uptime</td><td>查看系统运行时间、用户数、负载</td></tr><tr><td>cat /proc/loadavg</td><td>查看系统负载</td></tr><tr><td>ifconfig</td><td>查看防火墙设置</td></tr><tr><td>route –help</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端口</td></tr><tr><td>netstat -nap</td><td>grep 80(2755)</td></tr><tr><td>kill</td><td>进程终止</td></tr><tr><td>killall</td><td>根据名称终止进程</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>top</td><td>显示进程状态</td></tr><tr><td>who</td><td>查看当前登录用户</td></tr><tr><td>last</td><td>查看用户登录日志</td></tr><tr><td>cut -d: -f1 /etc/passwd</td><td>查看系统所有用户</td></tr><tr><td>cut -d: -f1 /etc/group</td><td>查看系统所有组</td></tr><tr><td>crontab -l</td><td>查看当前用户计划任务</td></tr><tr><td>rpm -qa</td><td>查看所有安装的软件包</td></tr><tr><td>date</td><td>系统时间</td></tr><tr><td>reboot</td><td>系统重启</td></tr><tr><td>poweroff</td><td>关机</td></tr></tbody></table><p>文件复制</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux QA</title>
      <link href="/interview/docs/07.Linux/QA/"/>
      <url>/interview/docs/07.Linux/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="Linux-篇"><a href="#Linux-篇" class="headerlink" title="Linux 篇"></a>Linux 篇</h2><h3 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── bin #存放二进制可执行文件，常用命令一般都在这里</span><br><span class="line">├── boot #存放用于系统引导时使用的各种文件</span><br><span class="line">├── dev #用于存放设备文件</span><br><span class="line">├── etc #存放系统管理和配置文件</span><br><span class="line">├── home #存放所有用户文件的根目录</span><br><span class="line">├── lib #存放着和系统运行相关的库文件</span><br><span class="line">├── media #linux 系统会自动识别一些设备，当识别后，linux 会把识别的设备挂载到这个目录下</span><br><span class="line">├── mnt #用户临时挂载其他的文件系统</span><br><span class="line">├── opt #额外安装的可选应用程序包所放置的位置</span><br><span class="line">├── proc #虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息</span><br><span class="line">├── root #超级用户的主目录</span><br><span class="line">├── run #是一个临时文件系统，存储系统启动以来的信息</span><br><span class="line">├── sbin #存放二进制可执行文件，只有 root 才能访问</span><br><span class="line">├── srv #该目录存放一些服务启动之后需要提取的数据</span><br><span class="line">├── sys #存放内核相关文件</span><br><span class="line">├── tmp #用于存放各种临时文件，是公用的临时文件存储点</span><br><span class="line">├── usr #用于存放系统应用程序</span><br><span class="line">└── var #用于存放运行时需要改变数据的文件，比如服务的日志文件</span><br></pre></td></tr></table></figure><h3 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h3><p>查看系统信息、内存信息、磁盘信息、负载信息、路由信息、端口信息、进程、登录用户、关机、重启、系统时间、用户管理、文件权限、压缩解压</p><h3 id="命令与文件查找"><a href="#命令与文件查找" class="headerlink" title="命令与文件查找"></a>命令与文件查找</h3><h4 id="which-寻找可执行文件"><a href="#which-寻找可执行文件" class="headerlink" title="which-寻找可执行文件"></a>which-寻找可执行文件</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# which php</span><br><span class="line">/usr/bin/php</span><br></pre></td></tr></table></figure><h4 id="whereis-特定目录寻找"><a href="#whereis-特定目录寻找" class="headerlink" title="whereis-特定目录寻找"></a>whereis-特定目录寻找</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# whereis php</span><br><span class="line">php: /usr/bin/php /usr/lib64/php /etc/php.d /etc/php.ini /usr/include/php /usr/share/php /usr/share/man/man1/php.1.gz</span><br></pre></td></tr></table></figure><h4 id="find-直接搜索硬盘"><a href="#find-直接搜索硬盘" class="headerlink" title="find-直接搜索硬盘"></a>find-直接搜索硬盘</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -name php-fpm</span><br><span class="line">/run/php-fpm</span><br><span class="line">/etc/sysconfig/php-fpm</span><br><span class="line">/etc/logrotate.d/php-fpm</span><br><span class="line">/var/log/php-fpm</span><br><span class="line">/usr/sbin/php-fpm</span><br></pre></td></tr></table></figure><h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>数据流分为三类：标准输入(stdin)、标准输出(stdout)、标准错误输出(stderr)</p><blockquote><p>/dev/null：是一个特殊的设备文件，这个文件接收到的任何数据都会被丢弃。因此，null 这个设备通常也被成为位桶(bit bucket)或黑洞</p></blockquote><h4 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h4><p>可以处理前一个标准输出信息，对标准错误输出没有处理能力</p><h4 id="截取命令"><a href="#截取命令" class="headerlink" title="截取命令"></a>截取命令</h4><ul><li>cut：将以行为单位的字符串进行切割</li><li>grep：分析一行字符，截取所需要的特定信息</li></ul><h4 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h4><ul><li>sort：可以依据不同的数据类型进行排序</li><li>uniq：数据去重</li><li>wc：统计行数、字符数</li></ul><h4 id="参数转换"><a href="#参数转换" class="headerlink" title="参数转换"></a>参数转换</h4><ul><li>xargs：将标准输入转换成命令行参数</li></ul><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>sed 是一个管道命令，用于分析标准输出。支持数据的替换、删除、新增、截取特定行等功能</p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>awk 是一个数据处理工具，sed 常常用于一整行的数据处理，awk 则倾向于将一行数据分成数据部分来处理。因此，awk 适合小型的数据进行局部处理</p><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><table><thead><tr><th>代表意义</th><th>分钟</th><th>小时</th><th>日期</th><th>月份</th><th>星期</th><th>指令</th></tr></thead><tbody><tr><td>数字范围</td><td>0-59</td><td>0-23</td><td>1-31</td><td>1-12</td><td>0-7</td><td>command</td></tr></tbody></table><table><thead><tr><th>特殊符号</th><th>意义</th><th>示例</th></tr></thead><tbody><tr><td>*</td><td>表示任何时刻</td><td>*</td></tr><tr><td>,</td><td>表示分隔时段</td><td>0 3,6 * * * command(3:00与6:00)</td></tr><tr><td>-</td><td>表示一段时间范围</td><td>20 8-12 * * * command(8:20~12:20)</td></tr><tr><td>/n</td><td>每隔 n 段时间</td><td>*/5 * * * * command(每五分钟进行一次)</td></tr></tbody></table><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><h4 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h4><p>normal、insert、command、visual、replace</p><h4 id="翻页与移动"><a href="#翻页与移动" class="headerlink" title="翻页与移动"></a>翻页与移动</h4><ul><li><code>&lt;c-f&gt;</code>：向下移动一页 (相当于：ctrl + f)</li><li><code>&lt;c-d&gt;</code>：向下移动半页</li><li><code>&lt;c-b&gt;</code>：向上移动一页</li><li><code>&lt;c-u&gt;</code>：向上移动半页</li></ul><p><code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>：<code>←</code>、<code>↓</code>、<code>↑</code>、<code>→</code></p><ul><li><code>nh</code>：向左移动 n 个字符(四个方向均可)</li><li><code>^</code>：移动到行首</li><li><code>$</code>：移动到行尾</li><li><code>nG</code>：移动到指定行数</li><li><code>gg</code>：移动到文档第一行，相当于 1G</li><li><code>G</code>：移动到文档最后一行</li></ul><h4 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h4><ul><li><p><code>/word</code>：输入<code>/</code>会进入 command 模式，在输入关键字回车进行搜索</p></li><li><p><code>?word</code>：<code>/</code>是向光标以后搜索，<code>?</code>是向前搜索</p></li><li><p><code>n</code>：根据搜索方向定位到下一个匹配目标</p></li><li><p><code>N</code>：与<code>n</code>相反方向定位匹配目标</p></li><li><p><code>:n1,n2s/word1/word2/g</code>：n1,n2 表示数字，替换n1行到n2行的单词</p></li><li><p><code>:1,$s/word1/word2/g</code>：全文替换，也可以写成<code>:%s/word1/word2/g</code></p></li><li><p><code>:1,$s/word1/word2/gc</code>：全文替换，并出现确认提示</p></li></ul><h3 id="负载查看"><a href="#负载查看" class="headerlink" title="负载查看"></a>负载查看</h3><p>使用 uptime、w、top 命令查看</p><p><code>load average: 0.00, 0.01, 0.05</code>，系统的平均负荷，对应 1分钟、5分钟、15分钟</p><p>X 个 CPU 的电脑，可接受的系统负荷最大为 <code>X.0</code> 。将<code>15分钟</code>系统负荷作为服务器正常运行的指标</p><h3 id="Linux-内存管理"><a href="#Linux-内存管理" class="headerlink" title="Linux 内存管理"></a>Linux 内存管理</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>malloc分配虚拟内存<br>mmap虚拟内存映射方法<br>hugepage虚拟内存映射方法，分配2MB或1GB</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>一种实现在计算机软硬件之间的内存管理技术，将程序使用到的内存地址映射到计算机内存中的物理地址<br>32位虚拟内存大小为0-4g，一个内存也默认大小为4kb</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>提高内存安全性</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>每个进程都有它自己的虚拟内存<br>虚拟内存的大小取决于系统的体系结构</p><h3 id="进程、线程、协程区别"><a href="#进程、线程、协程区别" class="headerlink" title="进程、线程、协程区别"></a>进程、线程、协程区别</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>是一个动态概念；由程序、数据和进程控制块组成。系统进行资源分配、调度和管理的最小单位。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>是进程的活动成分，是处理器分配资源的最小单位；可以共享进程的资源与地址空间。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程是一种用户态的轻量级线程，又称微线程，英文名 Coroutine，协程的调度完全由用户控制</p><h4 id="并发执行机制"><a href="#并发执行机制" class="headerlink" title="并发执行机制"></a>并发执行机制</h4><p>把一个处理器划分为若干个短的时间片，每个时间片依次轮流地执行处理各个应用程序，由于一个时间片很短，相对于一个应用程序来说，就好像是处理器在为自己单独服务一样，从而达到多个应用程序在同时进行的效果。</p><h4 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h4><p>多线程就是把操作系统中的这种并发执行机制原理运用在一个程序中，把一个程序划分为若干个子任务，多个子任务并发执行，每一个任务就是一个线程</p><h3 id="进程间通信与信号机制"><a href="#进程间通信与信号机制" class="headerlink" title="进程间通信与信号机制"></a>进程间通信与信号机制</h3><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>信号量、消息队列、共享内存、信号、管道、套接字</p><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p>信号是操作系统中进程间通讯的一种有限制的方式，是一种异步的通知机制，用来提醒进程一个事件已经发送</p><ul><li>SIGHUP：控制台操作</li><li>SIGINT：终止进程，<code>Ctrl + C</code></li><li>SIGKILL：终止进程，<code>kill -9</code></li><li>SIGSTOP：停止进程的执行</li><li>SIGCONT：恢复进程的执行</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安全 QA</title>
      <link href="/interview/docs/08.%E5%AE%89%E5%85%A8/QA/"/>
      <url>/interview/docs/08.%E5%AE%89%E5%85%A8/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="安全篇"><a href="#安全篇" class="headerlink" title="安全篇"></a>安全篇</h2><h3 id="跨站脚本攻击-XSS"><a href="#跨站脚本攻击-XSS" class="headerlink" title="跨站脚本攻击(XSS)"></a>跨站脚本攻击(XSS)</h3><p>跨站脚本攻击(Cross Site Script，简称 XSS)，利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序</p><h4 id="XSS-示例"><a href="#XSS-示例" class="headerlink" title="XSS 示例"></a>XSS 示例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$input</span> = <span class="variable">$_GET</span>[<span class="string">&quot;param&quot;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;div&gt;&quot;</span> . <span class="variable">$input</span> . <span class="string">&quot;&lt;/div&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.maplemark.cn/test.php?param=这是一个测试!</span><br><span class="line">https://blog.maplemark.cn/test.php?param=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h4><ul><li>反射型 XSS：简单地将用户输入的数据反射给浏览器</li><li>存储型 XSS：把用户输入的数据存储在服务器端</li><li>DOM Based XSS：修改页面 DOM 节点形成的 XSS</li></ul><h4 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h4><ul><li>为 Cookie 设置 HttpOnly，避免 Cookie 被劫持泄露</li><li>对输入/输出进行检查，明确编码方式</li></ul><h3 id="跨站点请求伪造-CSRF"><a href="#跨站点请求伪造-CSRF" class="headerlink" title="跨站点请求伪造(CSRF)"></a>跨站点请求伪造(CSRF)</h3><p>跨站请求伪造(Cross-site request forgery,简称 CSRF)， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法</p><h4 id="CSRF-示例"><a href="#CSRF-示例" class="headerlink" title="CSRF 示例"></a>CSRF 示例</h4><ul><li>在私有域构造页面P</li></ul><blockquote><p><a href="https://blog.maplemark.cn/csrf.html">https://blog.maplemark.cn/csrf.html</a></p></blockquote><p>其内容为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--仅用于演示，假设该点赞为 GET--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://segmentfault.com/api/article/1190000019050946/like?_=0faa0315ff95872d8b0f8da02e343ac7&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>诱使目标用户访问页面P</li></ul><p>如果你已经访问过 SF 网站，并且已经登录。可以看到在访问页面P之后，已经对 SF 文章进行点赞了</p><h4 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h4><ul><li>增加验证码(简单有效)</li><li>检查请求来源是否合法</li><li>增加随机 token</li></ul><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>输入的字符串中注入 SQL 指令，若程序当中忽略了字符检查，导致恶意指令被执行而遭到破坏或入侵</p><h4 id="SQL-注入示例"><a href="#SQL-注入示例" class="headerlink" title="SQL 注入示例"></a>SQL 注入示例</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM `user` WHERE `id`=<span class="subst">&#123;$id&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p>将传递参数改为</p><blockquote><p>1;DROP TABLE OrdersTable–</p></blockquote><h4 id="SQL-注入防御"><a href="#SQL-注入防御" class="headerlink" title="SQL 注入防御"></a>SQL 注入防御</h4><ul><li>使用预编译语句绑定变量(最佳方式)</li><li>使用安全的存储过程(也可能存在注入问题)</li><li>检查输入数据的数据类型(可对抗注入)</li><li>数据库最小权限原则</li></ul><h3 id="应用层拒绝服务攻击"><a href="#应用层拒绝服务攻击" class="headerlink" title="应用层拒绝服务攻击"></a>应用层拒绝服务攻击</h3><h4 id="DDOS-简介"><a href="#DDOS-简介" class="headerlink" title="DDOS 简介"></a>DDOS 简介</h4><p>DDOS 又称为分布式拒绝服务，全称是 Distributed Denial of Service。DDOS 本是利用合理的请求造成资源过载，导致服务不可用</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//ddos.png" alt="DDOS"></p><p>网络层 DDOS：伪造大量源 IP 地址，向服务器发送大量 SYN 包，因为源地址是伪造的，不会应答，大量消耗服务器资源(CPU 和内存)</p><h4 id="应用层-DDOS"><a href="#应用层-DDOS" class="headerlink" title="应用层 DDOS"></a>应用层 DDOS</h4><p>应用层 DDOS，不同于网络层 DDOS，由于发生在应用层，因此 TCP 三次握手已完成，连接已建立，发起攻击的 IP 地址都是真实的</p><ul><li>CC 攻击：对一些消耗资源较大的应用界面不断发起正常的请求，以消耗服务器端资源</li><li>限制请求频率：在应用中针对每个客户端做一个请求频率的限制</li></ul><h3 id="PHP-安全"><a href="#PHP-安全" class="headerlink" title="PHP 安全"></a>PHP 安全</h3><h4 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h4><p>include、require、include_once、require_once，使用这4个函数包含文件，该文件将作为 PHP 代码执行，PHP 内核不会在意该包含的文件是什么类型</p><h4 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h4><p>危险函数<code>exec</code>、<code>shell_exec</code>、<code>system</code>可以直接执行系统命令。<code>eval</code>函数可以执行 PHP 代码</p><h3 id="伪随机数和真随机数"><a href="#伪随机数和真随机数" class="headerlink" title="伪随机数和真随机数"></a>伪随机数和真随机数</h3><h4 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h4><p>通过一些数学算法生成的随机数，并非真正的随机数</p><h4 id="真随机数"><a href="#真随机数" class="headerlink" title="真随机数"></a>真随机数</h4><p>通过一些物理系统生成的随机数</p><h4 id="安全随机数"><a href="#安全随机数" class="headerlink" title="安全随机数"></a>安全随机数</h4><ul><li>Linux</li></ul><p>使用 /dev/random 或者 /dev/urandom 来生成随机数，只需读取即可</p><ul><li>PHP</li></ul><p>若是支持 openSSL 扩展，可以直接使用函数来生成随机数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">openssl_random_pseudo_bytes</span> ( <span class="keyword">int</span> <span class="variable">$length</span> [, <span class="keyword">bool</span> &amp;<span class="variable">$crypto_strong</span> ] ) : <span class="keyword">string</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 QA</title>
      <link href="/interview/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA/"/>
      <url>/interview/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="设计模式篇"><a href="#设计模式篇" class="headerlink" title="设计模式篇"></a>设计模式篇</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动</p><p>模式要素：模式名称、问题、解决方案、效果</p><h3 id="如何理解框架"><a href="#如何理解框架" class="headerlink" title="如何理解框架"></a>如何理解框架</h3><p>框架是构成一类特定软件可复用设计的一组相互协作的类。框架规定了应用的体系结构。定义了整体结构，类和对象的分隔，各部分的主要责任，类和对象怎么协作，以及控制流程。框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。框架记录了其应用领域的共同的设计决策。因而框架更强调设计复用，尽管框架常包括具体的立即可用的子类</p><h3 id="主要设计模式"><a href="#主要设计模式" class="headerlink" title="主要设计模式"></a>主要设计模式</h3><h4 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h4><ul><li>单例(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点</li><li>抽象工厂(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口</li><li>工厂方法(Factory Method)：定义一个用于创建对象的接口，让子类决定哪一个类实例化</li><li>原型(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象</li></ul><h4 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h4><ul><li>适配器(Adapter)：将一个类的接口转换成期望的另一个接口</li><li>代理(Proxy)：为其他对象提供一个代理以控制对这个对象的访问</li></ul><h4 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h4><ul><li>备忘录(Memento)：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态</li><li>观察者(Observer)：在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动刷新</li><li>策略(Strategy)：定义一个算法的系列，将其各个分装，并且使他们有交互性。策略模式使得算法在用户使用的时候能独立的改变</li></ul><h3 id="怎样选择设计模式"><a href="#怎样选择设计模式" class="headerlink" title="怎样选择设计模式"></a>怎样选择设计模式</h3><p>考虑设计模式是怎样设计问题的、浏览模式的意图部分、研究模式怎样互相关联、研究目的相似的模式、检查重新设计的原因、考虑你的设计中哪些是可变的</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。让类自身负责保存它的唯一实例，并提供一个访问该实例的方法。这就是单例模式</p><h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><ul><li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li><li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>对唯一实例的受控访问</li><li>避免全局变量污染</li><li>允许对操作和表示精化</li><li>允许可变数目的实例</li><li>比类操作更灵活</li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</p><p>“工厂”是创建产品(对象)的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码</p><h4 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h4><ul><li>一个系统要独立于它的产品的创建、组合和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>需要强调一系列相关的产品对象的设计以便进行联合使用时</li><li>提供一个产品类库，而只想显示它们的接口而不是实现时</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>具体产品从客户代码中被分离出来</li><li>容易改变产品的系列</li><li>将一个系列的产品族统一到一起创建</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在产品族中扩展新的产品是很困难的，它需要修改抽象工厂的接口</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类</p><h4 id="适用性-2"><a href="#适用性-2" class="headerlink" title="适用性"></a>适用性</h4><ul><li>当一个类不知道它所必须创建的对象的类的时候</li><li>当一个类希望由它的子类来指定它所创建的对象的时候</li><li>当类将创建对象的职责委托给多个帮忙子类的中的某一个，并且你希望将哪一个帮助子类是代理者者一信息局部化的时候</li></ul><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><h4 id="适用性-3"><a href="#适用性-3" class="headerlink" title="适用性"></a>适用性</h4><ul><li>你想使用一个已经存在的类，而它的接口不符合你的需求</li><li>你想创建一个可以复用的类，改类可以与其他不相关的类或不可预见(可能不兼容)的类协同工作</li><li>你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口</li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p><h4 id="适用性-4"><a href="#适用性-4" class="headerlink" title="适用性"></a>适用性</h4><ul><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用</li><li>当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不知道这些对象时紧密耦合的</li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化</p><h4 id="适用性-5"><a href="#适用性-5" class="headerlink" title="适用性"></a>适用性</h4><ul><li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法</li><li>需要使用一个算法的不同变体</li><li>算法使用客户不应该知道的数据。避免暴露复杂的、与算法相关的数据结构</li><li>一个类定义了多种行为，并且这些行为在类的操作中以多个条件语句的形式出现</li></ul><h3 id="OOP-思想"><a href="#OOP-思想" class="headerlink" title="OOP 思想"></a>OOP 思想</h3><p>面向对象程序设计(Object-oriented programming，OOP)是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>抽象类可以为项目提供一种组织机制。抽象类不能实例化，只能由具体(可实例化的类)继承抽象类的接口以及它的所有具体属性</p><p>与大多数抽象类一样，接口也有抽象方法。不过，不能像在抽象类中那样在接口中包含具体方法或变量</p><h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p><code>控制反转</code>（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做<code>依赖注入</code>（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>基于接口。实现特定接口以供外部容器注入所依赖类型的对象</li><li>基于 set 方法。实现特定属性的 public set 方法，来让外部容器调用传入所依赖类型的对象</li><li>基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>架构 QA</title>
      <link href="/interview/docs/10.%E6%9E%B6%E6%9E%84/QA/"/>
      <url>/interview/docs/10.%E6%9E%B6%E6%9E%84/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h2><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><h4 id="开放授权"><a href="#开放授权" class="headerlink" title="开放授权"></a>开放授权</h4><p>开放授权(OAuth)是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源(如照片，视频，联系人列表)，而无需将用户名和密码提供给第三方应用</p><h4 id="OAuth-2-0-1"><a href="#OAuth-2-0-1" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h4><p>OAuth 2.0 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。OAuth 2.0 关注客户端开发者的简易性，同时为 Web 应用、桌面应用、手机和智能设备提供专门的认证流程</p><h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><p>单点登录(Single sign-on，SSO)，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。这项功能通常是以轻型目录访问协议(LDAP)来实现，在服务器上会将用户信息存储到 LDAP 数据库中。相同的，单一退出(single sign-off)就是指，只需要单一的退出动作，就可以结束对于多个系统的访问权限</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低访问第三方网站的风险(不存储用户密码，或在外部管理)</li><li>减少因不同的用户名和密码组合而带来的密码疲劳</li><li>减少为相同的身份重新输入密码所花费的时间</li><li>因减少与密码相关的调用IT服务台的次数而降低IT成本</li></ul><h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制</p><h4 id="REST-优点"><a href="#REST-优点" class="headerlink" title="REST 优点"></a>REST 优点</h4><ul><li>可更高效利用缓存来提高响应速度</li><li>通讯本身的无状态性可以让不同的服务器的处理一系列请求中的不同请求，提高服务器的扩展性</li><li>浏览器即可作为客户端，简化软件需求</li><li>相对于其他叠加在 HTTP 协议之上的机制，REST 的软件依赖性更小</li><li>不需要额外的资源发现机制</li><li>在软件技术演进中的长期的兼容性更好</li></ul><h3 id="API-版本兼容"><a href="#API-版本兼容" class="headerlink" title="API 版本兼容"></a>API 版本兼容</h3><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>API 服务可以提供多个 API 接口，可以在 API 接口级层增加版本控制策略</p><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>将服务更新到新的版本时客户端不受影响</p><ul><li><p>向 API 服务定义添加 API 接口</p></li><li><p>向 API 接口添加方法</p></li><li><p>向请求消息添加字段</p></li><li><p>向响应消息添加字段</p></li><li><p>向枚举添加值</p></li><li><p>移除或重命名服务、字段、方法或枚举值</p></li><li><p>更改字段的类型</p></li></ul><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JSON Web Token 是一种跨域认证解决方案</p><h3 id="画出-PHP-业务架构图"><a href="#画出-PHP-业务架构图" class="headerlink" title="画出 PHP 业务架构图"></a>画出 PHP 业务架构图</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//PHP%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="PHP业务架构图"></p><h3 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h3><h4 id="LVS-介绍"><a href="#LVS-介绍" class="headerlink" title="LVS 介绍"></a>LVS 介绍</h4><p>Linux 虚拟服务器(Linux Virtual Server，LVS)是一个虚拟的服务器集群系统，用于实现负载均衡</p><p>LVS集群采用 IP 负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服 务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序</p><h4 id="LVS-体系结构"><a href="#LVS-体系结构" class="headerlink" title="LVS 体系结构"></a>LVS 体系结构</h4><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//lvs-architecture.jpg" alt="LVS集群的体系结构"></p><ul><li>负载调度器（load balancer），它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个IP地址（我们可称之为虚拟IP地址）上的</li><li>服务器池（server pool），是一组真正执行客户请求的服务器，执行的服务有WEB、MAIL、FTP和DNS等</li><li>共享存储（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务</li></ul><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//lvs-web-cluster.jpg" alt="基于LVS的Web集群"></p><h3 id="Ngnix"><a href="#Ngnix" class="headerlink" title="Ngnix"></a>Ngnix</h3><p>Nginx 是异步架构的 Web 服务器，也可以用作反向代理、负载均衡器和 HTTP 缓存</p><h4 id="Nginx-特点"><a href="#Nginx-特点" class="headerlink" title="Nginx 特点"></a>Nginx 特点</h4><ul><li>更快：单次请求响应更快，高并发可以更快的处理响应</li><li>高拓展性：设计极具扩展性，由多个不同功能、不同层次、不同类型且耦合度极低的模块组成</li><li>高可靠性：很多高流量网站都在核心服务器上大规模使用 Nginx</li><li>低内存消耗：一般1万个非活跃的 HTTP Keep-Alive 连接在 Nginx 中仅消耗2.5MB内存</li><li>高并发：单机支持10万以上的并发连接</li><li>热部署：master 管理进程与 worker工作进程的分离设计，使得 Nginx 能够支持热部署</li><li>开源协议：使用 BSD 许可协议，免费使用，且可修改源码</li></ul><h4 id="对比-Apache"><a href="#对比-Apache" class="headerlink" title="对比 Apache"></a>对比 Apache</h4><p>Apache 有许多优点，如稳定、开源、跨平台，但它出现的时间太长了，在它兴起的年代，互联网的产业规模远远比不上现在，所以它被设计成了一个重量级、不支持高并发的 Web 服务器。在 Apache 服务器上，如果有数以万计的并发 HTTP 请求同时访问，就会导致服务器上消耗大量内存，操作系统内核对成百上千的 Apache 进程做进程间切换也会消耗大量 CPU 资源，并导致 HTTP 请求的平均响应速度降低，这些都决定了 Apache 进程不可能成为高性能 Web 服务器，这也促使了 Lighttpd 和 Nginx 的出现</p><h4 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h4><ul><li>基本配置</li></ul><table><thead><tr><th>配置项</th><th>默认</th><th>用途</th></tr></thead><tbody><tr><td>daemon on|off;</td><td>on</td><td>是否以守护进程方式运行 Nginx</td></tr><tr><td>master_process on|off;</td><td>on</td><td>是否以 master/worker 方式工作</td></tr><tr><td>error_log /path/file level;</td><td>logs/error.log error;</td><td>error 日志的设置</td></tr><tr><td>include /path/file;</td><td></td><td>嵌入其他配置文件</td></tr><tr><td>pid path/file</td><td>logs/nginx.pid</td><td>pid 文件的路径</td></tr><tr><td>user username [groupname];</td><td>nobody nobody</td><td>Nginx worker 进程运行的用户及用户组</td></tr><tr><td>worker_processes number;</td><td>4</td><td>Nginx worker 进程个数</td></tr><tr><td>worker_connections number;</td><td></td><td>每个 worker 的最大连接数</td></tr><tr><td>worker_cpu_affinity cpumask [cpumask…]</td><td>1000 0100 0010 0001;</td><td>绑定 Nginx worker 进程到指定的 CPU 内核</td></tr><tr><td>accept_mutex on|off;</td><td>on</td><td>是否打开 accept 锁</td></tr><tr><td>accept_mutex_delay Nms;</td><td>500ms</td><td>再次获取锁延迟时间</td></tr></tbody></table><ul><li>Web 服务器配置</li></ul><p>配置块：http 块、server 块、location 块、upstream 块</p><table><thead><tr><th>配置项</th><th>默认</th><th>用途</th><th>配置块</th></tr></thead><tbody><tr><td>listen 80;</td><td></td><td>监听端口</td><td>server</td></tr><tr><td>server_name name;</td><td>“”</td><td>主机名称</td><td>server</td></tr><tr><td>root path;</td><td>html</td><td>以 root 方式设置资源路径</td><td>http、server、location</td></tr><tr><td>index file …;</td><td>index index.html</td><td>访问首页</td><td>http、server、location</td></tr><tr><td>error_page 404 /404.html</td><td></td><td>根据 HTTP 返回码重定向页面</td><td>http、server、location</td></tr><tr><td>try_files path1 [path2] uri;</td><td></td><td>try_files</td><td>server、location</td></tr><tr><td>location [=|<del>|</del>*|^~|@]/uri/{…}</td><td>location</td><td>server</td><td></td></tr></tbody></table><blockquote><p>location 参数说明：<code>=</code>表示完全匹配、<code>~</code>表示字母大小写敏感、<code>~*</code>表示忽略字母大小写、<code>^~</code>表示只需匹配前半部分、<code>@</code>表示 Nginx 服务内部之间重定向；参数支持正则表达式</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* \.(gif|jpg|jepg)$</span> &#123;</span><br><span class="line">    <span class="comment"># 匹配以 .gif、.jpg、.jpeg 结尾的请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>网络连接配置</li></ul><table><thead><tr><th>配置项</th><th>默认</th><th>用途</th><th>配置块</th></tr></thead><tbody><tr><td>client_header_timeout time;</td><td>60</td><td>读取 HTTP 头部的超时时间</td><td>http、server、location</td></tr><tr><td>client_body_timeout time;</td><td>60</td><td>读取 HTTP 包体的超时时间</td><td>http、server、location</td></tr><tr><td>send_timeout time;</td><td>60</td><td>发送响应的超时时间</td><td>http、server、location</td></tr><tr><td>lingering_close off|on|always;</td><td>on</td><td>该配置控制 Nginx 关闭用户连接的方式</td><td>http、server、location</td></tr><tr><td>lingering_time time;</td><td>30s</td><td>lingering_time</td><td>http、server、location</td></tr></tbody></table><ul><li>客户端请求配置</li></ul><table><thead><tr><th>配置项</th><th>默认</th><th>用途</th><th>配置块</th></tr></thead><tbody><tr><td>limit_except method …{…}</td><td></td><td>按 HTTP 方法名限制用户请求</td><td>location</td></tr><tr><td>client_max_body_size size;</td><td>1m</td><td>HTTP 请求包体的最大值</td><td>http、server、location</td></tr><tr><td>limit_rate speed;</td><td>0</td><td>对请求的限速</td><td>http、server、location</td></tr><tr><td>limit_rate_after time;</td><td>1m</td><td>发送响应长度超过1m后限速</td><td>http、server、location</td></tr></tbody></table><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理(reverse proxy)方式是指代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络中的上游服务器，并将从上游服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外的表现就是一个 Web 服务器</p><blockquote><p>反向代理服务器必须能够处理大量并发请求</p></blockquote><ul><li>Nginx 反向代理</li></ul><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//reverse-proxy.png" alt="反向代理"></p><p>当客户端发来 HTTP 请求时，Nginx 并不会立即转发到上游服务器，而是先把用户的请求(包括 HTTP 包体)完整地接受到 Nginx 所在服务器的硬盘或者内存中，然后再向上游服务器发起连接，把缓存的客户端请求转发到上游服务器</p><p>缺点是延长了请求的处理时间，并增加了用于缓存请求内容的内存和磁盘空间。优点则是降低了上游服务器的负载，尽量把压力放在了 Nginx 服务器上</p><ul><li>反向代理配置</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    ip_hash; <span class="comment">#保持相同 IP 用户落点一致</span></span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend3.example.com down; <span class="comment">#机器暂时不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h3><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h3 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a>服务注册发现</h3><h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>为了确保数据库产品的稳定性，很多数据库拥有双机热备功能。也就是，第一台数据库服务器，是对外提供增删改业务的生产服务器；第二台数据库服务器，主要进行读的操作</p><p>主数据库(master)处理事务性增、改、删操作(INSERT、UPDATE、DELETE)，从数据库(slave)处理 SELECT 查询操作</p><h3 id="数据库拆分"><a href="#数据库拆分" class="headerlink" title="数据库拆分"></a>数据库拆分</h3><p>数据库拆分有两种方式，一个是<code>垂直拆分</code>，一个是<code>水平拆分</code>。垂直拆分就是把一个数据库中不同业务单元的数据分到不同的数据库里面，水平拆分根据一定的规则把同一业务单元的数据拆分到多个数据库中</p><h4 id="垂直拆分影响"><a href="#垂直拆分影响" class="headerlink" title="垂直拆分影响"></a>垂直拆分影响</h4><ul><li>单机的 ACID 保证被打破了</li><li>一些 Join 操作会变得比较困难</li><li>靠外键去进行约束的场景会受影响</li></ul><h4 id="水平拆分影响"><a href="#水平拆分影响" class="headerlink" title="水平拆分影响"></a>水平拆分影响</h4><ul><li>单机的 ACID 保证被打破了</li><li>一些 Join 操作会变得比较困难</li><li>靠外键去进行约束的场景会受影响</li><li>依赖单库的自增序列生成唯一 ID 受影响</li><li>针对单个逻辑意义上的表的查询要跨库了</li></ul><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式的不同节点上</p><h3 id="ID-生成器"><a href="#ID-生成器" class="headerlink" title="ID 生成器"></a>ID 生成器</h3><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>一致性哈希把节点对应的哈希值变成了一个范围，而不再是离散的。在一致性哈希中，把整个哈希值的范围定义得非常大，然后把这个范围分配给现有的节点</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设哈希值范围是从0到100，四个节点为：[0,25)、[25,50)、[50,75)、[75,100]</p><blockquote><p>第二个节点退出，节点变为：[0,25)、[25,75)、[75,100]，只需要把第二节点接管过来即可，其他节点数据未受影响</p></blockquote><blockquote><p>在第二和第三节点之间增加节点，节点变为：[0,25)、[25,50)、[50,63)、[63,75)、[75,100]，第三节点部分数据未收影响，另一部分数据给新增节点管理，其他节点数据未受影响</p></blockquote><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//consistent-hash.png" alt="一致性哈希"></p><h3 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h3><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片(sharding)来进行数据库共享，并提供复制和故障转移功能</p><p>Redis 集群中的节点分为主节点(master)和从节点(slave)，其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求</p><p>Redis 集群为了保证一致性而牺牲了一部分容错性。系统在保证对网络短线和节点失效具有有限抵抗力的前提下，尽可能地保持数据的一致性</p><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，以此来检测对方是否在线，如果接收 PING 消息的节点没有在规定的消息内，向发送 PING 消息的节点返回 PONG 消息，那么发送 PING 消息的节点就会将接收 PING 消息的节点标记为疑似下线(probable fail, PFAIL)</p><p>如果一个集群里面，半数以上负责处理槽的主节点将某个主节点 x 报告为疑似下线，那么这个主节点 x 将被标记为已下线(FAIL)，将主节点 x 标记为已下线的节点会向集群广播一条关于主节点 x 的 FAIL 消息，所有收到这条 FAIL 消息的节点都会立即将主节点 x 标记为已下线</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><ul><li>复制下线主节点的所有从节点里面，会有一个从节点被选中</li><li>被选中的从节点会执行 SLAVEOF on one 命令，成为新的主节点</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li><li>新的主节点向集群广播一条 PONG 消息，这条 PONG 消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点</li><li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成</li></ul><h4 id="选举新的主节点"><a href="#选举新的主节点" class="headerlink" title="选举新的主节点"></a>选举新的主节点</h4><p>新的主节点是通过选举产生的，基于 Raft 算法的领头选举(leader election)方法实现</p><ul><li>集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票</li><li>当从节点发现自己正在复制的主节点进入已下线状态，从节点会向集群广播一条消息，要求所有收到消息具有投票权的主节点向这个从节点投票</li><li>具有投票权的主节点尚未投票给其他节点，那么主节点将回应消息，表示主节点支持从节点成为新的主节点</li><li>每个参与选举的从节点收到消息，统计自己获得多少主节点的支持</li><li>如果集群有 N 个具有投票权的主节点，那么当一个从节点收集到大于等于<code>N/2 + 1</code>张支持票，这个从节点就会选为新的主节点</li><li>如果从节点没有收集到足够多的支持票，那么集群将再次进行选举，直到选出新的主节点为止</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列(Message queue)是一种进程间通信或同一进程的不同线程间的通信方式。消息的发送者和接受者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>Kafka 是一个开源的流处理平台，目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台</p><h4 id="Kafka-特点"><a href="#Kafka-特点" class="headerlink" title="Kafka 特点"></a>Kafka 特点</h4><ul><li>可靠性： Kafka 是分布式的、可分区的、数据可备份的、高度容错的</li><li>可扩展性： 在无需停机的情况下实现轻松扩展</li><li>消息持久性： Kafka 支持将消息持久化到本地磁盘</li><li>性能：Kafka 的消息发布订阅具有很高的吞吐量，即便存储了 TB 级的消息，它依然能保持稳定的性能</li></ul><h3 id="消息中间件对比"><a href="#消息中间件对比" class="headerlink" title="消息中间件对比"></a>消息中间件对比</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//mo-middleware.png" alt="消息中间件"></p><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p>Zookeeper 是一个为分布式应用提供一致性服务的开源软件，提供功能包括：分布式配置服务、同步服务和命令注册</p><h3 id="穿透、雪崩"><a href="#穿透、雪崩" class="headerlink" title="穿透、雪崩"></a>穿透、雪崩</h3><h3 id="限流-木桶、令牌桶"><a href="#限流-木桶、令牌桶" class="headerlink" title="限流(木桶、令牌桶)"></a>限流(木桶、令牌桶)</h3><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><h3 id="语言对比"><a href="#语言对比" class="headerlink" title="语言对比"></a>语言对比</h3><p>PHP VS Java<br>PHP VS Python<br>PHP VS Golang</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>业务 QA</title>
      <link href="/interview/docs/11.%E4%B8%9A%E5%8A%A1/QA/"/>
      <url>/interview/docs/11.%E4%B8%9A%E5%8A%A1/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="业务篇"><a href="#业务篇" class="headerlink" title="业务篇"></a>业务篇</h2><p>重点介绍一个项目，分工，职责</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>其他 QA</title>
      <link href="/interview/docs/12.%E9%9D%9E%E6%8A%80%E6%9C%AF/QA/"/>
      <url>/interview/docs/12.%E9%9D%9E%E6%8A%80%E6%9C%AF/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="非技术篇"><a href="#非技术篇" class="headerlink" title="非技术篇"></a>非技术篇</h2><h3 id="Git-与-SVN-区别"><a href="#Git-与-SVN-区别" class="headerlink" title="Git 与 SVN 区别"></a>Git 与 SVN 区别</h3><h3 id="Git-基本使用"><a href="#Git-基本使用" class="headerlink" title="Git 基本使用"></a>Git 基本使用</h3><h3 id="SVN-基本使用"><a href="#SVN-基本使用" class="headerlink" title="SVN 基本使用"></a>SVN 基本使用</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试 QA</title>
      <link href="/interview/docs/13.%E9%9D%A2%E8%AF%95/QA/"/>
      <url>/interview/docs/13.%E9%9D%A2%E8%AF%95/QA/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="面试篇"><a href="#面试篇" class="headerlink" title="面试篇"></a>面试篇</h2><h3 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h3><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h3><h3 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h3><h3 id="准备问题"><a href="#准备问题" class="headerlink" title="准备问题"></a>准备问题</h3><h3 id="劳动合同"><a href="#劳动合同" class="headerlink" title="劳动合同"></a>劳动合同</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 QA</title>
      <link href="/interview/docs/14.%E5%85%B6%E4%BB%96/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/interview/docs/14.%E5%85%B6%E4%BB%96/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="数据结构与算法篇"><a href="#数据结构与算法篇" class="headerlink" title="数据结构与算法篇"></a>数据结构与算法篇</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="解决问题的效率"><a href="#解决问题的效率" class="headerlink" title="解决问题的效率"></a>解决问题的效率</h4><p>解决问题方法的效率，跟<code>数据的组织方式</code>有关，跟<code>空间的利用效率</code>有关，也跟<code>算法的巧妙程度</code>有关</p><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p><code>抽象数据类型</code>(Abstract Data Type，ADT)是一种对”数据类型”的描述，这种描述是”抽象”的</p><p>数据类型描述内容：一是<code>数据对象集</code>，二是<code>与数据集合相关联的操作集</code></p><h4 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h4><p>算法是一个<code>有限指令集</code>，它接受一些输入，产生输出，并在一定的有限步骤之后终止</p><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><ul><li>空间复杂度 S(n)：根据算法写成的程序在执行时占用存储单元的长度</li><li>时间复杂度 T(n)：根据算法写成的程序在执行时耗时时间的长度</li></ul><h4 id="分析算法效率"><a href="#分析算法效率" class="headerlink" title="分析算法效率"></a>分析算法效率</h4><ul><li>最坏情况的复杂度 T<sub>worst</sub>(n)</li><li>平均复杂度 T<sub>avg</sub>(n)</li></ul><p>拓展阅读 <a href="./02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0.md">《数据结构与算法概述》</a></p><h3 id="2-实现基础"><a href="#2-实现基础" class="headerlink" title="2. 实现基础"></a>2. 实现基础</h3><p>数据结构的处理方法是从这些具体应用中<code>抽象</code>出共性的数据组织与操作方式，进而采用某种具体的程序设计语言<code>实现</code>相应的数据存储与操作</p><h4 id="数据存储基础"><a href="#数据存储基础" class="headerlink" title="数据存储基础"></a>数据存储基础</h4><ul><li>数组</li></ul><p>数组是最基本的构造类型，它是一组相同类型数据的有序集合</p><ul><li>结构</li></ul><p>结构类型是一种允许把一些数据分量聚合成一个整体的数据类型，它能够把有内在联系的不同类型的数据统一成一个整体，使它们相互关联</p><ul><li>链表</li></ul><p>链表是一种常见而重要的基础数据结构，也是实现复杂数据结构的重要手段</p><h4 id="流程控制基础"><a href="#流程控制基础" class="headerlink" title="流程控制基础"></a>流程控制基础</h4><p>程序设计语言除了能够表达各种各样的数据外，还必须提供一种手段来表达数据处理的过程，即<code>程序的控制过程</code></p><p>按照结构化程序设计的观点，任何程序都可以将程序模块通过三种基本的控制结构进行组合来实现。这三种基本的控制结构是<code>顺序</code>、<code>分支</code>和<code>循环</code></p><p>拓展阅读 <a href="./02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80.md">《数据结构实现基础》</a></p><h3 id="3-线性结构"><a href="#3-线性结构" class="headerlink" title="3. 线性结构"></a>3. 线性结构</h3><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p>线性表(Linear List)是由同一类型的数据元素构成的有序序列的线性结构</p><p>操作集：初始化、指定查找、查找、插入、删除、求表长</p><p>实现方式：顺序存储、链式存储</p><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆栈(Stack)可以认为是具有一定约束的线性表，插入和删除操作都作用在一个称为栈顶(Top)的端点位置</p><p>操作集：生成栈、判断是否满、压栈、判断是否空、出栈</p><p>实现方式：顺序存储、链式存储</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列(Queue)是一个有序线性表，队列的插入和删除操作分别是在线性表的两个不同的端点进行</p><p>操作集：生成队列、判断是否满、压入队列、判断是否为空，移除队列</p><p>实现方式：顺序存储、链式存储</p><h3 id="4-树"><a href="#4-树" class="headerlink" title="4. 树"></a>4. 树</h3><p>树(Tree)是一种十分重要且广泛应用的非线性数据结构</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>五种基本形态：空二叉树、只有根节点的二叉树、只有根节点和左子树T<sub>L</sub>的二叉树、只有根节点和右子树T<sub>R</sub>的二叉树、具有根节点、左子树T<sub>L</sub>和右子树T<sub>R</sub>的二叉树</p><p>其它二叉树：斜二叉树、满二叉树、完美二叉树</p><p>实现方式：顺序存储、链式存储</p><p>操作集：创建二叉树、判断是否为空、遍历(先序遍历、中序遍历、后序遍历、层序遍历)</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树(Binary Search Tree)是一种对排序和查找都很有用的特殊二叉树</p><p>定义：左子树 &lt; 根节点 &lt; 右子树</p><p>实现方式：一般用链表实现</p><p>操作集：创建二叉树、判断是否为空、遍历、查找、查找最小元素、查找最大元素、插入、删除</p><p>时间复杂度：最好 O(logN) 最差 O(N)</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树(Balanced Binary Tree)又称为 AVL 树，AVL 树的插入、删除、查找操作均可在O(logN)时间内完成</p><p>定义：任一结点的左、右子树均为 AVL 树；根节点左、右子树高度差的绝对值不超过1</p><p>平衡二叉树的调整：单旋调整、双旋调整</p><h4 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h4><p>堆及其操作、哈夫曼树、集合及其运算</p><h3 id="5-散列查找"><a href="#5-散列查找" class="headerlink" title="5. 散列查找"></a>5. 散列查找</h3><p>符号表(SymbolTable)是名字(Name)-属性(Attribute)对的集合，符号表最核心的操作是查找、插入和删除</p><p>操作集：创建符号表、查找指定名字是否存在、获取指定名字对应属性、更改指定名字对应属性、插入新名字及其属性、删除名字及其属性</p><p>使用散列技术实现符号表的操作集，符号表也叫做<code>散列表</code>(Hash Table，即哈希表)，散列(Hashing)是一种重要的查找方法</p><p>散列函数(哈希函数)：在查找数据时，由函数 h 对给定值 key 计算出地址，将 key 与该地址单元中数据对象关键字进行比较，确定查找是否成功。散列法又称为”关键字-地址转换法”</p><p>关键字分类：一般把关键字分为<code>数字型关键字</code>和<code>字符串型关键字</code></p><h4 id="数字型关键字的散列构造"><a href="#数字型关键字的散列构造" class="headerlink" title="数字型关键字的散列构造"></a>数字型关键字的散列构造</h4><ul><li>直接定址法</li></ul><p>h(key) = a x key + b (a、b为常数)</p><ul><li>除留余数法</li></ul><p>h(key) = key mod p</p><ul><li>数字分析法</li></ul><p>h(key) = atoi(key + 7)</p><h4 id="字符串型关键字的散列构造"><a href="#字符串型关键字的散列构造" class="headerlink" title="字符串型关键字的散列构造"></a>字符串型关键字的散列构造</h4><ul><li>ASCII 码加和法</li></ul><p>h(key) = (Σkey[i]) mode TableSize</p><h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><ul><li>开放地址法</li></ul><p>开放地址法就是一旦产生了冲突，即该地址已经存放了其它数据元素，就去寻找另一个空的散列地址</p><ul><li>链地址法</li></ul><p>链地址法是将所有关键词为同义词的数据对象通过结点链接存储在同一个单链表中</p><ul><li>影响冲突的因素</li></ul><p>散列函数是否均匀、处理冲突的方法、散列表的装填因子 α</p><h3 id="6-图"><a href="#6-图" class="headerlink" title="6. 图"></a>6. 图</h3><p>图的结构是任意两个数据对象之前都可能存在某种特定关系的数据结构</p><h3 id="7-排序"><a href="#7-排序" class="headerlink" title="7. 排序"></a>7. 排序</h3><p>没有一种排序算法在任何情况下都是最优的，必须根据实际情况选择最优的算法来解决问题</p><p>算法稳定性：在一组待排序记录中，如果存在任意两个相等的记录 R 和 S，且在待排序记录中 R 在 S 前，如果在排序后 R 依然在 S 前，即它们的前后位置在排序前后不发生改变，则称为排序算法为稳定的</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul><li>简单选择排序</li></ul><p>简单选择排序(Simple Selection Sort)是一种直观的排序算法，在未排序的序列中，选出最小的元素和序列的首位元素交换，接下来在剩下的未排序序列中再选出最小元素与序列的第二位元素交换，依次类推，最后形成从小到大的已排序序列</p><p>时间复杂度：O(N<sup>2</sup>)</p><ul><li>堆排序</li></ul><p>将无序的序列生成一个最大堆，将堆顶元素与最后一个元素对换位置，将剩下元素生成最大堆，依次进行元素交换并生成最大堆</p><p>时间复杂度：O(NlogN)<br>空间复杂度：O(1)</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul><li>简单插入排序</li></ul><p>将待排序的一组序列分为已排好序和未排序的两个部分，初始状态时，已排序序列仅包含第一个元素，未排序序列中的元素为除了第一个以外N-1个元素；此后将未排序序列中的元素逐一插入到已排序的序列中。如此往复，经过N-1次插入后，未排序序列中元素个数为0，则排序完成</p><p>时间复杂度：O(N<sup>2</sup>) 稳定排序</p><ul><li>希尔排序</li></ul><p>将待排序的一组元素按一定间隔分为若干个序列，分别进行插入排序。开始时设置的”间隔”较大，在每轮排序中将间隔逐步减小，直到”间隔”为1，也就是最后一步是进行简单插入排序</p><p>时间复杂度：和增量序列的选取有关 非稳定排序</p><h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><ul><li>冒泡排序</li></ul><p>对元素个数为 N 的待排序序列进行排序时，共进行N-1次循环。在第 k 次循环中，对从第1到第N-k个元素从前往后进行比较，每次比较相邻的两个元素，若前一个元素大于后一个元素，则两者互换位置，否则保持位置不变</p><p>时间复杂度：O(N<sup>2</sup>)</p><ul><li>快速排序</li></ul><p>将未排序元素根据一个作为基准的”主元”分为两个子序列，其中一个子序列的记录均大于主元，而另一个子序列均小于主元，然后递归地对这两个子序列用类似的方法进行排序</p><p>时间复杂度：O(Nlog<sub>2</sub>N)</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>将大小为 N 的序列看成 N 个长度为1的子序列，接下来将相邻子序列两两进行归并操作，形成N/2(+1)个长度为2(或1)的有序子序列；然后再继续进行相邻子序列两两归并操作，如果一直循环，直到剩下1个长度为 N 的序列，则该序列为原序列完成排序后的结果</p><p>时间复杂度：O(Nlog<sub>2</sub>N)<br>空间复杂度：O(N)</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li>桶排序</li></ul><p>如果已知 N 个关键字的取值范围是在 0 到 M-1 之间，而 M 比 N 小的多，则桶排序算法将关键字的每个取值建立一个”桶”，即建立 M 个桶，在扫描 N 个关键字时，将每个关键字放入相应的桶中，然后按桶的顺序收集一遍就自然有序了</p><ul><li>基数排序</li></ul><p>基数排序是桶排序的一种推广，它所考虑的待排记录包含不止一个关键字</p><h3 id="8-补充"><a href="#8-补充" class="headerlink" title="8. 补充"></a>8. 补充</h3><h3 id="9-经典算法题"><a href="#9-经典算法题" class="headerlink" title="9. 经典算法题"></a>9. 经典算法题</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络 QA</title>
      <link href="/interview/docs/14.%E5%85%B6%E4%BB%96/01.%E7%BD%91%E7%BB%9C/"/>
      <url>/interview/docs/14.%E5%85%B6%E4%BB%96/01.%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与简答"><a href="#问题与简答" class="headerlink" title="问题与简答"></a>问题与简答</h1><h2 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h2><h3 id="1-计算机网络体系结构"><a href="#1-计算机网络体系结构" class="headerlink" title="1. 计算机网络体系结构"></a>1. 计算机网络体系结构</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-architecture-02.png" alt="计算机网络体系结构"></p><h4 id="各层作用"><a href="#各层作用" class="headerlink" title="各层作用"></a>各层作用</h4><ul><li>应用层：应用层协议定义的是应用进程间通信和交互的规则</li><li>运输层：运输层的任务就是负责向<code>两台主机中进程之间的通信</code>提供<code>通用的数据传输</code>服务</li><li>网络层：把运输层产生的报文段或用户数据报封装成<code>分组</code>或<code>包</code>进行传送</li><li>数据链路层：将网络层交下来的 IP 数据报组装成帧，并在两个相邻结点间的链路上传送</li><li>物理层：利用物理媒体以<code>比特</code>形式传送数据</li></ul><p>拓展阅读 <a href="./01.%E7%BD%91%E7%BB%9C/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">《计算机网络体系结构》</a></p><h3 id="2-UDP-的主要特点"><a href="#2-UDP-的主要特点" class="headerlink" title="2. UDP 的主要特点"></a>2. UDP 的主要特点</h3><ul><li>UDP 是<code>无连接的</code>，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延</li><li>UDP 使用<code>尽最大努力交付</code>，即不保证可靠交付，主机不需要维持复杂的连接状态表</li><li>UDP 是<code>面向报文</code>的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是<code>保留这些报文的边界</code></li><li>UDP <code>没有拥塞控制</code>，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP 的<code>首部开销小</code>，只有8个字节，比 TCP 的20个字节的首部要短</li></ul><p>拓展阅读 <a href="./01.%E7%BD%91%E7%BB%9C/02.%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP.md">《用户数据报协议 UDP》</a></p><h3 id="3-TCP-的主要特点"><a href="#3-TCP-的主要特点" class="headerlink" title="3. TCP 的主要特点"></a>3. TCP 的主要特点</h3><ul><li>TCP 是<code>面向连接的运输层协议</code>。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接</li><li>每一条 TCP 连接只能有两个<code>端点</code>，每一条 TCP 连接只能是<code>点对点</code>的(一对一)</li><li>TCP 提供<code>可靠交付</code>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达</li><li>TCP 提供<code>全双工通信</code>。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据</li><li><code>面向字节流</code>。TCP 中的“流”指的是<code>流入到进程或从进程流出的字节序列</code></li></ul><p>拓展阅读 <a href="./01.%E7%BD%91%E7%BB%9C/03.%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP.md">《传输控制协议 TCP》</a></p><h3 id="4-简述三报文握手建立-TCP-连接"><a href="#4-简述三报文握手建立-TCP-连接" class="headerlink" title="4. 简述三报文握手建立 TCP 连接"></a>4. 简述三报文握手建立 TCP 连接</h3><ul><li>服务器进程先创建传输控制块 TCB，并处于监听状态，等待客户端的连接请求;此时状态为LISTEN</li><li>客户端创建传输控制块 TCB，并向服务器发出连接请求报文段SYN,此时状态为SYN-SEND</li><li>服务器收到连接请求报文段后，如同意建立连接，则发送确认报文段ACK,此时状态为SYN-RECV，并且客户端链接进入半链接队列，系统参数/proc/sys/net/ipv4/tcp_max_syn_backlog</li><li>客户端进程收到服务器的确认报文段后，立即回复确认报文段ACK，并进入已建立连接状态，此时状态为ESTABLISHED</li><li>服务器收到确认报文段之后，也进入已建立连接状态，此时状态为ESTABLISHED，并且客户端链接进入全连接队列，系统参数/proc/sys/net/core/somaxconn</li></ul><blockquote><p>传输控制块 TCB(Transmission Control Block)存储了每一个连接中的一些重要信息</p></blockquote><h3 id="5-建立-TCP-连接为什么最后还要发送确认"><a href="#5-建立-TCP-连接为什么最后还要发送确认" class="headerlink" title="5. 建立 TCP 连接为什么最后还要发送确认"></a>5. 建立 TCP 连接为什么最后还要发送确认</h3><p>这主要是为了防止已失效的连接请求报文段突然又传到了 TCP 服务器，避免产生错误<br>简述为了保证数据的正确性和顺序</p><h3 id="6-简述-TCP-连接的释放"><a href="#6-简述-TCP-连接的释放" class="headerlink" title="6. 简述 TCP 连接的释放"></a>6. 简述 TCP 连接的释放</h3><ul><li>客户端应用进程发出连接释放报文段，并停止再发送数据，进入 FIN-WAIT-1(终止等待1)状态，等待服务器确认</li><li>服务器收到连接释放报文段后即发出确认，进入 CLOSE-WAIT(关闭等待)状态，服务器若发送数据，客户端扔要接收</li><li>客户端收到来自服务器的确认后，进入 FIN-WAIT-2(终止等待2)状态，等待服务器发出连接释放报文段</li><li>服务器没有要发送的数据，发出连接释放报文段，进入 LAST-ACK(最后确认)状态，等待客户端确认</li><li>客户端收到连接释放报文段后，发出确认，进入 TIME-WAIT(时间等待)状态，经过时间等待计时器设置的时间 2MSL 后，进入 CLOSED(关闭) 状态</li><li>服务器收到客户端报文段后，进入 CLOSED 状态</li></ul><h3 id="7-TIME-WAIT-是什么，为什么必须等待-2MLS"><a href="#7-TIME-WAIT-是什么，为什么必须等待-2MLS" class="headerlink" title="7. TIME-WAIT 是什么，为什么必须等待 2MLS"></a>7. TIME-WAIT 是什么，为什么必须等待 2MLS</h3><p>TIME-WAIT 是一种 TCP 状态。等待 2MLS 可以保证客户端最后一个报文段能够到达服务器，如果未到达，服务器则会超时重传连接释放报文段，使得客户端、服务器都可以正常进入到 CLOSE(关闭) 状态</p><h3 id="8-TCP-粘包问题"><a href="#8-TCP-粘包问题" class="headerlink" title="8. TCP 粘包问题"></a>8. TCP 粘包问题</h3><h4 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h4><p>在 TCP 这种字节流协议上做<code>应用层分包</code>是网络编程的基本需求。分包指的是在发生一个消息(message)或一帧(frame)数据时，通过一定的处理，让接收方能从字节流中识别并截取(还原)出一个个消息。因此，“粘包问题”是个伪命题</p><h4 id="长连接分包"><a href="#长连接分包" class="headerlink" title="长连接分包"></a>长连接分包</h4><ul><li>消息长度固定</li><li>使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\r\n”为字段的分隔符</li><li>在每条消息的头部加一个长度字段，这恐怕是最常见的做法</li><li>利用消息本身的格式来分包，例如 XML 格式的消息中 <code>&lt;root&gt;</code>…<code>&lt;/root&gt;</code> 的配对，或者 JSON 格式中的 { … } 的配对。解析这种消息格式通常会用到状态机(state machine)</li></ul><p>拓展阅读 <a href="./01.%E7%BD%91%E7%BB%9C/04.TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.md">《TCP粘包拆包》</a></p><h3 id="9-UDP、TCP-区别，适用场景"><a href="#9-UDP、TCP-区别，适用场景" class="headerlink" title="9. UDP、TCP 区别，适用场景"></a>9. UDP、TCP 区别，适用场景</h3><table><thead><tr><th>对比项</th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>连接性</td><td>无连接</td><td>面向连接</td></tr><tr><td>可靠性</td><td>不可靠</td><td>可靠</td></tr><tr><td>报文</td><td>面向报文-数据报模式</td><td>面向字节流-流模式</td></tr><tr><td>双工性</td><td>一对一、一对多、多对一、多对多</td><td>全双工</td></tr><tr><td>流量控制</td><td>无</td><td>有(滑动窗口)</td></tr><tr><td>拥塞控制</td><td>无</td><td>有(慢开始、拥塞避免、快重传、快恢复)</td></tr><tr><td>传输速度</td><td>快</td><td>慢</td></tr><tr><td>资源要求</td><td>较少</td><td>较多</td></tr><tr><td>首部开销</td><td>8字节</td><td>20字节</td></tr><tr><td>数据顺序</td><td>不保证</td><td>保证</td></tr></tbody></table><h4 id="UDP-适用场景"><a href="#UDP-适用场景" class="headerlink" title="UDP 适用场景"></a>UDP 适用场景</h4><p>面向数据报方式、网络数据大多为短消息、拥有大量 Client、对数据安全性无特殊要求、网络负担非常重，但对响应速度要求高</p><h4 id="TCP-适用场景"><a href="#TCP-适用场景" class="headerlink" title="TCP 适用场景"></a>TCP 适用场景</h4><ul><li>文件传输(FTP HTTP 对数据准确性要求较高，速度可以相对慢)</li><li>发送或接收邮件(POP IMAP SMTP 对数据准确性要求高，非紧急应用)</li><li>远程登录(telnet SSH 对数据准确性有要求，有连接的概念)</li></ul><h3 id="10-建立-socket-需要哪些步骤"><a href="#10-建立-socket-需要哪些步骤" class="headerlink" title="10. 建立 socket 需要哪些步骤"></a>10. 建立 socket 需要哪些步骤</h3><ul><li>创建 socket</li><li>绑定 socket 到指定地址和端口</li><li>开始监听连接</li><li>读取客户端输入</li><li>关闭 socket</li></ul><h3 id="11-DNS-主要作用是什么"><a href="#11-DNS-主要作用是什么" class="headerlink" title="11. DNS 主要作用是什么"></a>11. DNS 主要作用是什么</h3><p>计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问</p><p>但要让计算机去理解名称，相对而言就变得困难，因为计算机更擅长处理一长串数字</p><p>为了解决上述问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务</p><h3 id="12-HTTP-报文组成"><a href="#12-HTTP-报文组成" class="headerlink" title="12. HTTP 报文组成"></a>12. HTTP 报文组成</h3><p>HTTP 报文是由简单字符串组成，HTTP 报文都是纯文本，不是二进制代码，可以很方便地对其进行读写</p><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-message.png" alt="HTTP报文"></p><p>从客户端发往服务器的 HTTP 报文称为<code>请求报文</code>(request message)。从服务器发往客户端的报文称为<code>响应报文</code>(response message)。HTTP 请求和响应报文的格式很类似</p><p>HTTP 报文组成部分</p><ul><li>起始行：报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况</li><li>首部字段：起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值</li><li>主体：空行之后就是可选的报文主体了，其中包含了所有类型的数据</li></ul><h3 id="13-HTTP-状态码"><a href="#13-HTTP-状态码" class="headerlink" title="13. HTTP 状态码"></a>13. HTTP 状态码</h3><blockquote><p>HTTP 状态码用来告诉客户端，发生了什么事情，状态码位于响应的起始行中</p></blockquote><h4 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h4><table><thead><tr><th>状态码</th><th>整体范围</th><th>已定义范围</th><th>分类</th></tr></thead><tbody><tr><td>1XX</td><td>100~199</td><td>100~101</td><td>信息提示</td></tr><tr><td>2XX</td><td>200~299</td><td>200~206</td><td>成功</td></tr><tr><td>3XX</td><td>300~399</td><td>300~305</td><td>重定向</td></tr><tr><td>4XX</td><td>400~499</td><td>400~415</td><td>客户端错误</td></tr><tr><td>5XX</td><td>500~599</td><td>500~505</td><td>服务器错误</td></tr></tbody></table><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><table><thead><tr><th>状态码</th><th>原因短语</th><th>含义</th><th>考察概率</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求没有问题</td><td>***</td></tr><tr><td>206</td><td>Partial Content</td><td>部分或 Range(范围) 请求</td><td>*</td></tr><tr><td>301</td><td>Moved Permanently</td><td>在请求的链接被移除时使用</td><td>**</td></tr><tr><td>302</td><td>Found</td><td>在请求临时的链接使用</td><td>**</td></tr><tr><td>304</td><td>Not Modified</td><td>资源未被修改可使用旧资源</td><td>**</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>在请求临时的链接使用</td><td>**</td></tr><tr><td>400</td><td>Bad Request</td><td>告知客户端发送了错误请求</td><td>***</td></tr><tr><td>403</td><td>Forbidden</td><td>请求被服务器拒绝</td><td>***</td></tr><tr><td>404</td><td>Not Found</td><td>无法找到所请求的 URL</td><td>***</td></tr><tr><td>413</td><td>Request entiry too large</td><td>请求实体过大</td><td>*</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器遇到错误</td><td>***</td></tr><tr><td>502</td><td>Bad Gateway</td><td>代理或网关错误(无法连接到其父网关)</td><td>***</td></tr><tr><td>503</td><td>Service Unavailable</td><td>无法为请求提供服务</td><td>***</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>代理或网关超时(等待另一服务器响应超时)</td><td>***</td></tr></tbody></table><p>拓展阅读 <a href="./01.%E7%BD%91%E7%BB%9C/05.HTTP%E7%8A%B6%E6%80%81%E7%A0%81.md">《HTTP状态码》</a></p><p>拓展阅读 <a href="../03.PHP/QA.md#502504-%E9%94%99%E8%AF%AF%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F">《5xx系列错误》</a></p><h3 id="14-常见的-HTTP-方法"><a href="#14-常见的-HTTP-方法" class="headerlink" title="14. 常见的 HTTP 方法"></a>14. 常见的 HTTP 方法</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-http-method.png" alt="HTTP方法"></p><p>拓展阅读 <a href="./01.%E7%BD%91%E7%BB%9C/06.HTTP%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.md">《HTTP方法详解》</a></p><h3 id="15-GET-与-POST-请求方式区别"><a href="#15-GET-与-POST-请求方式区别" class="headerlink" title="15. GET 与 POST 请求方式区别"></a>15. GET 与 POST 请求方式区别</h3><table><thead><tr><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新无害</td><td>数据会被重新提交</td></tr><tr><td>数据长度限制/URL长度2048字符</td><td>长度无限制（协议不限制；实际上受nginx和PHP的限制，php还会限制post报文变量的个数）</td></tr><tr><td>数据可见/安全性差</td><td>不可见/更安全</td></tr><tr><td>可以被缓存</td><td>不可以被缓存</td></tr><tr><td>书签可收藏</td><td>书签不可收藏</td></tr><tr><td>产生一个TCP数据包</td><td>产生两个TCP数据包</td></tr></tbody></table><h3 id="16-HTTP-优缺点"><a href="#16-HTTP-优缺点" class="headerlink" title="16. HTTP 优缺点"></a>16. HTTP 优缺点</h3><p>基于应用级的接口，使用方便</p><p>传输速度慢，数据包大；如实现实时交互，服务器性能压力大；数据传输安全性差</p><h3 id="17-HTTPS-通信原理"><a href="#17-HTTPS-通信原理" class="headerlink" title="17. HTTPS 通信原理"></a>17. HTTPS 通信原理</h3><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-https.png" alt="HTTPS通信原理"></p><p>拓展阅读 <a href="./01.%E7%BD%91%E7%BB%9C/07.HTTPS%E7%BB%86%E8%8A%82%E4%BB%8B%E7%BB%8D.md">《HTTPS细节介绍》</a></p><h3 id="18-HTTP-2-0"><a href="#18-HTTP-2-0" class="headerlink" title="18. HTTP 2.0"></a>18. HTTP 2.0</h3><p>多路复用、客户端拉拽/服务器推送、流量控制、WebSocket</p><h3 id="19-WebSocket"><a href="#19-WebSocket" class="headerlink" title="19. WebSocket"></a>19. WebSocket</h3><p>WebSocket 是一种通信协议，定义了一个全双工通信信道，仅通过 Web 上的一个 Socket 即可进行通信</p><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul><li>推送功能：支持由服务器向客户端推送数据的推送功能</li><li>减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态</li></ul><p><img src="http://tlcydev-github-io-1255676299.cos.ap-nanjing.myqcloud.com//network-websocket.png" alt="websocket"></p><h3 id="20-IPv6-与-IPv4-有什么变化"><a href="#20-IPv6-与-IPv4-有什么变化" class="headerlink" title="20. IPv6 与 IPv4 有什么变化"></a>20. IPv6 与 IPv4 有什么变化</h3><p>更大的地址空间、扩展的地址层次结构、灵活的首部格式、改进的选项、允许协议继续扩充、支持资源的预分配</p><h3 id="21-什么是心跳机制"><a href="#21-什么是心跳机制" class="headerlink" title="21. 什么是心跳机制"></a>21. 什么是心跳机制</h3><p>心跳机制是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制</p><h3 id="22-什么是长连接"><a href="#22-什么是长连接" class="headerlink" title="22. 什么是长连接"></a>22. 什么是长连接</h3><p>长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>参考资料</title>
      <link href="/interview/docs/14.%E5%85%B6%E4%BB%96/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
      <url>/interview/docs/14.%E5%85%B6%E4%BB%96/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="出版图书"><a href="#出版图书" class="headerlink" title="出版图书"></a>出版图书</h2><ul><li>《计算机网络-第7版》谢希仁</li><li>《Linux 多线程服务端编程》陈硕</li><li>《图解 HTTP》上野宣</li><li>《HTTP 权威指南》David Gourley、Brian Totty </li><li>《数据结构-第2版》陈越</li><li>《PHP5 权威编程》简张桂</li><li>《PHP 核心技术与最佳实践》列旭松</li><li>《PHP7 内核剖析》秦朋</li><li>《SEO 教程-搜索引擎优化入门与进阶》吴泽欣</li><li>《CSS 权威指南》伊志忠、侯妍</li><li>《JavaScript 权威指南-第6版》David Flanagan</li><li>《HTML5 程序设计-第2版》Peter Lubbers</li><li>《高性能 MySQL-第三版》Baron Schwartz</li><li>《MySQL 技术内幕-InnoDB 存储引擎-第2版》姜承尧</li><li>《Redis 实战》Josiah L. Carlson</li><li>《Redis 设计与实现》黄健宏</li><li>《鸟哥的 Linux 私房菜-基础学习篇》鸟哥</li><li>《Vim 实用技巧》Drew Neil</li><li>《深入 Linux 内核架构》Wolfgang Mauerer</li><li>《白帽子讲 Web 安全》吴翰清</li><li>《设计模式-可复用面向对象软件的基础》Erich Gamma</li><li>《Learning PHP 设计模式》 William Sanders</li><li>《深入理解 Nginx-第2版》陶辉</li><li>《大型网站系统与 Java 中间件开发实践》曾宪杰</li><li>《企业应用架构模式》Martin Fowler</li><li>《Kafka 权威指南》Neha Narkhede</li></ul><h2 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN web docs</a></li><li><a href="https://www.ibm.com/developerworks/cn/topics/">IBM Developer</a></li><li><a href="https://cloud.google.com/apis/design/?hl=zh-cn">API 设计指南</a></li><li><a href="https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md">Microsoft REST API Guidelines</a></li></ul><h2 id="职级参考"><a href="#职级参考" class="headerlink" title="职级参考"></a>职级参考</h2><table><thead><tr><th>职级</th><th>名称</th><th>薪资</th><th>股票</th></tr></thead><tbody><tr><td>P4</td><td>初级工程师</td><td></td><td></td></tr><tr><td>P5</td><td>中级工程师</td><td></td><td></td></tr><tr><td>P6</td><td>高级研发工程师</td><td></td><td></td></tr><tr><td>P7</td><td>专家</td><td></td><td></td></tr><tr><td>P9</td><td>资深专家</td><td></td><td></td></tr></tbody></table><ul><li>阿里薪资结构：一般是12+1+3=16薪</li><li>年底的奖金为0-6个月薪资，90%人可拿到3个</li><li>股票是工作满2年才能拿，第一次拿50%，4年能全部拿完</li></ul><blockquote><p>备注：阿里技术通道</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>术语对照表</title>
      <link href="/interview/docs/14.%E5%85%B6%E4%BB%96/%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
      <url>/interview/docs/14.%E5%85%B6%E4%BB%96/%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="术语对照表"><a href="#术语对照表" class="headerlink" title="术语对照表"></a>术语对照表</h1><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>开放式系统互联通信参考模型（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为OSI模型（OSI model），一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>‘域名系统（英文：Domain Name System，缩写： ‘DNS）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据包协议（英语：User Datagram Protocol，缩写：UDP），又称用户数据包协议，是一个简单的面向数据报的传输层协议</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>互联网控制消息协议（英语：Internet Control Message Protocol，缩写：ICMP）是互联网协议族的核心协议之一。它用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p><h2 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h2><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制</p><h2 id="SYN"><a href="#SYN" class="headerlink" title="SYN"></a>SYN</h2><p>同步序列编号（Synchronize Sequence Numbers）</p><h2 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h2><p>ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误</p><h2 id="TCB"><a href="#TCB" class="headerlink" title="TCB"></a>TCB</h2><p>传输控制块 TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如：TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议</p><h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p>传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障</p><h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是间接定义的，通过其上的可执行的操作以及这些操作的效果的数学约束（与可能的代价）</p><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用</p><h2 id="FPM"><a href="#FPM" class="headerlink" title="FPM"></a>FPM</h2><p>FPM(FastCGI Process Manager, FPM)是 PHP FastCGI 运行模式的一个进程管理器</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）</p><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换</p><h2 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h2><p>PDO（PHP Data Objects） PHP 数据对象，是 PHP 应用中的一个数据库抽象层规范。PDO提供了一个统一的 API 接口可以使得你的 PHP 应用不去关心具体要 连接的数据库服务器系统类型</p><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构</p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB(Redis Database)，在指定时间间隔对 Redis 内存数据进行快照存储</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>只追加文件(append-only file，AOF)，在执行写命令时，将被执行的写命令复制到磁盘里面</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>进程间通信（IPC，Inter-Process Communication），指至少两个进程或线程间传送数据或信号的一些技术或方法</p><h2 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h2><p>每秒查询率 QPS(Query Per Second) 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</p><h2 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h2><p>Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>跨站请求伪造（英语：Cross-site request forgery），通常缩写为 CSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法</p><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p>DDOS 又称为分布式拒绝服务，全称是 Distributed Denial of Service。DDOS 本是利用合理的请求造成资源过载，导致服务不可用</p><h2 id="OOP-1"><a href="#OOP-1" class="headerlink" title="OOP"></a>OOP</h2><p>面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针</p><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p>单点登录（英语：Single sign-on，缩写为 SSO），又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录</p><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>表现层状态转换（英语：Representational State Transfer，缩写：REST）是一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token 是一种跨域认证解决方案</p><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>Linux 虚拟服务器（Linux Virtual Server，LVS）是一个虚拟的服务器集群系统，用于实现负载均衡</p><p>以上内容均摘录自维基百科、百度百科</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>技能树</title>
      <link href="/interview/docs/14.%E5%85%B6%E4%BB%96/%E6%8A%80%E8%83%BD%E6%A0%91/"/>
      <url>/interview/docs/14.%E5%85%B6%E4%BB%96/%E6%8A%80%E8%83%BD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><ul><li>UDP</li><li>TCP</li><li>socket</li><li>HTTP/HTTPS</li><li>websocket</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul><li>红黑树</li><li>B-Tree</li><li>B+Tree</li></ul><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ul><li><p>PHP 基础</p><ul><li>语言参考</li><li>COOKIE</li><li>SESSION</li><li>PDO</li></ul></li><li><p>面向对象</p><ul><li>魔术方法</li><li>继承与多态</li><li>面向接口</li><li>反射</li><li>异常和错误处理</li></ul></li><li><p>正则表达式</p></li><li><p>流行框架</p></li><li><p>PHP 扩展开发</p></li><li><p>缓存详解</p></li><li><p>代码调试与测试</p></li><li><p>PHP 编码规范</p></li><li><p>PHP 7</p></li></ul><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul><li><p>SEO</p></li><li><p>HTML</p><ul><li>历史</li><li>标记</li><li>语义化</li><li>HTML5</li></ul></li><li><p>CSS</p><ul><li>基础</li><li>CSS3</li></ul></li><li><p>JavaScript</p></li><li><p>Vue.js</p><ul><li>Node.js</li><li>npm</li><li>flow</li></ul></li><li><p>自动化部署工具</p><ul><li>webpack</li><li>gulp</li></ul></li><li><p>浏览器兼容性</p></li><li><p>编程部分</p></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul><li>体系结构</li><li>字段类型</li><li>存储引擎</li><li>事务</li><li>索引</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>CSRF</li><li>XSS</li><li>SQL注入</li><li>DOS</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>负载均衡</li><li>单点故障</li><li>反向代理</li><li>消息队列</li><li>分布式存储</li></ul><h2 id="业务相关"><a href="#业务相关" class="headerlink" title="业务相关"></a>业务相关</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>Git</li><li>SVN</li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
