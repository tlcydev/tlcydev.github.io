<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="php 数组底层实现原理 底层实现是通过散列表（hash table） + 双向链表（解决hash冲突） hashtable：将不同的关键字（key）通过映射函数计算得到散列值（Bucket-&gt;h） 从而直接索引到对应的Bucket hash表保存当前循环的指针，所以foreach 比for更快 Bucket：保存数组元素的key和value，以及散列值h 如何保证有序性 散列函数和元素数组">
<meta property="og:type" content="article">
<meta property="og:title" content="面试资料笔记整理01">
<meta property="og:url" content="https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/index.html">
<meta property="og:site_name" content="快乐的杨蛆">
<meta property="og:description" content="php 数组底层实现原理 底层实现是通过散列表（hash table） + 双向链表（解决hash冲突） hashtable：将不同的关键字（key）通过映射函数计算得到散列值（Bucket-&gt;h） 从而直接索引到对应的Bucket hash表保存当前循环的指针，所以foreach 比for更快 Bucket：保存数组元素的key和value，以及散列值h 如何保证有序性 散列函数和元素数组">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-10-07T03:22:30.000Z">
<meta property="article:modified_time" content="2022-04-07T06:13:12.392Z">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>面试资料笔记整理01</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 5.4.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/interview/docs/01.%E7%BD%91%E7%BB%9C/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&text=面试资料笔记整理01"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&is_video=false&description=面试资料笔记整理01"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=面试资料笔记整理01&body=Check out this article: https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&name=面试资料笔记整理01&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&t=面试资料笔记整理01"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#php-%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">php 数组底层实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">冒泡排序的时间复杂度和空间复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A-TCP-%E5%92%8C-UDP"><span class="toc-number"></span> <span class="toc-text">网络七层协议及 TCP 和 UDP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">TCP 和 UDP 的特点和区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number"></span> <span class="toc-text">TCP 的三次握手和四次挥手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">HTTP 状态码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">http 和 HTTPS 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8A%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">redis 分布式锁及问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">redis 的数据类型及应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">redis 实现持久化的方式及原理、特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E5%8F%8A%E9%9A%BE%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">秒杀设计流程及难点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2-sql-%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">防 sql 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">索引原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E8%A1%A8-%E5%88%86%E5%BA%93-%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number"></span> <span class="toc-text">分表 (分库) 的策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#select-%E5%92%8C-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">select 和 update 的执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binlog-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">binlog 的作用和三种格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E9%97%AE%E9%A2%98%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number"></span> <span class="toc-text">主从同步（主从复制）的原理和问题及读写分离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number"></span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql-%E4%BC%98%E5%8C%96%E5%A4%A7%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-limit-100000"><span class="toc-number"></span> <span class="toc-text">Mysql 优化大分页查询 limit 100000</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E7%BC%93%E5%AD%98%E5%92%8C-mysql-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">redis 缓存和 mysql 数据一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E4%B8%AD%E7%9A%84-connect-%E5%92%8C-pconnect"><span class="toc-number"></span> <span class="toc-text">redis 中的 connect 和 pconnect</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-zset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8-skiplist-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">redis zset 有序集合使用 skiplist 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">redis 的过期删除和淘汰机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">redis 常见问题及解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#php-fpm-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number"></span> <span class="toc-text">php-fpm 详解及生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx-%E5%92%8C-php-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number"></span> <span class="toc-text">Nginx 和 php 之间的通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web-%E6%BC%8F%E6%B4%9E%E5%8F%8A%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">web 漏洞及问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">魔术方法原理及使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number"></span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql-%E4%B8%80%E6%AC%A1%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">mysql 一次查询索引使用</span></a>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        面试资料笔记整理01
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name"></span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-10-07T03:22:30.000Z" itemprop="datePublished">2021-10-07</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="php-数组底层实现原理"><a href="#php-数组底层实现原理" class="headerlink" title="php 数组底层实现原理"></a>php 数组底层实现原理</h2><ol>
<li>底层实现是通过散列表（hash table） + 双向链表（解决hash冲突）<br> hashtable：将不同的关键字（key）通过映射函数计算得到散列值（Bucket-&gt;h） 从而直接索引到对应的Bucket<br> hash表保存当前循环的指针，所以foreach 比for更快<br> Bucket：保存数组元素的key和value，以及散列值h</li>
<li>如何保证有序性<ol>
<li>散列函数和元素数组（Bucket）中间添加一层大小和存储元素数组相同的映射表。</li>
<li>用于存储元素在实际存储数组中的下标</li>
<li>元素按照映射表的先后顺序插入实际存储数组中</li>
<li>映射表只是原理上的思路，实际上并不会有实际的映射表，而是初始化的时候分配Bucket内存的同时，还会分配相同数量的 uint32_t 大小的空间，然后将 arData 偏移到存储元素数组的位置。        </li>
</ol>
</li>
<li>解决hash重复(php使用的链表法)：<ol>
<li>链表法:不同关键字指向同一个单元时，使用链表保存关键字（遍历链表匹配key） </li>
<li>开放寻址法：当关键字指向已经存在数据的单元的时候，继续寻找其他单元，直到找到可用单元（占用其他单元位置，更容易出现hash冲突，性能下降）</li>
</ol>
</li>
<li>基础知识<br>  链表：队列、栈、双向链表、<br>  链表    ：元素 + 指向下一元素的指针<br>  双向链表：指向上一元素的指针 + 元素 + 指向下一元素的指针</li>
</ol>
<h1 id="冒泡排序的时间复杂度和空间复杂度"><a href="#冒泡排序的时间复杂度和空间复杂度" class="headerlink" title="冒泡排序的时间复杂度和空间复杂度"></a>冒泡排序的时间复杂度和空间复杂度</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1. 代码实现</span><br><span class="line">        $arr = [2, 4, 1, 5, 3, 6];</span><br><span class="line">        for ($i = 0; $i &lt; (count($arr)); $i++) &#123;</span><br><span class="line">            for ($j = $i + 1; $j &lt; (count($arr)); $j++) &#123;</span><br><span class="line">                if ($arr[$i] &lt;= $arr[$j]) &#123;</span><br><span class="line">                    $temp = $arr[$i];</span><br><span class="line">                    $arr[$i] = $arr[$j];</span><br><span class="line">                    $arr[$j] = $temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    result : [6,5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">    评论区有其他同学对于上面的写法有不用意见（第一种写法虽然能达到排序的目的，但是他觉得按照冒泡排序的明确定义来说不是冒泡排序），所以另一种写法我也列举出来，有更专业的大佬们可以指正一下,代码实现如下  </span><br><span class="line">$list = [2, 4, 1, 7, 9, 3];</span><br><span class="line">$len = count($list);</span><br><span class="line"></span><br><span class="line">for ($i = $len - 1; $i &gt; 0; $i--) &#123;</span><br><span class="line">    for ($j = 0; $j &lt; $i; $j++) &#123;</span><br><span class="line">        if ($list[$j] &gt; $list[$j + 1]) &#123;</span><br><span class="line">            $tmp = $list[$j];</span><br><span class="line">            $list[$j] = $list[$j + 1];</span><br><span class="line">            $list[$j + 1] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($list);</span><br><span class="line"></span><br><span class="line">2. 计算原理</span><br><span class="line">    第一轮：将数组的第一个元素和其他所有的元素进行比较，哪个元素更大，就换顺序，从而冒泡出第一大（最大）的元素</span><br><span class="line">    第一轮：将数组的第二个元素和其他所有的元素进行比较（第一大已经筛选出来不用继续比较了），哪个元素更大，就换顺序，从而冒泡出第二大的元素</span><br><span class="line">    ... 依次类推，冒泡从大到小排序的数组</span><br><span class="line"></span><br><span class="line">    平均时间复杂度：O(n^2)  ：</span><br><span class="line">    最优时间复杂度：O(n) ：需要加判断，第一次循环如果一次都没有交换就直接跳出循环</span><br><span class="line"></span><br><span class="line">    空间复杂度：O(1)，交换元素的时候的临时变量占用的空间</span><br><span class="line">    最优空间复杂度：O(1)，排好序，不需要交换位置</span><br><span class="line">3. 时间复杂度和空间复杂度</span><br><span class="line">    时间复杂度：全程为渐进时间复杂度，估算对处理器的使用效率（描述算法的效率趋势，并不是指算法具体使用的时间，因为不同机器的性能不一致，只是一种效率计算的通用方法）</span><br><span class="line">    表示方法：大O符号表示法 </span><br><span class="line">    复杂度量级：</span><br><span class="line">        常数阶O(1)</span><br><span class="line">        线性阶O(n)</span><br><span class="line">        平方阶O(n²)</span><br><span class="line">        立方阶O(n³)</span><br><span class="line">        K次方阶O(n^k)</span><br><span class="line">        指数阶(2^n)</span><br><span class="line">        对数阶O(logN)</span><br><span class="line">        线性对数阶O(nlogN)</span><br><span class="line">    时间复制类型：</span><br><span class="line">        最好时间复杂度</span><br><span class="line">        最坏时间复杂度</span><br><span class="line">        平均时间复杂度</span><br><span class="line">        均摊时间复杂度</span><br><span class="line"></span><br><span class="line">    空间复杂度：全程渐进空间复杂度，估算对计算机内存的使用程度（描述算法占用的存储空间的趋势，不是实际占用空间，同上）</span><br></pre></td></tr></table></figure>
<h1 id="网络七层协议及-TCP-和-UDP"><a href="#网络七层协议及-TCP-和-UDP" class="headerlink" title="网络七层协议及 TCP 和 UDP"></a>网络七层协议及 TCP 和 UDP</h1><p> 应用层、表示层、会话层、传输层、网络层、（数据）链路层、物理层<br><kbd> 记忆套路：<br> 首字：应表会传（物链网）<br>             第一个字：应用层（出现次数多，易忆）<br>            前四个正向：应表 - 会传<br>            后三个反向：物联网谐音比网链物更好记<br></kbd></p>
<h1 id="TCP-和-UDP-的特点和区别"><a href="#TCP-和-UDP-的特点和区别" class="headerlink" title="TCP 和 UDP 的特点和区别"></a>TCP 和 UDP 的特点和区别</h1><ol>
<li><p>都是属于传输层协议</p>
</li>
<li><p>TCP</p>
<ol>
<li>面向连接，所以只能一对一</li>
<li>面向字节流传输</li>
<li>数据可靠，不丢失</li>
<li>全双工通信</li>
</ol>
</li>
<li><p>UDP（根据TCP特点反记）</p>
<ol>
<li>无连接，支持一对一，一对多，多对多</li>
<li>面向报文传输</li>
<li>首部开销小，数据不一定可靠但是速度更快<h1 id="TCP-的三次握手和四次挥手"><a href="#TCP-的三次握手和四次挥手" class="headerlink" title="TCP 的三次握手和四次挥手"></a>TCP 的三次握手和四次挥手</h1></li>
</ol>
</li>
<li><p>三次握手：</p>
<ol>
<li>第一次：客户端发送SYN = 1,seq = client_isn<br>作用：<br>客户端：无<br>服务端：确认自己的接收功能和客户端的发送功能</li>
<li>第二次：服务端发送SYN = 1,seq = server_isn,ACK =client_isn +1<br>作用：<br>客户端：确认自己发送和接收都正常，确认服务端的接收和发送正常<br>服务端：确认自己的接收正常，确认服务端的发送正常（这时候服务端还不能确认客户端接收是否正常）</li>
<li>第三次：客户端发送SYN = 0,  ACK =  server_isn+1,seq =client_isn+1<br>作用：双方确认互相的接收和发送正常，建立连接</li>
</ol>
</li>
<li><p>四次挥手</p>
<ol>
<li>第一次:客户端发送FIN<br> 作用：告诉服务端我没有数据发送了（但是还能接收数据）</li>
<li>第二次：服务端发送ACK<br> 作用：告诉客户端收到请求了，可能服务端可能还有数据需要发送，所以客户端收到进入FIN_WAIT状态，等服务端数据传输完之后发送FIN</li>
<li>第三次：服务端发送FIN<br> 作用：服务端告诉客户端我发送完了，可以关闭连接了。</li>
<li>第四次:客户端发送ACK<br> 作用：客户端收到FIN之后，担心服务端不知道要关闭，所以发送一个ACK，进入TIME_WAIT，等待2MSL之后如果没有收到回复，证明服务端已经关闭了，这时候客户端也关闭连接。<blockquote>
<p>注意：</p>
</blockquote>
</li>
<li>当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据</li>
<li>最后需要等待2MSL是因为网络是不可靠的，如果服务端没有收到最后一次ACK,服务端会重新放FIN包然后等客户端再次发送ACK包然后关闭（所以客户端最后发送ACK之后不能立即关闭连接）</li>
</ol>
</li>
</ol>
<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><ol>
<li><p>状态码分类  </p>
<pre><code> - 1xx：信息，服务器收到请求，需要请求者继续操作
 - 2xx：成功
 - 3xx：重定向
 - 4xx：客户端错误
 - 5xx：服务端错误
</code></pre>
</li>
<li><p>常用状态码</p>
<p> 200：请求成功<br> 301：永久重定向<br> 302：临时移动<br> 400 bad request：客户端请求语法错误<br> 401 unauthorized：客户端没有权限<br> 403 forbidden：服务器拒绝客户端请求<br> 404 not found：客户端请求资源不存在<br> 500 Internal Server Eerro：服务器内部错误<br> 502 bad gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应<br> 503 Service Unavailable 超载或系统维护<br> 504 Gateway timeout：网关超时</p>
</li>
<li><p>502 的原因及解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">原因：nginx将请求提交给网关（php-fpm）处理异常导致</span><br><span class="line">    1. fastcgi 缓冲区设置过小</span><br><span class="line">        fastcgi_buffers 8 16k;</span><br><span class="line">         fastcgi_buffer_size 32k;</span><br><span class="line">    2. php-cgi的进程数设置过少</span><br><span class="line">        查看FastCgi进程数：netstat -anpo | grep &quot;php-cgi&quot;| wc -l</span><br><span class="line">        调整参数最大子进程数：max_children</span><br><span class="line">            一般按照单个进程20M计算需要需要设置的子进程数 </span><br><span class="line">    3. max_requests（内存溢出或频繁重启）</span><br><span class="line">        参数指明每个children最多能处理的请求数量，到达最大值之后会重启children。</span><br><span class="line">        设置过小可能导致频繁重启children：</span><br><span class="line">            php将请求轮询给每个children，在大流量的场景下，每一个children 到达最大值的时间差不多，如果设置过小可能多个children 在同一时间关闭，nginx无法将请求转发给php-fpm，cpu降低，负载变高。</span><br><span class="line">        设置过大可能导致内存泄露</span><br><span class="line">    4. php执行时间超过nginx等待时间</span><br><span class="line">            fastcgi_connect_timeout</span><br><span class="line">            fastcgi_send_timeout</span><br><span class="line">            fastcgi_read_timeout</span><br><span class="line">    5. fastcgi执行时间</span><br><span class="line">        max_execution_time</span><br></pre></td></tr></table></figure>
<h1 id="http-和-HTTPS-的区别"><a href="#http-和-HTTPS-的区别" class="headerlink" title="http 和 HTTPS 的区别"></a>http 和 HTTPS 的区别</h1></li>
<li><p>端口：http 80； https ：443</p>
</li>
<li><p>http无状态，https是有http + ssl构建的可进行加密传输的协议</p>
</li>
<li><p>http明文传输，https加密传输</p>
</li>
<li><p>http更快，三次握手三个包，https 需要12个包（3个tcp包+9个ssl握手包）</p>
</li>
</ol>
<h1 id="redis-分布式锁及问题"><a href="#redis-分布式锁及问题" class="headerlink" title="redis 分布式锁及问题"></a>redis 分布式锁及问题</h1><ol>
<li>实现：<br> 加锁：setnx<br> 解锁：del<br> 锁超时：expire</li>
<li>可能出现的问题<ol>
<li>setnx 和expire非原子性问题（加锁之后还没来得及设置超时就挂了）<br> 解决方案：<pre><code> Redis 2.6.12以上版本为set指令增加了可选参数，伪代码如下：set（key，1，30，NX）,这样就可以取代setnx指令
</code></pre>
</li>
<li>超时误删其他进程锁。（A进程执行超时，导致锁释放，这时候B进程获取锁开始处理请求，这时候A进程处理完成，会误删B进程的锁）<br> 解决方案：只能删除自己进程的锁 （lua脚本防止B进程获取过期锁之后误删A进程的锁） </li>
<li>并发场景，A进程执行超时导致锁释放，这时候B进程获取到锁。<br> 解决方案：开启守护进程，给当前进程要过期的锁延时。</li>
<li>单点实例安全问题<br> 单机宕机之后导致所有客户端无法获取锁<br> 解决：<pre><code> 主从复制，因为是异步完成的所以无法完全实现解决
</code></pre>
</li>
</ol>
</li>
</ol>
<h1 id="redis-的数据类型及应用场景"><a href="#redis-的数据类型及应用场景" class="headerlink" title="redis 的数据类型及应用场景"></a>redis 的数据类型及应用场景</h1><ol>
<li>string ：<br> 普通的key/value存储</li>
<li>hash：<br> hashmap：键值队集合，存储对象信息</li>
<li>list：<br> 双向链表:消息队列</li>
<li>set：<br> value永远为null的hashMap：无序集合且不重复：计算交集、并集、差集、去重值</li>
<li>zset：<br> 有序集合且不重复:hashMap(去重) + skiplist跳跃表（保证有序）：排行榜</li>
</ol>
<h1 id="redis-实现持久化的方式及原理、特点"><a href="#redis-实现持久化的方式及原理、特点" class="headerlink" title="redis 实现持久化的方式及原理、特点"></a>redis 实现持久化的方式及原理、特点</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. RDB持久化（快照）：指定时间间隔内的内存数据集快照写入磁盘        </span><br><span class="line">        1. fork一个子进程，将快照内容写入临时RDB文件中（dump.rdb），当子进程写完快照内容之后新的文件替换老的文件</span><br><span class="line">        2. 整个redis数据库只包含一个备份文件</span><br><span class="line">        3. 性能最大化，只需要fork子进程完成持久化工作，减少磁盘IO</span><br><span class="line">        4. 持久化之前宕机可能会导致数据丢失        </span><br><span class="line">2. AOF持久化 ：以日志的形式记录服务器的所有的写、删除操作</span><br><span class="line">        1. 每接收到一个写的命令用write函数追加到文件appendonly.aof</span><br><span class="line">        2. 持久化的文件会越来越大，存在大量多余的日志（0 自增100次到100，会产生100条日志记录）</span><br><span class="line">        3. 可以设置不同的fsync策略</span><br><span class="line">            1. appendfsync everysec ：1s一次，最多丢失1s的数据（默认）</span><br><span class="line">            2. appendfsync always    ：每次变动都会执行一次</span><br><span class="line">            3. appendfsync no          ：不处理</span><br><span class="line">        4. AOF文件太大之后会进行重写：压缩AOF文件大小</span><br><span class="line">            1. fork一个子进程，将redis内地数据对象的最新状态写入AOF临时文件（类似rdb快照）</span><br><span class="line">            2. 主进程收到的变动会先写入内存中，然后同步到老的AOF文件中（重写失败之后也能保证数据完整性）</span><br><span class="line">            3. 子进程完成重写之后会将内存中的新变动同步追加到AOF的临时文件中</span><br><span class="line">            4. 父进程将临时AOF文件替换成新的AOF文件，并重命名。之后收到的新命令写入到新的文件中</span><br></pre></td></tr></table></figure>

<h1 id="秒杀设计流程及难点"><a href="#秒杀设计流程及难点" class="headerlink" title="秒杀设计流程及难点"></a>秒杀设计流程及难点</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 静态缓存</span><br><span class="line">2. nginx 负载均衡  </span><br><span class="line">    三种方式：DNS轮询、IP负债均衡、CDN</span><br><span class="line">3. 限流机制</span><br><span class="line">    方式：ip限流、接口令牌限流、用户限流、header动态token（前端加密，后端解密）</span><br><span class="line">4. 分布式锁</span><br><span class="line">    方式：</span><br><span class="line">        1. setnx + expire （非原子性，redis2.6 之后set保证原子性）</span><br><span class="line">        2. 释放锁超时 （开启守护进程自动续时间）</span><br><span class="line">        3. 过期锁误删其他线程（requestId验证或者lua脚本保证查 + 删的原子性）</span><br><span class="line">5. 缓存数据</span><br><span class="line">    方式：</span><br><span class="line">        1. 缓存击穿：缓存数据预热 + 布隆过滤器/空缓存 </span><br><span class="line">        2. 缓存雪崩：缓存设置随机过期时间，防止同一时间过期</span><br><span class="line">6. 库存及订单</span><br><span class="line">    1. 扣库存</span><br><span class="line">        1. redis 自减库存，并发场景下可能导致负数，影响库存回仓：使用lua脚本保证原子性</span><br><span class="line">        2. redis预扣库存之后，然后使用异步消息创建订单并更新库存变动 </span><br><span class="line">        3. 数据库更新库存使用乐观锁：where stock_num - sell_num &gt; 0</span><br><span class="line">        4. 添加消息发送记录表及重试机制，防止异步消息丢失</span><br><span class="line">    2. 创建订单</span><br><span class="line">        1. 前端建立websocket连接或者轮询监听订单状态</span><br><span class="line">        2. 消费验证记录状态，防止重复消费</span><br><span class="line">    3. 回仓</span><br><span class="line">        1. 创建订单之后发送延时消息，验证订单支付状态及库存是否需要回仓 </span><br></pre></td></tr></table></figure>
<h1 id="防-sql-注入"><a href="#防-sql-注入" class="headerlink" title="防 sql 注入"></a>防 sql 注入</h1><ol>
<li>过滤特殊字符</li>
<li>过滤数据库关键字</li>
<li>验证数据类型及格式</li>
<li>使用预编译模式，绑定变量</li>
</ol>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. 标准的sql隔离级别实现原理</span><br><span class="line">    1. 未提交读：其他事务可以直接读到没有提交的：脏读</span><br><span class="line">        1. 事务对当前被读取的数据不加锁</span><br><span class="line">        2. 在更新的瞬间加行级共享锁到事务结束释放</span><br><span class="line">    2. 提交读：事务开始和结束之间读取的数据可能不一致，事务中其他事务修改了数据：不可重复度</span><br><span class="line">        1. 事务对当前读取的数据（被读到的时候）行级共享锁，读完释放</span><br><span class="line">        2. 在更新的瞬间加行级排他锁到事务结束释放</span><br><span class="line">    3. 可重复读：事务开始和结束之前读取的数据保持一致，事务中其他事务不能修改数据：可重复读</span><br><span class="line">        1. 事务对当前读到的数据从事务一开始就加一个行级共享锁</span><br><span class="line">        2. 在更新的瞬间加行级排他锁到事务结束释放</span><br><span class="line">        3. 其他事务再事务过程中可能会新增数据导致幻读 </span><br><span class="line">    4. 串行化</span><br><span class="line">        1. 事务读取数据时加表级共享锁</span><br><span class="line">        2. 事务更新数据时加表级排他锁</span><br><span class="line">2. innodb的事务隔离级别及实现原理（！！和上面的不一样，区分理解一个是隔离级别 一个是！！事务！！隔离级别）</span><br><span class="line">    1. 基本概念</span><br><span class="line">        1. mvcc:多版本并发控制:依赖于undo log 和read view</span><br><span class="line">            1. 让数据都读不会对数据加锁，提高数据库并发处理能力</span><br><span class="line">            2. 写操作才会加锁</span><br><span class="line">            3. 一条数据有多个版本，每次事务更新数据的时候会生成一个新的数据版本，旧的数据保留在undo log</span><br><span class="line">            4. 一个事务启动的时候只能看到所有已经提交的事务结果</span><br><span class="line">        1. 当前读：读取的是最新版本</span><br><span class="line">        2. 快照读:读取的是历史版本</span><br><span class="line">        4. 间隙锁：间隙锁会锁住一个范围内的索引</span><br><span class="line">            1. update id between 10 and 20 </span><br><span class="line">            2. 无论是否范围内是否存在数据，都会锁住整个范围：insert id = 15，将被防止</span><br><span class="line">            3. 只有可重复读隔离级别才有间隙锁</span><br><span class="line">        5. next-key lock：</span><br><span class="line">            1. 索引记录上的记录锁+ 间隙锁（索引值到前一个索引值之间的间隙锁）</span><br><span class="line">            2. 前开后闭</span><br><span class="line">            3. 阻止幻读</span><br><span class="line">    事务隔离级别</span><br><span class="line">        1. 未提交读</span><br><span class="line">            1. 事务对当前读取的数据不加锁，都是当前读</span><br><span class="line">            2. 在更新的瞬间加行级共享锁到事务结束释放</span><br><span class="line">        2. 提交读</span><br><span class="line">            1. 事务对当前读取的数据不加锁，都是快照读</span><br><span class="line">            2. 在更新的瞬间加行级排他锁到事务结束释放</span><br><span class="line">        3. 可重复读</span><br><span class="line">            1. 事务对当前读取的数据不加锁，都是快照读</span><br><span class="line">            2. 事务再更新某数据的瞬间，必须加行级排他锁（Record 记录锁、GAP间隙锁、next-key 锁），事务结束释放</span><br><span class="line">            3. 间隙锁解决的是幻读问题</span><br><span class="line">                    1. 主从复制的情况下 ,如果没有间隙锁，master库的A、B进程 </span><br><span class="line">                    2. A进程 delete id &lt; 6 ;然后还没有commit</span><br><span class="line">                    3. B进程insert id = 3，commit</span><br><span class="line">                    4. A进程提交commit</span><br><span class="line">                    5. 该场景下，主库会存在一条id =3 的记录，但是binlog里面是先删除再新增就会导致从库没有数据，导致主从的数据不一致</span><br><span class="line">            4. MVCC的快照解决的是不可重复读问题</span><br><span class="line">        4. 串行化</span><br><span class="line">            1. 事务读取数据时加表级，当前读</span><br><span class="line">            2. 事务更新数据时加表级排他锁</span><br></pre></td></tr></table></figure>

<h1 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">索引就是帮助数据库高效查找数据的存储结构，存储再磁盘中，需要消耗磁盘IO</span><br><span class="line">1. 存储引擎</span><br><span class="line">    1. myisam 支持表锁，索引和数据分开存储适合跨服务器迁移</span><br><span class="line">    2. innodb 支持行锁，索引和数据存储再一个文件</span><br><span class="line">2. 索引类型</span><br><span class="line">    1. hash索引</span><br><span class="line">        1. 适合精确查询且效率高</span><br><span class="line">        2. 无法排序、不适合范围查询</span><br><span class="line">        3. hash冲突的情况下需要遍历链表（php数组的实现原理、redis zset 的实现原理类似）</span><br><span class="line">    2. b-tree、b+tree</span><br><span class="line">        1. b-tree 和b+tree的去区别</span><br><span class="line">            1. b+tree 的数据全部存储在叶子节点，内部节点只存key,一次磁盘IO能获取到更多的节点</span><br><span class="line">            2. b-tree 的内部节点和叶子节点都存储key和数据，查找数据不需要找到叶子节点，内部节点可以直接返回数据</span><br><span class="line">            3. b+tree 增加了叶子节点到相邻节点的指针，方便返回查询遍历</span><br><span class="line">    3. 聚簇索引和非聚簇索引</span><br><span class="line">        1. 概念</span><br><span class="line">            1. 聚簇索引  :索引和数据存储在一个节点</span><br><span class="line">            2. 非聚簇索引:索引和数据分开存储，通过索引找到数据实际存储的地址</span><br><span class="line">        2. 详解:</span><br><span class="line">            1. innodb 使用的聚簇索引,且默认主键索引为聚簇索引（没有主键索引的时候，选择一个非空索引，还没有则隐式的主键索引），辅助索引指向聚簇索引位置，然后在找到实际存储地址</span><br><span class="line">            2. myisam 使用非聚簇索引，所有的索引都只需要查询一次就能找到数据</span><br><span class="line">            3. 聚簇索引的优势和略势</span><br><span class="line">                1. 索引和数据在一起，同一页的数据会被缓存到（buffer）内存中，所以查看同一页数据的时候只需要从内存中取出，</span><br><span class="line">                2. 数据更新之后之只需要维护主键索引即可，辅助索引不受影响</span><br><span class="line">                3. 辅助索引存的是主键索引的值，占用更多的物理空间。所以会受到影响</span><br><span class="line">                4. 使用随机的UUID，数据分布不均匀，导致聚簇索引可能扫全表，降低效率，所以尽量使用自增主键id </span><br><span class="line"></span><br><span class="line"># 索引原理补充（2022-03-11）</span><br><span class="line">1. 索引原理</span><br><span class="line">    1. 磁盘IO： </span><br><span class="line">        1. 寻道时间：指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下</span><br><span class="line">        2. 旋转延迟：指的是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms</span><br><span class="line">        3. 传输时间：指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</span><br><span class="line">        4. 磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右</span><br><span class="line">    2. 预读</span><br><span class="line">        1. 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)</span><br><span class="line">        2. 具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</span><br><span class="line">    3. B+tree</span><br><span class="line">        1. 一次IO将一页的数据加载到内存中</span><br><span class="line">        2. 为什么索引字段尽量小并且数据只存在叶子节点：字节越少，每次IO请求扫描的节点就越多</span><br><span class="line">            1. 假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低</span><br><span class="line">        3. 最左前缀特性：b+数是按照从左到右的顺序来建立搜索树的</span><br><span class="line">2. 索引创建原则</span><br><span class="line">    1. 最左前缀原则：mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配。联合索引（A,B,C） = (A) + (A,B) +(A,B,C) （更新于2022-03-02：之前错误写法： (A) + (B) + (C) + (A,B) +(A,B,C)）</span><br><span class="line">    2. =和in可以乱序,mysql查询优化器会自动识别成需要使用索引的类型</span><br><span class="line">    3. 尽量选择区分度高的列作为索引</span><br><span class="line">    4. 索引列不能参与计算</span><br><span class="line">    5. 尽量的扩展索引，不要新建索引，入过已经存在A索引 需要加一个新的索引，建议修改原来的索引为（A,B）联合索引    </span><br><span class="line">4. OR 是否能走索引及原理</span><br><span class="line">5. GROUP BY 是否能走索引及原理</span><br><span class="line">6. ORDER BY 能否走索引及原理</span><br></pre></td></tr></table></figure>

<h1 id="分表-分库-的策略"><a href="#分表-分库-的策略" class="headerlink" title="分表 (分库) 的策略"></a>分表 (分库) 的策略</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 流程</span><br><span class="line">    评估容量和分表数量-&gt; 根据业务选定分表key-&gt;分表规则（hash、取余、range）-&gt;执行-&gt;考虑扩容问题</span><br><span class="line">2. 水平拆分</span><br><span class="line">    1. 根据字段水平拆分为多个表</span><br><span class="line">    2. 每个表的结构相同</span><br><span class="line">    3. 所有分表的合集是全量数量</span><br><span class="line">3. 垂直拆分</span><br><span class="line">    1. 根据字段垂直拆分</span><br><span class="line">    2. 表结构不一样，分表的同一个关联行是一条完整的数据</span><br><span class="line">    3. 扩展表，热点字段和非热点字段的拆分（列表和详情的拆分）</span><br><span class="line">    4. 获取数据时，尽量避免使用join，而是两次查询结果组合</span><br><span class="line">4. 问题</span><br><span class="line">    1. 跨库join问题</span><br><span class="line">        1. 全局表：需要关联部分系统表的场景</span><br><span class="line">        2. 冗余法：常用字段进行冗余</span><br><span class="line">        3. 组装法：多次查询的结果进行组装</span><br><span class="line">    2. 跨节点的分页、排序、函数问题</span><br><span class="line">    3. 事务一致性</span><br><span class="line">    4. 全局主键id</span><br><span class="line">        1. 使用uuid -&gt; 会降低聚簇索引效率</span><br><span class="line">        2. 使用分布式自增id</span><br><span class="line">    5. 扩容问题</span><br><span class="line">        1. 升级从库</span><br><span class="line">            1. 从库升级为主库，数据一致，只需要删除冗余数据即可</span><br><span class="line">            2. 成倍扩容：需要在加一倍从库</span><br><span class="line">        2. 双写迁移：</span><br><span class="line">            1. 新数据进行双写，同时写进新老数据库</span><br><span class="line">            2. 旧数据复制到新数据库</span><br><span class="line">            3. 以老数据库为准，验证数据一致性之后删除冗余数据</span><br></pre></td></tr></table></figure>

<h1 id="select-和-update-的执行流程"><a href="#select-和-update-的执行流程" class="headerlink" title="select 和 update 的执行流程"></a>select 和 update 的执行流程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1. mysql 构成</span><br><span class="line">    1. server层：连接器-&gt;缓存器-&gt;分析器(预处理器)-&gt;优化器-&gt;执行器</span><br><span class="line">    2. 引擎层  ： 查询和存储数据</span><br><span class="line">2. select 执行过程</span><br><span class="line">    1. 客户端发送请求，建立连接</span><br><span class="line">    2. server层查找缓存，命中直接返回，否则继续</span><br><span class="line">    3. 分析七分析sql语句以及预处理（验证字段合法性及类型等）</span><br><span class="line">    4. 优化器生成执行计划</span><br><span class="line">    5. 执行器调用引擎API查询结果</span><br><span class="line">    6. 返回查询结果</span><br><span class="line">3. update执行过程</span><br><span class="line">    1. 基础概念</span><br><span class="line">        1. buffer pool(缓存池),在内存中，下次读取同一页的数据的时候可以直接从buffer pool中返回（innodb的聚簇索引）</span><br><span class="line">        2. 更新数据的时候先更新buffer pool,然后在更新磁盘</span><br><span class="line">        3. 脏页:内存中的缓存池更新了,但是没有更新磁盘</span><br><span class="line">        4. 刷脏:inndb 中有一个专门的进程将buffer pool的数据写入磁盘，每隔一段时间将多个修改一次性写入磁盘</span><br><span class="line">        5. redo log 和 binlog</span><br><span class="line">            1. redo log(重做日志),innodb特有的日志，物理日志，记录修改</span><br><span class="line">            2. redo log是重复写,空间固定且会用完,会覆盖老日志</span><br><span class="line">            3. binlog 是server层共有的日志，逻辑日志,记录语句的原始逻辑</span><br><span class="line">            4. binlog 是追加写到一定大小切换到下一个,不会覆盖以前的日志</span><br><span class="line">            5. redo log主要是用来恢复崩溃，bin log是用来记录归档的二进制日志</span><br><span class="line">            6. redo log只能恢复短时间内的数据，binlog可以通过设置恢复更大的数据</span><br><span class="line">        6. WAL（write-ahead-logging）先写日志方案</span><br><span class="line">            1. 记录日志是顺序IO</span><br><span class="line">            2. 直接写入磁盘（刷盘）是随机IO,因为数据是随机的,可能分布在不同的扇区</span><br><span class="line">            3. 顺序IO的效率更高,先写入修改日志,可以延迟刷盘时机，提高吞吐量</span><br><span class="line">        7. redo log 刷盘机制，check point</span><br><span class="line">            1. redo log大小固定,循环写入</span><br><span class="line">            2. redo log 就像一个圆圈,前面是check point (到这个point就开始覆盖老的日志),后面是write point (当前写到的位置)</span><br><span class="line">            2. write point 和check point 重叠的时候就证明redo log 满了,需要开始同步redo log 到磁盘中了</span><br><span class="line">    2. 执行步骤（两阶段提交 - 分布式事务，保证两个日志的一致性）</span><br><span class="line">        1. 分析更新条件,查找需要更新的数据（会用到缓存）</span><br><span class="line">        2. server 调用引擎层的API,Innodb 更新数据到内存中，然后写入redo log，然后进入prepare</span><br><span class="line">        3. 引擎通知server层开始提交数据</span><br><span class="line">        4. server层写入binlog 日志,并且调用innodb 的接口发出commit请求</span><br><span class="line">        5. 引擎层收到请求之后提交commit</span><br><span class="line">    3. 宕机后数据崩溃恢复规则</span><br><span class="line">        1. 如果redo log 状态为commit ,则直接提交</span><br><span class="line">        2. 如果redo log 状态为prepare,则判断binlog 中的事务是否commit,是则提交，否则回滚</span><br><span class="line">    4. 如果不使用两次提交的错误案例（update table_x set value = 10 where value = 9）</span><br><span class="line">        1. 先redo log 再写入binlog</span><br><span class="line">            1. redo log 写完之后，binlog没写完，这时候宕机。</span><br><span class="line">            2. 重启之后redo log 完整，所以恢复数据 value = 10 </span><br><span class="line">            3. bin log日志中没有记录，如果需要恢复数据的时候 value = 9</span><br><span class="line">        2. 先写binlog 再写redo log</span><br><span class="line">            1. binlog 写入完成，redo log 未完成</span><br><span class="line">            2. 重启之后没有redo log ，所以value 还是9</span><br><span class="line">            3. 当需要恢复数据的时候binlog 日志完整，value 更新成10</span><br><span class="line">    5. undo log </span><br><span class="line">        1. 在更新写入buffer pool之前记录</span><br><span class="line">        2. 如果更新过程中出错，直接回滚到undo log 的状态 </span><br></pre></td></tr></table></figure>
<h1 id="binlog-的作用和三种格式"><a href="#binlog-的作用和三种格式" class="headerlink" title="binlog 的作用和三种格式"></a>binlog 的作用和三种格式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">    1. 数据恢复</span><br><span class="line">    2. 主从复制</span><br><span class="line">格式（二进制文件）：</span><br><span class="line">    1. statement </span><br><span class="line">        1. 记录每次sql语句的原文</span><br><span class="line">        2. 删除一个表只需要记录一条sql语句，不需要记录每一行的变化，节约IO，提高性能，减少日志量</span><br><span class="line">        3. 可能出现主从不一致（存储过程、函数等）</span><br><span class="line">        4. RC隔离级别（读提交），因为binlog 记录顺序是按照事务commit 顺序记录的，所以可能导致主从复制不一致。通过可重复读级别的间隙锁的引入，可以解决。</span><br><span class="line">    2. row          </span><br><span class="line">        1. 记录每条记录的修改情况，不需要记录sql语句的上下文记录</span><br><span class="line">        2. 导致binlog日志量很大</span><br><span class="line">        3. 删除一个表：记录每条记录都被删除的状况 </span><br><span class="line">    3. mixed</span><br><span class="line">        1. 前两个格式的混合版</span><br><span class="line">        2. 根据语句自动选择使用哪一种：</span><br><span class="line">            1. 一般的sql语句修改使用statement</span><br><span class="line">            2. 修改表结构、函数、存储过程等操作选择row</span><br><span class="line">            3. update 和delete 还是会记录全部记录的变化</span><br></pre></td></tr></table></figure>

<h1 id="主从同步（主从复制）的原理和问题及读写分离"><a href="#主从同步（主从复制）的原理和问题及读写分离" class="headerlink" title="主从同步（主从复制）的原理和问题及读写分离"></a>主从同步（主从复制）的原理和问题及读写分离</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">1. 解决的问题</span><br><span class="line">    1. 数据分布</span><br><span class="line">    2. 负载均衡</span><br><span class="line">    3. 数据备份，高可用，避免单点失败</span><br><span class="line">    4. 实现读写分离，缓解数据库压力</span><br><span class="line">    5. 升级测试（使用高版本mysql当从库）</span><br><span class="line">2. 支持的复制类型（binlog 的三种格式）</span><br><span class="line">    1. 基于sql语句的复制</span><br><span class="line">    2. 基于行的复制</span><br><span class="line">    3. 混合型复制</span><br><span class="line">3. 原理</span><br><span class="line">    1. 基础概念</span><br><span class="line">        1. 从库生成两个线程</span><br><span class="line">            1. I/O线程</span><br><span class="line">            2. SQL线程</span><br><span class="line">        2. 主库生成线程</span><br><span class="line">            1. log dumo 线程</span><br><span class="line">    2. 流程（主节点必须开启bin log功能，）</span><br><span class="line">        1. 从节点开启start slave 命令之后，创建一个IO进程连接到主节点</span><br><span class="line">        2. 连接成功之后，主节点创建一个 log dump线程(主节点会为每一个从节点创一个log dump线程)</span><br><span class="line">        3. 当binlog发生变化时，主节点的dump log线程会读取bin-log内容并发送给从节点</span><br><span class="line">        4. 主节点dump log 线程读取bin-log 的内容时会对主节点的bin-log加锁，读取完成在发送给从节点之前释放锁</span><br><span class="line">        5. 从节点的IO线程接收主节点发送的binlog内容，并将其写入本地relay log 文件中</span><br><span class="line">        6. 主从节点通过binlog文件+position偏移量定位主从同步的位置，从节点会保存接收到的position偏移量，如果从节点发生宕机重启，自动从postion位置发起同步</span><br><span class="line">        7. 从节点的SQL线程复制读取本地relay log的内容，解析成具体的操作并执行，保证主从数据一致性</span><br><span class="line">    4. 主从复制的模式</span><br><span class="line">        1. 异步模式（默认方式）</span><br><span class="line">            1. 可能导致主从不一致（主从延时）</span><br><span class="line">            2. 主节点接收到客户端提交的事务之后直接提交事务并返回给客户端</span><br><span class="line">            3. 如果主节点事务提交之后，log dump还没来得及写入就宕机就会导致主从数据不一致</span><br><span class="line">            4. 不用关心主从的同步操作，性能最好            </span><br><span class="line">        2. 全同步模式</span><br><span class="line">            1. 可靠更高，但是会影响主库相应时间</span><br><span class="line">            2. 主节点接收到客户端提交的事务之后，必须等待binlog 发送给从库，并且所有从库全部执行完事务之后才返回给客户端</span><br><span class="line">        3.  半同步模式</span><br><span class="line">            1.  增加一部分可靠性，增加主库一部分相应时间</span><br><span class="line">            2.  主节点接收到客户端提交的事务之后，等待binlog发送给至少一个从库并且成功保存到本地relay log中，此时主库提交事务并返回给客户端</span><br><span class="line">        4. server-id的配置和server-uuid</span><br><span class="line">            1. server-id用于标识数据库实例，防止在链式主从、多主多从拓扑中导致SQL语句的无限循环</span><br><span class="line">            2. server-id默认值为0，对于主机来说依然会记录二进制日志，但是会拒绝所有的从机连接。</span><br><span class="line">            2. server-id = 0 对于从机来说会拒绝连接其他实例</span><br><span class="line">            3. server-id是一个全局变量，修改之hi偶必须重启服务</span><br><span class="line">            4. 主库和从库的server-id重复时</span><br><span class="line">                1. 默认replicate-same-server-id = 0，从库会跳过所有主从同步的数据，导致主从数据不一致</span><br><span class="line">                2. replicate-same-server-id = 1，可能导致无线循环执行sql</span><br><span class="line">            5. 两个从库（B、C）server-id重复会导致主从连接异常，时断时连</span><br><span class="line">                1. 主库（A）发现相同的server-id会断开之前的连接，重新注册新的连接</span><br><span class="line">                2. B、C从库的连接会周而复始的重连</span><br><span class="line">            6. MySQL服务会自动创建并生成server-uuid配置</span><br><span class="line">                1. 当主从同步时如果主从实例的server-uuid相同会报错退出，不过我们可以通过设置replicate-same-server-id=1来避免报错（不推荐）</span><br><span class="line"></span><br><span class="line">     5. 读写分离 </span><br><span class="line">         1. 基于代码实现，减少硬件开支</span><br><span class="line">         2. 基于中间代理实现</span><br><span class="line">         3. 主从延时</span><br><span class="line">             1. 从库性能比主库差</span><br><span class="line">             2. 大量查询导致从库压力大，消耗大量CPU资源，影响同步速度：一主多从</span><br><span class="line">             3. 大事务执行：事务执行完之后才会写入binlog，从库读取延时</span><br><span class="line">             4. 主库ddl（alter、drop、create）</span><br></pre></td></tr></table></figure>

<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ol>
<li>产生的四个必要条件<ol>
<li>互斥条件</li>
<li>请求与保持条件：一次性分配全部资源，否则一个都不分配</li>
<li>非剥夺条件：当进程获得一部分资源等待其他资源的时候释放占有的资源</li>
<li>循环等待条件：<br>理解：一个资源只能被一个进程占用，进程获取资源资源还能申请新的资源，并且已经获得的资源不能被剥夺，同时多个进程相互等待其他进程被占用的资源</li>
</ol>
</li>
<li>解除死锁<ol>
<li>终止进程（全部干掉）</li>
<li>逐个种植（杀一个看一下有没有解除）</li>
</ol>
</li>
</ol>
<h1 id="Mysql-优化大分页查询-limit-100000"><a href="#Mysql-优化大分页查询-limit-100000" class="headerlink" title="Mysql 优化大分页查询 limit 100000"></a>Mysql 优化大分页查询 limit 100000</h1><ol>
<li>原因<br> mysql查询分页数据时不是直接跳过offset(100000)，而是取offset + page_size  = 100000 + 10 = 100010条数据，然后放弃其掉前面的100000条数据，所以效率地下</li>
<li>优化方案<ol>
<li>延时关联：使用覆盖索引</li>
<li>主键阈值法：主键是自增的情况下，通过条件推算出符合条件的主键最大值&amp;最小值（使用覆盖索引）</li>
<li>记录上一页的结果位置，避免使用 OFFSET</li>
</ol>
</li>
</ol>
<h1 id="redis-缓存和-mysql-数据一致性"><a href="#redis-缓存和-mysql-数据一致性" class="headerlink" title="redis 缓存和 mysql 数据一致性"></a>redis 缓存和 mysql 数据一致性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">方式：</span><br><span class="line">    1. 先更新redis 再更新数据库</span><br><span class="line">        场景：update set value = 10 where value = 9</span><br><span class="line">        1. redis更新成功：redis value = 10</span><br><span class="line">        2. 数据库更新失败：mysql value = 9 </span><br><span class="line">        3. 数据不一致</span><br><span class="line">    2. 先更新数据库,再更新redis</span><br><span class="line">        场景： A进程update set value = 10 where value = 9 ；B进程 update set value = 11 where value = 9;</span><br><span class="line">        1. A 进程先更新数据库，还未写入缓存：mysql value = 10 ;redis value = 9</span><br><span class="line">        2. B 进程更新数据库并且提交事务，写入缓存：mysql value = 11；redis value = 11；</span><br><span class="line">        3. A 进程处理完请求提交事务，写入缓存：redis value = 10；</span><br><span class="line">        4. 最终 mysql value = 11; redis value = 10</span><br><span class="line">    3. 先删除缓存再更新数据库</span><br><span class="line">        场景：A进程update set value = 10 where value = 9 ；B进程查询value;</span><br><span class="line">        1. A 进程先删除缓存 还没来得及修改数据或者事务未提交</span><br><span class="line">        2. B 进程开始查询，没有命中缓存，所以查库并写入缓存 redis value = 9 </span><br><span class="line">        3. A 进程更新数据库完成 mysql value = 10</span><br><span class="line">        4. 最终 mysql value = 10；redis value = 9 </span><br><span class="line">解决方案：</span><br><span class="line">    1. 延时双删除</span><br><span class="line">        场景：A进程update set value = 10 where value = 9 ；B进程查询value;</span><br><span class="line">        1. A 进程先删除缓存 还没来得及修改数据或者事务未提交</span><br><span class="line">        2. B 进程开始查询，没有命中缓存，所以查库并写入缓存 redis value = 9 </span><br><span class="line">        3. A 进程更新数据库完成 mysql value = 10</span><br><span class="line">        4. A 进程估算延时时间，sleep之后再次删除缓存</span><br><span class="line">        5. 最终mysql value = 10;redis value 为空（下次查询直接查库）</span><br><span class="line">        6. 延时的原因时防止B进程在A进程更新完之后B进程还没来得及写入缓存 </span><br><span class="line">    2. 请求串行化</span><br><span class="line">        1. 创建两个队列 ：更新队列和查询队列</span><br><span class="line">        2. 当缓存不存在需要查库的时候将key存入更新队列</span><br><span class="line">        3. 如果查询未完成之前有新的请求进来，并且发现更新队列中还存在key则将key放入查询队列，则等待；不存在则重复第二步</span><br><span class="line">        4. 如果查询的数据发现查询队列已经存在则不需要再次写入队列</span><br><span class="line">        4. 数据更新完成之后rpop更新队列，同时rpop查询队列，释放查询请求</span><br><span class="line">        5. 查询请求可以使用while + sleep  查询缓存并且设置最大延迟时间，还没有完成则返回空</span><br></pre></td></tr></table></figure>

<h1 id="redis-中的-connect-和-pconnect"><a href="#redis-中的-connect-和-pconnect" class="headerlink" title="redis 中的 connect 和 pconnect"></a>redis 中的 connect 和 pconnect</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. connect             ：脚本结束之后释放连接</span><br><span class="line">    1. close :释放连接</span><br><span class="line">2. pconnect（长连接） ：脚本结束连接不释放，连接保持在php-fpm进程中，生命周期随着php-fpm进程的生命周期</span><br><span class="line">    1. close不释放连接</span><br><span class="line">        1. 只是当前php-cgi进程中不能再次请求redis</span><br><span class="line">        2. 当前php-cgi中的后续连接仍然可以复用，直到php-fpm结束生命周期</span><br><span class="line">    2. 减少建立redis连接的消耗</span><br><span class="line">    3. 减少一个php-fpm多次建立连接</span><br><span class="line">    4. 消耗更多的内存，并且连接数持续增加</span><br><span class="line">    5. 同一个php-fpm的woker子进程（php-cgi）的上一个请求可能会影响到下一个请求</span><br><span class="line">3. pconnect 的连接复用问题</span><br><span class="line">    1. 变量A select db 1 ；变量B select db 2；会影响到变量A的db</span><br><span class="line">    2. 解决：每一个db创建一个连接实例</span><br></pre></td></tr></table></figure>

<h1 id="redis-zset-有序集合使用-skiplist-的原理"><a href="#redis-zset-有序集合使用-skiplist-的原理" class="headerlink" title="redis zset 有序集合使用 skiplist 的原理"></a>redis zset 有序集合使用 skiplist 的原理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 基本概念</span><br><span class="line">     1. skiplist是一个随机的数据，以有序的方式在层次化的链表中保存元素（只能用于元素有序的情况）</span><br><span class="line">     2. skiplist实在有序链表和多层链表的基础上演变的</span><br><span class="line">     3. 允许重复值，所以对比检查除了要对比key 还要对比value</span><br><span class="line">     4. 每个节点都带有一个高度为1的后退指针，用于表头方向到表尾方向的迭代</span><br><span class="line">     5. 时间复杂度O(logn)、空间复杂度O(n)</span><br><span class="line"> 2. 跳跃表和平衡树的对比</span><br><span class="line">     1. 范围查询效率</span><br><span class="line">         1. 跳跃表范围查询效率更高，因为找到最小值之后只需要对第一层的链表进行遍历直到小于最大值即可</span><br><span class="line">         2. 平衡树范围查询找到最小值之后还要进行中序遍历找到其他不超过最大值的节点</span><br><span class="line">     2. 内存占用</span><br><span class="line">         1. skiplist 每个节点的指针数量为1/(1-p)</span><br><span class="line">         2. 平衡树的每个节点指针数都为2</span><br><span class="line">     3. 插入和删除操作</span><br><span class="line">         1. skiplist只需要修改相邻节点的指针</span><br><span class="line">         2. 平衡树变更会引起子树的调整</span><br></pre></td></tr></table></figure>

<h1 id="redis-的过期删除和淘汰机制"><a href="#redis-的过期删除和淘汰机制" class="headerlink" title="redis 的过期删除和淘汰机制"></a>redis 的过期删除和淘汰机制</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 常规过期删除策略</span><br><span class="line">    1. 定时删除</span><br><span class="line">        1. 通过定时器在过期的时候立即删除</span><br><span class="line">        2. 内存释放及时但是消耗更多的CPU，大并发的时候需要消耗CPU资源影响处理请求的速度    </span><br><span class="line">        3. 内存友好，CPU不友好</span><br><span class="line">    2. 惰性删除</span><br><span class="line">        1. 放任键过期不管，到下次需要去取出的时候检查是否过期并删除</span><br><span class="line">        2. 可能存在大量过期键，且不会使用，导致内存溢出</span><br><span class="line">        2. 内存不友好，CPU友好</span><br><span class="line">    3. 定期删除</span><br><span class="line">        1. 每隔一段时间检查，删除过期的键</span><br><span class="line">        2. 删除多少和检查多少有算法决定</span><br><span class="line">2. redis采用的 惰性删除 + 定期删除</span><br><span class="line">    1. 周期性随机测试一些设置了过期时间的键进行检查，到期则删除</span><br><span class="line">    2. 每次清理的时间不超过CPU的25%，达到时间则退出检查</span><br><span class="line">    3. 定期没有删除到的键，且以后不会使用的键还是会存在内存中，所以需要配合淘汰策略</span><br><span class="line">3. 淘汰策略（内存不足以写入新数据的时候执行）</span><br><span class="line">    1. volatile-lru     ：设置了过期时间且最近使用越少越优先淘汰</span><br><span class="line">    2. volatile-ttl     ：设置了过期时间且过期时间越早越优先淘汰</span><br><span class="line">    3. volatile-random    ：设置了过期时间中随机删除</span><br><span class="line">    4. allkeys-lru        ：所有键中过期时间越早越优先淘汰</span><br><span class="line">    5. allkeys-random    ：所有键中过期随机淘汰</span><br><span class="line">    6. no-enviction        ：不允许淘汰，内存不足报错</span><br></pre></td></tr></table></figure>

<h1 id="redis-常见问题及解决方案"><a href="#redis-常见问题及解决方案" class="headerlink" title="redis 常见问题及解决方案"></a>redis 常见问题及解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 缓存雪崩：同一时间大量缓存失效，导致请求直接查询数据库，数据库内存和CPU压力增加甚至宕机</span><br><span class="line">    解决：</span><br><span class="line">        1. 热点数据永不过期或者分布到不同实例，降低单机故障问题</span><br><span class="line">        2. 缓存时间添加随机数，防止大量缓存同时失效                </span><br><span class="line">        4. 做二级缓存或者双缓存，A为原始缓存 短时效，B为备份缓存 ，长期有效。更新时候双写缓存</span><br><span class="line">2. 缓存穿透：缓存和数据库都没有数据，大量请求下，所有请求直接击穿到数据库，导致宕机。</span><br><span class="line">    解决：</span><br><span class="line">        1. 布隆过滤器:长度为m的位向量或者位列表组成（仅包含0或1位值的列表）</span><br><span class="line">            1. 使用多个不用的hash函数，产生多个索引值，填充对应多个位置的值为1</span><br><span class="line">            2. 布隆过滤器可以检查值是 “可能在集合中” 还是 “绝对不在集合中”</span><br><span class="line">            2. 可能误判但是基础过滤效率高</span><br><span class="line">            3. 极端情况，当布隆过滤器没有空闲位置的时候每次查询返回true</span><br><span class="line">        2. 空缓存（短时效）</span><br><span class="line">        3. 业务层参数过滤</span><br><span class="line">3. 缓存击穿：数据库中有数据，但是缓存突然失效之后发生大量请求导致数据库压力增加甚至打垮宕机</span><br><span class="line">    解决：</span><br><span class="line">        1. 热点数据永不过期</span><br><span class="line">        2. 互斥锁：获取锁之后不管成功还是失败都要释放锁</span><br></pre></td></tr></table></figure>

<h1 id="php-fpm-详解及生命周期"><a href="#php-fpm-详解及生命周期" class="headerlink" title="php-fpm 详解及生命周期"></a>php-fpm 详解及生命周期</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. 基础知识</span><br><span class="line">    1. CGI协议</span><br><span class="line">        1. 动态语言的代码文件需要通过对应的解析器才能被服务器识别</span><br><span class="line">        2. CGI协议就是用来使服务器和解释器相互通信的</span><br><span class="line">        3. 服务器解析PHP文件需要PHP解释器加上对应的CGI协议        </span><br><span class="line">    2. CGI程序 = php-cgi</span><br><span class="line">        1. php-cgi就是一个遵守CGI协议的CGI程序</span><br><span class="line">        2. 同时也就是PHP解释器</span><br><span class="line">        3. 标准的CGI每个请求都会解析php.ini，初始化执行环境等，降低性能</span><br><span class="line">        4. 每次修改配置之后需要重新php-cgi才能让php.ini生效</span><br><span class="line">        5. 不能动态worker调度，只能一开始指定数量的worker</span><br><span class="line">    2. FastCGI协议 </span><br><span class="line">        1. 和CGI一样也是一个协议/规范，不过是再CGI的基础上优化，效率更高</span><br><span class="line">        2. 用来提高CGI程序性能的</span><br><span class="line">        3. 实现了CGI进程的管理</span><br><span class="line"></span><br><span class="line">    3. FastCGI程序  = php-fpm</span><br><span class="line">        1. php-fpm就是一个遵守FastCGI协议的FastCGI程序        </span><br><span class="line">        2. FastCGI程序对CGI程序的管理模式</span><br><span class="line">            1. 启动一个master进程，解析配置文件，初始化环境</span><br><span class="line">            2. 启动多个worker子进程</span><br><span class="line">            3. 接受到请求之后，传递给woker进程去执行</span><br><span class="line">        3. 解决修改php.ini之后平滑重启问题</span><br><span class="line">            1. process_control_timeout:子进程接受主进程复用信号的超时时间(在规定时间内处理完请求，完成不了就不管了)</span><br><span class="line">            2. 设定php-fpm留给fastcgi进程响应重启信号的时间</span><br><span class="line">            3. process_control_timeout = 0，也就是不生效，无法保证平滑重启</span><br><span class="line">            4. process_control_timeout设置过大可能导致系统请求堵塞 </span><br><span class="line">            5. process_control_timeout =10的情况下，如果代码逻辑需要11s，重启旧可能导致代码执行部分退出</span><br><span class="line">            6. 建议值：request_terminate_timeout</span><br><span class="line">        4. 重启类型</span><br><span class="line">            1. 优雅重启</span><br><span class="line">            2. 强制重启</span><br><span class="line">    2. php-fpm生命周期：待更新</span><br><span class="line">        PHP-FPM 生命周期:https://www.abelzhou.com/php/php-fpm-lifespan/#</span><br></pre></td></tr></table></figure>

<h1 id="Nginx-和-php-之间的通信"><a href="#Nginx-和-php-之间的通信" class="headerlink" title="Nginx 和 php 之间的通信"></a>Nginx 和 php 之间的通信</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 通信方式：fastcgi_pass</span><br><span class="line">    1. tcp socket</span><br><span class="line">        1. 跨服务器，nginx和php不在一个机器时，只能用这个方式</span><br><span class="line">        2. 面向连接的协议，更好的保证通信的正确性和完整性</span><br><span class="line">    2. unix socket</span><br><span class="line">        1. 不需要网络协议栈、打包拆包等</span><br><span class="line">        2. 减少tcp 开销，效率比tcp socket 更高</span><br><span class="line">        3. 高并发时候不稳定，连接数暴增产生大量的长时缓存，大数据包可能直接返回异常</span><br></pre></td></tr></table></figure>

<h1 id="web-漏洞及问题"><a href="#web-漏洞及问题" class="headerlink" title="web 漏洞及问题"></a>web 漏洞及问题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. sql注入</span><br><span class="line">2. XSS攻击</span><br><span class="line">    推荐阅读(很详细的案例来分析XSS攻击的不同类型及解决方案)：[前端安全系列（一）：如何防止XSS攻击？](https://tech.meituan.com/2018/09/27/fe-security.html)</span><br><span class="line">3. CSRF攻击：</span><br><span class="line">    推荐阅读 ：[前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)</span><br><span class="line">4. 文件上传漏洞</span><br><span class="line">    推荐阅读 ：[浅析文件上传漏洞](https://xz.aliyun.com/t/7365)</span><br><span class="line">5. 跨域问题：</span><br><span class="line">    推荐阅读 ：</span><br><span class="line">        1. [前端常见跨域解决方案（全）](https://segmentfault.com/a/1190000011145364)</span><br><span class="line">        2. [JSONP原理详解——弄懂JSONP及其实现方法](https://juejin.cn/post/6844904024924225544)</span><br><span class="line">    1. jsonp</span><br><span class="line">    2. cors</span><br><span class="line">    3. nginx代理</span><br></pre></td></tr></table></figure>
<h1 id="魔术方法原理及使用场景"><a href="#魔术方法原理及使用场景" class="headerlink" title="魔术方法原理及使用场景"></a>魔术方法原理及使用场景</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1. __cocnstruct() 构造方法</span><br><span class="line">    详解：</span><br><span class="line">        1. 对象被实例化的时候首先调用</span><br><span class="line">        2. 初始化数据、初始化属性</span><br><span class="line">2. __destruct() 析构方法</span><br><span class="line">    详解：</span><br><span class="line">        1. 对象销毁前调用该方法</span><br><span class="line">        2. 释放资源防止内存溢出和单个进程占用过多内存</span><br><span class="line">3. __get()、__set()</span><br><span class="line">    详解：</span><br><span class="line">        1. 调用或者设置对象未定义的属性是触发</span><br><span class="line">        2. 属性的一些格式化或者处理</span><br><span class="line">4. __isset()</span><br><span class="line">    详解：</span><br><span class="line">        1. 对不可访问属性调用isset()或者empty()时调用</span><br><span class="line">5. __unset()</span><br><span class="line">    详解：</span><br><span class="line">        1. 对不可访问属性调用unset()时调用</span><br><span class="line">6. __call() 、__callStatic()</span><br><span class="line">    详解：</span><br><span class="line">        1. 调用不存在的方法或者调用不存在的静态方法时执行</span><br><span class="line">        2. 调用不存在的方法php会抛出致命错误，该方法可以进行错误日志或者重定向、抛出异常等处理</span><br><span class="line">7.  __sleep () </span><br><span class="line">    详解：</span><br><span class="line">        1. 执行serialize()时调用</span><br><span class="line">8.  __wakeup ()</span><br><span class="line">    详解：</span><br><span class="line">        1. 执行unserialize()时调用</span><br><span class="line">9. __clone()</span><br><span class="line">    详解：</span><br><span class="line">        1. 对象复制完成时调用</span><br><span class="line">        2. 克隆示例或者单例模式 防止克隆</span><br><span class="line">10. __autoload（）</span><br><span class="line">    详解：</span><br><span class="line">        1. 尝试加载未定义的类时候调用</span><br><span class="line">        2. 惰性加载/懒加载/lazy loading</span><br><span class="line">11. __toString()</span><br><span class="line">12. __invoke()</span><br><span class="line">13. __set_state</span><br></pre></td></tr></table></figure>

<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 乐观锁：执行更新的时候判断其他进程是否修改了数据，如果修改了就放弃修改</span><br><span class="line">    1. 实现机制：</span><br><span class="line">        1. 版本号机制：数据表加一个version版本号字段，每次修改+1。</span><br><span class="line">        2. CAS算法</span><br><span class="line">    2. 场景：读取频繁场景</span><br><span class="line">2. 悲观锁：先取锁再操作-操作数据的时候把数据锁住，操作完成之后才会释放，释放锁之前其他进程不能修改数据</span><br><span class="line">    1. 实现机制</span><br><span class="line">        1. select * from table where id = 1 for update</span><br><span class="line">    2. 场景：写入操作频繁的场景</span><br></pre></td></tr></table></figure>

<h1 id="mysql-一次查询索引使用"><a href="#mysql-一次查询索引使用" class="headerlink" title="mysql 一次查询索引使用"></a>mysql 一次查询索引使用</h1><ol>
<li>一次查询只能使用1个，所以要合理的使用组合索引，而不是单列索引。</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#php-%E6%95%B0%E7%BB%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">php 数组底层实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">冒泡排序的时间复杂度和空间复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A-TCP-%E5%92%8C-UDP"><span class="toc-number"></span> <span class="toc-text">网络七层协议及 TCP 和 UDP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">TCP 和 UDP 的特点和区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number"></span> <span class="toc-text">TCP 的三次握手和四次挥手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">HTTP 状态码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">http 和 HTTPS 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8F%8A%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">redis 分布式锁及问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">redis 的数据类型及应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">redis 实现持久化的方式及原理、特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E5%8F%8A%E9%9A%BE%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">秒杀设计流程及难点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2-sql-%E6%B3%A8%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">防 sql 注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">索引原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E8%A1%A8-%E5%88%86%E5%BA%93-%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number"></span> <span class="toc-text">分表 (分库) 的策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#select-%E5%92%8C-update-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">select 和 update 的执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binlog-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">binlog 的作用和三种格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E9%97%AE%E9%A2%98%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number"></span> <span class="toc-text">主从同步（主从复制）的原理和问题及读写分离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number"></span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql-%E4%BC%98%E5%8C%96%E5%A4%A7%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-limit-100000"><span class="toc-number"></span> <span class="toc-text">Mysql 优化大分页查询 limit 100000</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E7%BC%93%E5%AD%98%E5%92%8C-mysql-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">redis 缓存和 mysql 数据一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E4%B8%AD%E7%9A%84-connect-%E5%92%8C-pconnect"><span class="toc-number"></span> <span class="toc-text">redis 中的 connect 和 pconnect</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-zset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8-skiplist-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">redis zset 有序集合使用 skiplist 的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">redis 的过期删除和淘汰机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number"></span> <span class="toc-text">redis 常见问题及解决方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#php-fpm-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number"></span> <span class="toc-text">php-fpm 详解及生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx-%E5%92%8C-php-%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number"></span> <span class="toc-text">Nginx 和 php 之间的通信</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#web-%E6%BC%8F%E6%B4%9E%E5%8F%8A%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">web 漏洞及问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">魔术方法原理及使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number"></span> <span class="toc-text">乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql-%E4%B8%80%E6%AC%A1%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">mysql 一次查询索引使用</span></a>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&text=面试资料笔记整理01"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&is_video=false&description=面试资料笔记整理01"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=面试资料笔记整理01&body=Check out this article: https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&title=面试资料笔记整理01"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&name=面试资料笔记整理01&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://tlcydev.github.io/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%8601/&t=面试资料笔记整理01"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2022
    快乐的杨蛆
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
